{"data":{"site":{"siteMetadata":{"blogTitle":"LaySent's Blog","author":"LaySent"}},"markdownRemark":{"id":"c9655f88-e926-5a7a-a307-6a369c6fde11","html":"<section><h1>访客端</h1><section><h2>storybook</h2><p>storybook 是一个库，用于展示 React 组件的效果的。在访客端项目中，这个功能已经基本不用了。如果需要重新使用，需要先修复 <code class=\"language-text\">.storybook</code> 目录下 webpack.config.js 文件中的配置问题：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  resolve<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    alias<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// ...</span>\n      <span class=\"token string\">'@'</span><span class=\"token punctuation\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'..'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'src'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'css'</span><span class=\"token punctuation\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'..'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'css'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>加上上面的两行之后，<code class=\"language-text\">npm run story</code> 命令就可以正确执行了。执行成功后，会在 6006 端口开启一个新的服务（6006 是写死在 npm script 的定义里的，见 package.json 文件）。访问这个地址，可以看到各种控件的实时展示。修改 src 文件夹下任意一个 xx.story.js 的文件，保存之后，就可以看到最终的结果。</p><p>这里，由于访客端用的是 preact 而不是 react，与 storybook 的默认配置不同，所以在 webpack.config.js 中，用 resolve alias 的方式配置了使用 preact-compat 来做兼容。兼容的效果不是百分百的。只是大体上可以达到使用的效果。</p><p>但是目前这个部分已经无人维护了。很多控件的展示存在错误。如果需要重新使用起来，需要把这里一些报错的地方先修复掉。</p><p>.storybook/config.js 文件主要是针对 storybook 的一些配置。重点做了两件事情：</p><ol>\n<li>将各个 css 文件从 css 文件夹下面读取出来，将颜色信息和字体信息替换掉，然后以 style 的形式插入到页面中</li>\n<li>监听 src/components 下面，以 story.jsx 结尾的文件改动，一旦发生变化，就重新渲染。</li>\n</ol><p><code class=\"language-text\">npm run story</code> 定义在 package.json 中，实际运行的是 <code class=\"language-text\">start-storybook -p 6006 -c .storybook -s ./css</code> 命令，其中 start-storybook 是 storybook 提供的 bin，p 指定了端口号，c 指定了配置文件的位置，也就是 .storybook 目录，s 指定了静态目录的为止。</p></section><section><h2>vs</h2><p>.vs 目录应该是被无意中签入的，实际并未用到</p></section><section><h2>vscode</h2><p>.vscode 目录下存放的是和 VSCode 相关的一些配置文件。因为平常的前端开发，一般都使用 VSCode 作为主要的编辑器，这里的配置一旦提交到代码库中，将能一定程度上的同步各个开发人员之间的编辑器配置。</p><section><h3>launch.json</h3><p>这个文件配置是为了 VSCode Debug 的时候使用的。</p><p>这里 configurations 里面，第一个写的内容应该是没有实际作用的。configurations 第二个配置主要是为了 Jest 在做单元测试的时候，调试用的。下面以调试 helper.test.js 为例，简单介绍一下用 VSCode 调试的步骤：</p><ol>\n<li>打开 helper.test.js 这个文件，位置是 src/utils/helper.test.js</li>\n<li>在 VSCode 中，选中左侧菜单的第四个 icon，可以进入 Debug 的面板</li>\n<li>在 Debug 面板的右侧顶部下拉菜单中，选择 Jest Debug，及使用 launch.json 中第二个 configurations 的配置</li>\n<li>在 helper.test.js 文件的任意位置，点击行标，设置断点（比如，点击 499 在第 499 行设置一个断点）</li>\n<li>在右侧顶部选中 > 按钮，开始 Debug 模式</li>\n<li>VSCode 会开始用 jest 运行 helper.test.js 文件，并在 499 行挺住</li>\n<li>可以通过 VSCode 了解当前的程序运行状态，或者单步调试来执行后续代码</li>\n</ol><p>launch.json 配置里的一些说明：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  type<span class=\"token punctuation\">:</span> <span class=\"token string\">'node'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 运行环境是 Node</span>\n  request<span class=\"token punctuation\">:</span> <span class=\"token string\">'launch'</span><span class=\"token punctuation\">,</span>\n  protocol<span class=\"token punctuation\">:</span> <span class=\"token string\">'inspector'</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Jest Debug'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 显示在 Debug 下拉菜单中的名字</span>\n  program<span class=\"token punctuation\">:</span> <span class=\"token string\">'${workspaceRoot}/node_modules/jest/bin/jest'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 执行文件的位置</span>\n  stopOnEntry<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不需要在运行一开始就直接停住，默认是直接在文件设置断点的地方停住就可以了</span>\n                      <span class=\"token comment\">// 对于单元测试来说，只需要在有问题的测试用例中停顿就可以了</span>\n                      <span class=\"token comment\">// 如果是其他的情况，在调试一开始的时候就直接停住，有助于设置进一步的断点位置</span>\n  args<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'--runInBand'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token string\">'--env=jsdom'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 访客端需要 jsdom 作为运行环境</span>\n    <span class=\"token string\">'${fileBasename}'</span> <span class=\"token comment\">// 这里默认只执行打开着的那一个文件，如果打开的是 helper.test.js 就只执行这一个文件</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  runtimeArgs<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'--inspect-brk'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  cwd<span class=\"token punctuation\">:</span> <span class=\"token string\">'${workspaceRoot}'</span><span class=\"token punctuation\">,</span>\n  sourceMap<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  console<span class=\"token punctuation\">:</span> <span class=\"token string\">'integratedTerminal'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div></section><section><h3>settings.json</h3><p>settings.json 文件主要记录的是 VSCode 在本项目中的一些配置，一定程度上在开发人员间做到配置共享。以下是一些说明：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  <span class=\"token string\">'javascript.validate.enable'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token comment\">// 默认 VSCode 会做一些 JavaScript 的检查。但是对于一些较新的语法，可能会导致 VSCode 检查出现错误。项目中直接使用 ESLint 做检查，这里默认就把 VSCode 的检查关闭了。考虑到这几年 JavaScript 的支持发展很快，大部分在访客端中用到的功能应该都已经默认支持了，可以考虑重新打开来看看效果。</span>\n  <span class=\"token string\">'files.exclude'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 这里主要设置了一些不需要在 VSCode 中展示出来的文件，包括 node_modules 等。如果</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token string\">'files.eol'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'\\n'</span> <span class=\"token comment\">// 使用 \\n 而不是 \\r\\n 这个 Windows 默认的转行符号，保持不同系统间的统一。ESLint 也有专门针对这一点的 rule 配置</span>\n  <span class=\"token string\">'search.exclude'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 这里配置了一些不需要在搜索结果中出现的文件，基本上除了 src 和 css 中的文件，其他的基本都不需要可以搜索到（css 中编译出来的 .min.css 文件耶不需要可以搜索到。这里的配置可以按需调整</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'file.associations'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 有一些文件，VSCode 无法通过后缀来判断文件的语法类型，这里可以做配置</span>\n    <span class=\"token comment\">// 注意：这里的配置是写错了的，应该是 files.associations，而不是 file.associations</span>\n    <span class=\"token comment\">// 这里的配置实际上是没有生效的，需要修改一下</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'editor.rulers'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">80</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 这里会在 80 个字符和 100 个字符处各增加一个竖线。一般不建议超过一行 80 个字符，ESLint 中配置了代码长度不能超过 100 个字符，否则会报错。这里的 rulers 主要是视觉上提供一个边界提醒</span>\n  <span class=\"token string\">'editor.tabSize'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token comment\">// 默认将 tab 等同于两个空格，保持视觉上的良好体验，同时也不至于占太多控件</span>\n  <span class=\"token string\">'editor.insertSpaces'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// VSCode 会在按下 tab 的时候，插入 space</span>\n  <span class=\"token string\">'files.trimTrailingWhitespace'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// VSCode 会在保存的时候，将每一行文末多余的空格给删除</span>\n  <span class=\"token string\">'stylelint.config'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'extends'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'stylelint-config-standard'</span> <span class=\"token comment\">// 针对 stylelint 的配置，指明用到的配置文件是 stylelint-config-standard</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token string\">'cssrem.rootFontSize'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">15</span> <span class=\"token comment\">// 这两个都是 cssrem 插件的配置，访客端默认的 1rem = 15px，定义的位置在 chat-button.less，side-window.les 和 style.less 中都有涉及</span>\n  <span class=\"token string\">'cssrem.autoRemovePrefixZero'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span></code></pre></div></section></section><section><h2>api</h2><p>这个目录下面，存放的是访客端对外开放的 JavaScript API 的文档，以及展示文档需要用到的 <a href=\"https://github.com/docsifyjs/docsify\">docsify</a> 代码。</p><p>文档的实体内容写在 readme.md 文件中。</p><p>docsify 相关的主要是 docsify.min.js，<a href=\"unpkg.com/docsify/lib/plugins/search.min.js\">search.min.js</a> 以及 style.css 三个部分。其中 docsify.min.js 是 docsify 的核心功能，search.min.js 提供了 docsify 的搜索插件，style.css 是对应的样式文件。我们使用的是 4.3.13 版本。</p><p>index.html 里面，除了设置了一些 meta 值之外，主要有一个 <code class=\"language-text\">window.$docsify</code> 的配置。说明如下：</p><div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  search<span class=\"token punctuation\">:</span> <span class=\"token string\">'auto'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 默认搜索</span>\n  loadNavbar<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 设置为 true，navbar 会从 _navbar.md 中读取内容。这里其实可以设置为 false，_navbar.md 实际中并未使用</span>\n  homepage<span class=\"token punctuation\">:</span> <span class=\"token string\">'../readme.md'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 主页就是 API 文档的正文（和 index.html 同级的 readme.md 文件）</span>\n  loadSidebar<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 没有 sidebar</span>\n  maxLevel<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 目录最多三层深</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Comm100 Live Chat'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 侧边栏顶部的文字</span>\n  themeColor<span class=\"token punctuation\">:</span> <span class=\"token string\">'#329fd9'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 主题色</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>更多的配置，见<a href=\"https://docsify.js.org/#/configuration\">官方文档</a>。</p><p>文档最终发布的位置，见：<a href=\"https://ent.comm100.com/LiveChatFunc/doc/CustomJS/index.html\">https://ent.comm100.com/LiveChatFunc/doc/CustomJS/index.html</a></p><p>编译的时候完成后，api 整个目录会被放到 ent 和 hosted 下，livechatfunc/doc/customJS 目录下面。这里的位置配置见 branding.yaml 中，deploy 下 api 的部分</p></section><section><h2>assets</h2><p>assets 目录下存放了非常少量的图片资源。Rollup 不具备打包各种非 JavaScript 内容的能力，所以这里要处理图片并不非常容易。现在的做法是这样的：在 assets 下面放好文件，然后程序在编译的时候会去读取这些文件，将这些文件的内容转化成 base64 编码的字符串，然后赋值给 process.env.ASSETS.filename.png 这样的全局变量。程序中以字符串的形式对这些内容引用。这里，编译的过程见 build/getEnvValues.js 文件。</p></section><section><h2>build</h2><section><h3>browserlist.js</h3><p>这个文件里面主要定义了 browserlist 的配置，browserlist 的配置是给 Babel 编译使用的。babel-preset-env 会根据 browserlist 的配置，来选择哪些语法需要被转换，哪些语法可以直接使用。目前，访客端的浏览器支持如下：</p><ul>\n<li>占有率在 5% 以上的浏览器</li>\n<li>每个主流浏览器的最新两个版本</li>\n<li>IE9+</li>\n</ul></section><section><h3>build.iframe.js</h3><p>这个文件的作用是编译出页面文件。访客端有一些地方需要用到页面文件，比如说弹出式窗口，（）等。这些页面文件统一都用这个文件编译出来。在编译的时候，通过给定一个参数来指定最终编译出来的文件的名称。比如 <code class=\"language-text\">node ./build/build.iframe.js xxx.html</code>，那么最终编译出来的文件就是 xxx.html。如果不指定，程序会报错，不会执行（见文件的最后几行代码）</p><p>程序的执行逻辑如下：</p><ol>\n<li>根据指定的 xxx.html 文件名，找到 src/xxx 目录下的 index.js 文件，作为编译的起始文件（ln 181）</li>\n<li>编译完成后，生成 iife 形式的最终代码（ln 129）</li>\n<li>读取 iframe.ejs 模板文件，把生成的代码插入到 &#x3C;%- script %> 指定的位置（ln 134-139）</li>\n<li>压缩 HTML 代码（ln 140-152）</li>\n<li>在 HTML 的顶部增加一些编译的信息。包括当前的版本号（从 package.json 中读取），build 的时间（这里手写了一个输出时间格式的函数 now，主要是为了模糊时区的信息，不让人知道编译时间集中在东八区的白天），git 的 commit id 。这些信息主要的作用是，在发布之后，如果出现了问题，比较容易知道具体是从哪里编译出来的版本；同时，测试在测试版本的时候，也可以通过这里的数据简单检查一下，看是否使用到了最新提交的版本。</li>\n<li>将最终的代码存储到 dist 目录下，同一份代码会生成多份输出文件。内容是一样的，但是文件名不同，主要是增加了 free （给免费服务器用），或者增加了 hash 值（用 sha1 计算出来的指纹）。具体的使用，Roy 比较清楚。</li>\n</ol><p>其中，JavaScript 部分的编译配置如下：</p><ul>\n<li>会根据命令行是否有 —production 或 -p 来确定是否要编译压缩的代码。如果要，就使用 uglify 来压缩代码。其中，ascii<em>only 的配置让 uglify 只使用 ascii 的字符而不使用 unicode，避免不必要的解析问题。unsafe</em>math 和 side_effects 可以在一定程度上进一步压缩代码，主要是可以提前计算部分信息。目前使用上没有发现异常。如果这里的压缩导致了程序异常，可以考虑把相关的配置去掉。</li>\n<li>rollup-plugin-json 使得程序可以直接 import json 文件，import 后的值就是一个 JavaScript object</li>\n<li>\n<p>alias 的部分做了这么几件事情：</p>\n<ul>\n<li>import 的时候不需要指定后缀，默认会试试 .js 或者 .jsx，都不行的话就不添加额外的后缀，这是 resolve 的定义部分</li>\n<li><code class=\"language-text\">@/xxx</code> 会被指定为 <code class=\"language-text\">src/xxx</code>，是一个简写的方式，用绝对引用代替一般的相对引用</li>\n<li><code class=\"language-text\">css/xxx</code> 会被指定为 <code class=\"language-text\">css/xxx</code>，也是一个简写的方式，这样深层的 js 文件可以直接引用顶层的 css 目录下的文件，而不需要写很多的 <code class=\"language-text\">../</code></li>\n</ul>\n</li>\n<li>resolve plugin 的作用有点忘了（看上去 browser:false 的部分不是非常必要），可以试试删掉会出现什么问题，会比较清楚当初为啥加上</li>\n<li>babel 的部分是 babel 的配置：不使用顶层的 babelrc 文件（babelrc: false），presets 主要是用到了 babel-preset-env（browserlist 的配置在这里使用），babel-preset-stage-3 和 babel-preset-react。访客端的项目，babel 还没有升级，升级之后这里 stage 的配置应该就不需要了。plugin 的部分，transform-react-jsx 是转化 jsx 文件用的，由于使用的是 preact 而不是 react 库，需要指定 pragma: ‘h’；external-helpers 可以插入一些必要的辅助函数；transform-string-join 是一个小的 babel 插件，可以提前计算 string 的合并，把 <code class=\"language-text\">[&#39;a&#39;, &#39;b&#39;].join(&#39;,&#39;)</code> 编译成 <code class=\"language-text\">&#39;a,b&#39;</code>，具体可以看这个插件的说明文档。如果是 production 模式，孩会用 transform-remove-console 来删掉 console 的使用（IE9 默认不开 devtool 使用 console 会报错，线上也不应该有额外的 console 输出）transform-react-remove-prop-types 可以把 .propTypes 的定义删除（这里因为 JavaScript 的动态性，默认 .propTypes 是不会删除的，但是从业务上来说，线上的代码不需要 propTypes 的检查，删除不影响使用，还可以减少包的大小）</li>\n<li>replace 的部分，可以把一些定义过的 process.env. 变量替换为具体的值。（比如把 process.env.ASSETS.xxx.png 替换为 assets/xxx.png 文件的 base64 字符串等，具体说明见 getEnvValues.js 文件部分）</li>\n</ul></section><section><h3>deploy.js</h3><p>这个文件做一个非常简单的事情，把 dist 目录下编译好的内容，根据 branding.yaml 中的配置，复制到 deploy 目录下指定的子目录中。这样的目的，是可以方便提供一个完整的包给测试。</p><p>从 dist 目录到 deploy 目录的文件映射关系，见 branding.yaml 中的 deploy 字段（每个 branding 都会有一个 deploy 字段，其中 livechat100 的部分应该已经没有用了，这个 branding 已经不在维护了）</p><p>branding.yaml 中的 deploy 书写，形式如下：key 的部分是 dist 中目录的名称，key 对应的 value 是一个数组，表示映射到的 deploy 目录的位置。这里的映射是一个一对多的关系，因为存在很多个不同的服务器，都需要发布。这里，key 的文件名允许出现 *，可以匹配一段不包含 . 的字符串（见 ln 13），主要是用来匹配 hash 值的。value 数组中的字符串，可以使用 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">示</mi><mi mathvariant=\"normal\">原</mi><mi mathvariant=\"normal\">始</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">文</mi><mi mathvariant=\"normal\">件</mi><mi mathvariant=\"normal\">名</mi><mi mathvariant=\"normal\">称</mi><mi mathvariant=\"normal\">，</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi mathvariant=\"normal\">.</mi><mi>j</mi><mi>s</mi><mi mathvariant=\"normal\">会</mi><mi mathvariant=\"normal\">在</mi><mi mathvariant=\"normal\">复</mi><mi mathvariant=\"normal\">制</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">时</mi><mi mathvariant=\"normal\">候</mi><mi mathvariant=\"normal\">直</mi><mi mathvariant=\"normal\">接</mi><mi mathvariant=\"normal\">替</mi><mi mathvariant=\"normal\">换</mi><mi mathvariant=\"normal\">掉</mi><mi mathvariant=\"normal\">；</mi></mrow><annotation encoding=\"application/x-tex\">name 表示原始的文件名称，deploy.js 会在复制的时候直接替换掉；</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">e</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">示</span><span class=\"mord cjk_fallback\">原</span><span class=\"mord cjk_fallback\">始</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">文</span><span class=\"mord cjk_fallback\">件</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord cjk_fallback\">称</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">.</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord mathdefault\">s</span><span class=\"mord cjk_fallback\">会</span><span class=\"mord cjk_fallback\">在</span><span class=\"mord cjk_fallback\">复</span><span class=\"mord cjk_fallback\">制</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">候</span><span class=\"mord cjk_fallback\">直</span><span class=\"mord cjk_fallback\">接</span><span class=\"mord cjk_fallback\">替</span><span class=\"mord cjk_fallback\">换</span><span class=\"mord cjk_fallback\">掉</span><span class=\"mord cjk_fallback\">；</span></span></span></span>server-version 表示对应的服务器版本号，在 deploy.js 中会做替换，这里的值是从 package.json 里的 server-version 中取得的。</p><p>同时，如果一个 dist 中的文件名是 branding-name.filename 的形式，最终复制到 deploy 目录下的时候，branding-name 会被删除，最终的名字是 filename。如果 branding-name 的部分和指定的 branding name 不符合，那么这个目录/文件就不会被复制。</p></section><section><h3>getBranding.js</h3><p>这个文件提供了和 branding 相关的各种辅助函数。在之前的项目里，有需求需要一份代码可以编译出不同 UI，不同商标的最终代码。因而需要一个 branding.yaml 文件来指定一些差异化的地方（比如 logo）。在实际编译的时候，通过命令行 —branding xxx 来指定当前需要编译的 branding 是哪一个（对应到 branding.yaml 中顶层的某一个 key，比如 —branding comm100 用于编译 comm100）</p><ul>\n<li>getName 用于检查通过命令行 —branding 提供的 branding 是哪一个</li>\n<li>getConfig 用于根据提供的 branding name 来读取 branding.yaml 中相对应的 branding 配置，返回是一个 object</li>\n<li>getAllConfig 用于获取所有的 config</li>\n<li>hasNameProvided 用于判断 —branding name 是否提供了</li>\n</ul></section><section><h3>getEnvValues.js</h3><p>这个文件主要是给 rollup 中的 replace 用的，用于字符串的替换。主要做这么几个事情：</p><ol>\n<li>process.env.NODED_ENV 判断是否是 production，还是 development</li>\n<li>process.env.IS_PREVIEW 判断当前的运行环境，是不是给 Control Panel 中，LiveChatFun 下面的聊天窗口 preview 使用的</li>\n<li>process.env.USE_PARENT 这个用于决定代码中是否可以直接使用 window 作为顶层的 object（对于嵌入式窗口来说，window.top 才是顶层，但是对于弹出窗口来说，没有了 iframe，直接 window 就是顶层了）</li>\n<li>process.env.IS_CORDOVA 用于判断是否是 cordova 的代码，true or false</li>\n<li>process.env.IS_GALLERY 用于判断当前的代码是不是给 gallery 用的（gallery 通过生成各种 redux state 来创建各种 UI 结果，通过图像对比来判断代码改动是否符合预期）</li>\n<li>process.env.IS_BotPreview 判断是否是 control panel bot 部分的 preview</li>\n<li>webrtc-adapter 在 Cordova 的环境下不应该被引用（rollup 不支持动态的 import，所以这里用 replace 的方法直接删除 webrtc-apdater 引用的相关代码）</li>\n<li>process.env.BRANDING.xxx.yyy 的值，就是 branding.yaml 中，某一个 branding 下面，xxx.yyy 的值（这里的 branding 通过 —branding name 来指定）</li>\n<li>process.env.ASSETS.xxx.png 的值，是一个 base64 的字符串，对应的是 assets 目录下的 xxx.png 图片的值。由于图片很少而且比较小，直接通过 base64 的方式编译到 js 文件中并不会增加太多额外的代码量。</li>\n</ol></section><section><h3>iframe.ejs</h3><p>build.iframe.js 中需要用到的模板文件。在编译 html 文件的时候，目前都会公用这个模板文件。主要的区别就是插入的 script 不同，script 是通过 build.iframe.js 编译出来的，不同的文件对应的入口文件不同，所以最终的结果不同。</p></section><section><h3>less.config.js</h3><p>这个文件是用于编译 css 文件的。访客端的 css 使用了 less 作为编译器。目前需要编译出来的 css 一共有三个，分别是 style.min.css / chat-button.min.css / side-window.min.css，对应的入口文件分别是 style.less / chat-button.less / side-window.less（见 ln 34-35）</p><p>如果命令行检测到了 —watch，那么就会开启 less 编译的 watch 模式，每次 less 文件改动，都会触发重新编译。同时，如果开启了 js 的 watch 编译模式，css 的改动又会触发 js 的编译，最终编译完成后，刷新页面就可以看到效果。</p><p>convertAll 函数加上了 debounce，也是考虑到 watch 模式下，一个简单的改动可能多次触发编译。确保 100ms 内的多次修改只会触发一次真正的编译。</p><p>less 的编译用到了两个插件，分别是 autoprefix（用于给老版本的浏览器加上一些 prefix 的支持，用到的 browserlist 信息依然来自 browserlist.js），一个是 clean-css，用于 css 的代码优化。</p></section><section><h3>rawTransformer.js</h3><p>这个是给 jest 使用的模块。直接把引用 css 的地方直接处理成空字符串。（使用位置见 package.json 中 ln 185）</p><p>因为在 rollup 的配置里面，css 也是被处理成 plain string 直接引用的，所以在单元测试的时候，至少保证变量的类型是一样的。但是，因为单元测试 js 的内容不关心具体 css 的值，所以这里的输出只需要空字符串就可以了，不需要具体的内容。</p></section><section><h3>release.js</h3><p>这个文件是 npm run release 的时候调用的。做这么几件事情：</p><ol>\n<li>检查是否有没签入的 git 改动，有的话不允许 release 编译。这里的目的，是为了避免在没有签入的情况下，本地编译一个最终会上线的包。由于没有签入，一旦后续需要修改 bug，会导致找不到原来的基准版本。造成不必要的麻烦。（注：这里的代码不知道为什么被删除了，建议找回来）</li>\n<li>删除 dist 和 deploy 两个目录下的内容</li>\n<li>依次执行各个编译命令</li>\n<li>npm run build:font 编译字体</li>\n<li>将 css/image 文件下的图片复制到 dist 目录下，每一个 branding name 复制一份（ln 83-86）</li>\n<li>将 api 文档复制到 dist 目录下，每一个 branding name 复制一份（ln 89-91）</li>\n<li>编译 css （ln 93）</li>\n<li>编译 JavaScript （buildJavaScript 函数）</li>\n<li>将 dist 目录下，指定 branding name 相关的文件都复制到 deploy 中（复制到 deploy 的方法见 deploy.js）</li>\n</ol></section><section><h3>rollup-plugin-hash.js</h3><p>这个是 rollup-plugin-hash npm 包的修改版本。首先，计算 hash 的时候会去掉顶部的注释，因为这里包含了编译时间，并不希望每次仅仅因为编译时间不同导致最终的 hash 值不同。</p><p>其次，针对编译出来的不同文件，如 bundle.xxxx.js，需要生成对应的 newlivechat 文件。对于贴代码的网站来说，首先下载的就是这个 newlivechat 文件，newlivechat 里面需要指定具体去下载哪个 bundle.xxx.js。这个指定的过程是在编译阶段写死的。另外，这里再生成的时候还会根据 branding name 做替换。比如说，comm100 使用的 api 名字是 window.Comm100API，而 livechat100 （已经弃用）用到的可能是 window.LiveChat100API。编译的时候会做字符串的替换（见 replaceCode 函数）</p><p>注意到除了 newlivechat.js 之外，还有 newlivechat.cordova.js / newlivechat.free.js / newlivechat.free.cordova.js 等，针对不同用途的入口文件。</p><p>其中，.free.js 这个是给免费用户使用的。免费用户在请求的时候，服务器会直接给这个 .free.js 的内容。这样的设计是为了给差异化发布使用的。最后的版本，可以先只发布免费的部分，免费用户使用没有问题之后，再全量上线。</p><p>另外，会在文件底部加上 map 文件的引用地址。因为我们的流程中一直没有对 map 文件的管理和发布，所以实际上这里的 map 一直都没有用起来，无法帮助线上问题的定位。这里需要改进。</p><p>另外，newlivechat.dev.js 是一个特殊的入口文件，这个入口是给调试使用的。调试的时候，不会生成 bundle.xxx.js 而是生成 bundle.js 文件。这样避免了每次修改之后都生成不同文件的麻烦。newlivechat.dev.js 中也直接指定 bundle.js。</p></section><section><h3>rollup.botpreview.config.js</h3><p>这个不太了解。</p></section><section><h3>rollup.config.js</h3><p>这个是访客端 js 文件编译的配置文件。这里大部分的配置和 build.iframe.js 中 rollup 的配置是一样的。不同的几个地方：</p><ol>\n<li>用 string({ include: ‘*<em>/</em>.css’ }) 来处理 css 文件，将 css 的内容读出来，转化成一个字符串，在 js 中直接引用。（在 js 里面，需要将这个字符串通过 style 的 tag 插入到 dom 中）</li>\n<li>redux-logger 这个库常年没有人维护了，依然用的是比较早的 nodejs module export 方法，所以需要用 commonjs 来转化一下（rollup 默认只支持 es6 的 import/export）</li>\n<li>license 的部分给编译好的 js 加上了一个顶部的注释，主要包括了当前编译的时间（时间去掉了时区的影响，不暴露编译大部分是在东八区白天进行的事实），版本号，最后一个 git 提交。</li>\n</ol><p>由于 rollup 的编译结果还是比较容易识别的，在不压缩的情况下，去掉了 sourcemap，反而调试方便一些。</p></section><section><h3>rollup.pciform.config.js</h3><p>这个不太了解。</p></section><section><h3>rollup.preview.config.js</h3><p>这个文件是为了编译出 preview.js 的，这个文件是给 control panel 中预览聊天窗口使用的。</p><p>大部分的配置和前面的 rollup.config.js 是一致的，最后加上了一个 onwrite 的回调，生成 preview 和 preview.next 两个文件。preview.next 是给免费用户使用的。在某些情况下，可以只发布这个 preview.next.js 这样只有免费用户会看到代码的改动。（应该配合 newlivechat.free.js 一起发布，这样后台和网站上看到的都会是匹配的，且只有免费用户受到影响，收费客户没有变化）</p></section><section><h3>rollup.view.config.js</h3><p>这个文件可以编译出 view.js。只提供一个对外的接口，接口接受一个 state 参数，函数会在 id 是 process.env.BRANDING.ids.uiContainer 的 div 下面，生成 dom tree。（uiContainer 的定义见 branding.yaml）</p><p>有了这个函数，就可以批量生成各种情况下的 redux state，然后用 puppeteer 来生成每一个 state 对应的 dom tree，截图生成效果。</p><p>如果有上一轮截图的结果的话，还可以通过像素级别的比较，查看当前和上一轮的代码改动造成的 UI 变化。</p></section><section><h3>t<em>onemaxon</em>platform.sql</h3><p>这个不太了解。</p></section><section><h3>uglify-cordova.js</h3><p>这个不太了解。</p></section><section><h3>font/font-generator.js</h3><p>在 css 目录下生成 Icon.css 文件（css 会用 cleancss 来进行压缩，ln 52），以及对应的字体文件。css 用的模板是 css-template.hbs（ln 43），html-template.hbs 暂时没有使用。</p><p>所有的字体 svg 都放在 css/icons 中，编译的时候会读取这里面的 svg 文件，最终生成字体文件。（ln 32-33）</p><p>最终生成的字体文件在 css/fonts 中。</p><p>在执行生成命令之前，updateIconHash 函数会删除上一次的编译结果。</p><p>注意，这里的字体文件路径会用 {FONT<em>URL</em>PREFIX} 来代替。在 js 中，会根据运行环境，将这个值替换成真实的 URL 地址。具体见 src/utils/business.js 中的 fontCSS 函数。</p></section></section><section><h2>cobrowse</h2><p>这个目录下放了一份 3.3.0 版本的 Glance 代码。主要是测试阶段，经常连不上 glance 的服务器，无法下载静态资源。之前有用过这样的方法来直接使用一个更容易拿到的静态资源。（见 src/store/cobrowisng.js ln 289）</p><p>在页面的 URL 中 search 里带上 cobrwoseDebug 就可以开启这个功能了。</p><p>不建议使用。</p><p>现在应该可以用合适的网络访问来避免这个问题了。建议删除这部分代码。</p></section><section><h2>css</h2><p>css 下面的 images 目录会直接复制到 deploy 中（见 branding.yaml 的配置和 deploy.js 的说明），所以可以直接在代码里面引用这些 images 文件。</p><p>css 下面的 fonts 目录和 images 目录类似。但是这里的文件一般是 css 文件直接引用的。</p><p>css 目录下面的入口文件有三个，style.less / chat-button.less / side-window.less。分别生成三个 style.min.css / chat-button.min.css / side-window.min.css，这三个文件分别在 src 中被直接引用。分别是给 chat window，adaptive chat button 和 side window 使用的。</p><p>variables.less 是一个比较特殊的文件，这里面定义了一些颜色的数据。这些颜色在定义的时候都是写成了非常特殊的值，从 #000001 开始。然后在实际运行的代码中，会通过字符串替换的方式替换成主题色和其他相对应的颜色。见 src/utils/busioness.js 中的 replaceThemeColors 函数。（这里的实现并不是非常的好，可以考虑改用 css variable。在实际运行的时候，如果 css variable 是支持的，可以直接使用，不支持的话再用字符串替换处理）</p></section><section><h2>dev</h2><p>这个目录下面存放了开发服务器相关的所有代码。</p><p>除了 server.js 外，大部分的代码是为了 mock 真实服务器而存在的。但是这部分代码已经不再使用了，一般调试的过程中还是建议直接链接一个真实的测试服务器。</p><p>需要说明的几个文件。</p><section><h3>gallery.html</h3><p>TODO</p></section><section><h3>portAssigner</h3><p>这个文件的意义，是为了给每一个开发者指定一个不同的端口号起始位置。这样所有人在同一台机器上进行开发的时候，不同的人起服务后使用的端口号是不一样的。（实际使用的端口号，是起始端口号加上 401，见 dev/server.js ln 16）</p></section><section><h3>screenshots.js</h3><p>因为我们的代码是通过 redux state 来驱动的，所以如果可以生成各种类型的 state，那么就可以渲染出各种情况下的 UI。这里的代码，就是为了做这个事情。通过 src/gallery.js 下面的代码生成各种 state，然后调用 dist/view.js （由 src/view.js 生成）来渲染出 UI，通过 puppeteer 得到最终的图片，通过和上一轮代码的渲染结果的像素对比，找出差异化的地方。</p><p>具体的执行逻辑是这样的：</p><ol>\n<li>require(‘../src/gallery.js’) 引入了 gallery 的代码。gallery 里面 window.run 暴露了接口。这个接口会在 screenshots.js 中通过 global.window.run 获取到（ln 11）</li>\n<li>执行比较需要用到 view.html / view.previous.html 两个入口页面，分别渲染出当前代码和之前一个版本代码的结果。两个页面的代码是一样的，只不过 view.html 引用的是 view.js，而 view.previous.html 引用的是 view.previous.js。</li>\n</ol><p>（在使用的时候，需要先用 rollup.view.js 编译出 dist/view 文件，然后拷贝到 dev 下面。运行 screenshots 出结果。然后，需要把 dev/view.js 修改成 dev/view.previous.js，因为这个版本就变成“上一个版本”了，下一次运行的时候，拷贝过来新的 view.js，可以直接和这个 view.previous.js 来进行执行结果的比较）</p><ol start=\"3\">\n<li>getBrowser 用 puppeteer 运行 chrome，位置定义在 30 行，不同的开发机不一定一样，这里可能需要修改</li>\n<li>pool 生成了一个线程池，最多 10 个 tab 一起运行。</li>\n<li>每隔一秒，从 iterator 中取下一个 state，然后放到 main 里面去渲染结果（渲染的时间超过了 1s，所以这里线程池 10 个最终会都用起来的）</li>\n<li>核心的代码在 main 函数里面，做了这么几个事情：</li>\n<li>访问 view.html，设置窗口的大小和 state.page.width / state.page.height 一致</li>\n<li>用 page.evaluate(s => window.view(s), state) 来渲染 state。这里需要通过 .evaluate 来将 screenshot 运行环境下的 state 提供给 puppeteer 的 chrome 环境。window.view 是 view.js 暴露出来的接口（见 rollup.view.js 说明）</li>\n<li>等待五秒后，截屏</li>\n<li>同样的步骤，访问 view.previous.html，生成一个针对同样 state 的截屏</li>\n<li>用 pixelmatch 来比较前后两个图片的差异，threshold 1%，如果超过阈值，就将结果生成到 diff 文件下</li>\n<li>当前版本的截图放到 screenshots/index.png 中</li>\n<li>screenshots.description.txt 中插入一条，记录当前这个 index 的图片，是根据什么样的 state 渲染出来的。（描述在 state.description 中，这个值的设置见 src/gallery.js）</li>\n</ol><p>由于 gallery.js 中 generator 生成了很多的 state，整个运行的过程大概需要两三个小时。建议放到中午吃饭或者晚上下班后进行，回头再来查看结果。</p><p>如果需要缩短运行时间，就需要对 gallery.js 中的代码做剪枝。但是这里不太容易，因为有可能把可能的情况给剪掉了。</p><p>另外，这里即使是相同的 view.js，也可能生成出不同的 screenshots，主要是一些简单的动画（如 loading）会造成视觉差异。可以在后续中考虑使用 process.env.IS_GALLERY 这个判断来去掉动画或其他可能影响到判断的地方，确保两次运行的结果是一样的。</p><p>另外，将 view.js 重命名成 view.previous.js 的过程也可以写道 screenshots.js 里面。建议在覆盖原来的 view.previous.js 前，备份一份原来的 view.previous.js，免得版本找不到了。这里的覆盖动作可以在全部 screenshots 比较完成后进行。</p></section><section><h3>server.js</h3><p>这个文件是用于开启调试服务器用的，主要做几个事情：</p><ol>\n<li>开始一个 mock 服务器（不再使用）</li>\n<li>为静态文件提供服务（参考 ln 378 开始的部分）</li>\n<li>对于 newlivechat.js 来说，除了提供入口文件之外，还需要和真实的服务器一样写入入口的服务器地址。针对不同的测试环境，可能需要修改这里的服务器地址。可以修改 getServerUrl 这个函数的返回值，数组至少一个值，第一个是主服务器地址，第二个是副服务器地址。</li>\n</ol></section><section><h3>test.html</h3><p>这个页面是测试时候用到的入口文件。这个页面做了几件事情：</p><ol>\n<li>如果 shouldMesseUp 设置为 true，会把页面上的一些 prototype 函数给改坏掉（因为我们的代码是运行在客户网站上的，我们的代码不能假设客户网站上的 prototype 是正确的，非常有可能客户自己修改了 prototype 的代码，比如重写了 Array.prototype.map 函数，直接调用可能导致错误。由于我们的代码已经运行在 iframe 中了，所以理论上来说这里应该已经不会有问题了，shouldMesseUp 暂时默认写的是 false）</li>\n<li>window.core 的设置也和上一条理由差不多。主要是为了保证 core-js 不会改客户网站上的代码，比如覆盖 window.core</li>\n<li>代码会从 url 中读取 siteid 和 plainid 的值。如果没有 plainid 就认为是 dynamic campaign。然后就插入相对应的代码。</li>\n</ol></section></section><section><h2>test</h2><p>test 目录下面放了一些实验性质的代码，主要是用 Puppeteer + Jest 来尝试做和 screenshot.js 类似的功能。jest 原生提供了比较好的 snapshot 比较功能，加上 toMatchImageSnapshot 这个功能扩展的帮助，可以比 screenshot.js 中自己手写代码方便一些。toMatchImageSnapshot 这个功能是在 jest.setup.js 中定义扩展的。而 jest.setup.js 是在 jest.e2e.config.json 中定义使用的，jest.e2e.config.json 是在 package.json 的 e2e 命令中，以 <code class=\"language-text\">jest --config jest.e2e.config.json</code> 的方式指定的。</p><p>未来可以考虑直接用 gallery.js 生成各种 state，然后用 jest 这里的框架直接声称图片的比较。优点是 jest 做了大量的工作，包括事先的编译工作都可以免去了。然而缺点也是比较明显的：为了保证 snapshot 的比较，需要将大量的截图上传到库里面，这个量非常大；另外，jest 比较出来，第一次可能有不同，需要人工比较后，确认没有问题了，再跑一次把内容覆盖掉，生成新的 snapshots，两次跑全量会非常耗费时间。</p><p>参考的代码大概如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> run <span class=\"token keyword\">from</span> <span class=\"token string\">'src/gallery'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> view <span class=\"token keyword\">from</span> <span class=\"token string\">'src/view'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'e2e demo'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// setups first ...</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> state <span class=\"token keyword\">of</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">it</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>description<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// take screenshot after running view(state) inside puppeteer</span>\n      <span class=\"token keyword\">const</span> img <span class=\"token operator\">=</span> <span class=\"token function\">takeScreenshot</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      img<span class=\"token punctuation\">.</span><span class=\"token function\">toMatchImageSnapshot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div></section><section><h2>.babelrc</h2><p>这个 babelrc 的配置可能在编译中没有实际使用，因为 rollup 中的配置，基本都设置了 <code class=\"language-text\">babelrc: false</code></p></section><section><h2>.editoconfig</h2><p>这里的配置主要是给 VSCode 增加一些默认的设置，同步不同工程师的开发环境。比如说默认的文件都以 lf 作为结尾（而不是 windows 默认的 crlf），文末需要插入一个额外的空行，保存的时候删除行尾多余的空格，tab 转化为 space，一个 tab 等于 2 个 space，默认的字符集使用 utf8。</p><p>这些配置在 ESlint 中都有相对应的 rule 检查。</p><p>另外，不太清楚的是现在版本的 VSCode 是否还会遵循这里的配置。</p></section><section><h2>.esdoc.json</h2><p>这里是给 esdoc 的配置。esdoc 用于根据 JavaScript 代码中的 jsdoc 注释来生成文档文件。基本上这个已经废弃了，没有实际使用的场景。</p><p>另外，在 JavaScript 项目中，使用 jsdoc 来注释函数等依然是有意义的。VSCode 会根据这些 jsdoc 的注释来做类型推断。因为访客段还没有开始使用 TypeScript，这里的 jsdoc 还是可以有所帮助的。至少，VSCode 在知道类型之后，可以给出更好的 intellisense。所以虽然 esdoc 废弃不用了，但是 jsdoc 注释的部分建议保留，并可以考虑多写写。</p></section><section><h2>.eslintignore</h2><p>有些文件不需要 eslint 检查，写在这里</p></section><section><h2>.eslintrc</h2><p>ESLint 相关的配置都写在这个文件里面。一些简单的说明：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">extends</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'airbnb'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 我们的 ESLint 配置是基于 Airbnb 的 ESLint 配置，官网见：https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb</span>\n                     <span class=\"token comment\">// 这里我们用的版本还是比较老的，14.1.0，文档写的时候最新版本已经是 17.1.0 了。可以考虑对这个进行升级，但是升级会带来大量的代码重新不符合规范，需要花时间修正。</span>\n                     <span class=\"token comment\">// 升级是可以带来实际好处的，比如会有新的 accessibility 相关的规则帮助产品更好的满足 WCAG 的要求。可以找一个时间进行升级。</span>\n                     <span class=\"token comment\">// 另外，一个 tip，如果升级中发现某些规则的加入导致了大量的 errors，可以考虑在这个配置文件里面先把这个对应的规则改成 warning，然后慢慢改完之后，再去掉 warning 的配置覆盖</span>\n  settings<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> react<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> pragma<span class=\"token punctuation\">:</span> <span class=\"token string\">'h'</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 这个就是为 preact 设置的，preact 不使用 react.createElement 而是使用 preact.h 函数来创建 virtual dom</span>\n  <span class=\"token string\">'import/resolver'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'eslint-import-resolver-custom-alias'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      alias<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'@'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'./src'</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 这里两个是和 rollup 中相同的配置。对于大型的项目来说，引用尽量应该使用绝对路径而不是相对路径（特别是引用的模块不是在子目录的时候——这往往意味着引用之间的关系至少是平级的）</span>\n        <span class=\"token string\">'css'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'./css'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 这里用 eslint-import-resolver-custom-alias 插件来同步 eslint 中的配置，这样 eslint 在看到 import 'src/xxx' 的时候，就知道去什么位置寻找文件</span>\n                        <span class=\"token comment\">// 从而可以更好的判断引用位置的文件是否存在了（如果不存在，eslint 会给出报错）</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  env<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> es6<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> jest<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> browser<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 我们的项目是基于浏览器的，同时会用到 jest 的单元测试，所以这里的环境这么配置（这样 ESLint 知道那些变量是默认的全局变量，而不是忘了引用）</span>\n  rules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'no-restricted-globals'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'top'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 这个规则和下面的 no-restricted-properties 是相互配套使用的，禁止了 window.top 的使用</span>\n    <span class=\"token string\">'no-restricted-properties'</span><span class=\"token punctuation\">:</span>  <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>     <span class=\"token comment\">// 如果需要使用宿主环境的 window （比如获取 window.Comm100API 值），可以使用 utils/env.js 中的 global</span>\n    <span class=\"token string\">'valid-jsdoc'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 合格的 jsdoc 往往要写很多内容，由于已经不需要用 esdoc 来生成文档了，写全 jsdoc 的意义并不大</span>\n                      <span class=\"token comment\">// 这里改成 warning，可以按需只写部分 jsdoc（比如只写参数的类型，不写返回值的类型，vice versa）</span>\n    <span class=\"token string\">'jsx-a11y/no-static-element-interactions'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token comment\">// 理论上来说，不应该在 div 等元素上面加 onClick 之类的事件，应该用 a 或者 button 之类的</span>\n                                                 <span class=\"token comment\">// 这些元素浏览器都会有默认的键盘行为支持，可以更好的服务于残障人士。（比如 focus 后按会车可以出发 onClick 之类的）</span>\n                                                 <span class=\"token comment\">// 但是由于历史的原因，这里改成 warning，暂不要求原有的部分都统一改对。</span>\n                                                 <span class=\"token comment\">// 另外，Firefox 对 button 元素里有 children 的支持好像是比较奇怪的，在使用的时候需要注意。</span>\n                                                 <span class=\"token comment\">// 如果对于需要 onClick 的情况都用 a 标签，也会不太符合语意，ESLint 也会有其他的报错。</span>\n                                                 <span class=\"token comment\">// 这里可能需要细致的测试和一定的工程上的取舍。建议暂时不去掉 warning。</span>\n                                                 <span class=\"token comment\">// 但是对于新加入的元素，应该保证都使用符合 WCAG 标准的设置方式。主要是要有键盘操作的支持。</span>\n    <span class=\"token string\">'react/no-unused-prop-types'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>， <span class=\"token comment\">// 这里主要是怕麻烦，有很多报错，所以 error 改 warning 了，可以考虑改回去</span>\n    <span class=\"token string\">'react-jsx-filename-extension'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 后缀使用问题都不大，这个规则就关闭了</span>\n    <span class=\"token string\">'react/prop-types'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 因为 preact 本身没有 propTypes 的支持，代码里有些地方有 propTypes 的检查，也是手写上去的，所以加上这个规则意义不大</span>\n                           <span class=\"token comment\">// 所谓手写的检查，可以参考 src/compoennts/HoC/validation.js 这个高阶函数，在 development 模式下，会对 props 进行手动检查。</span>\n                           <span class=\"token comment\">// 因为不是每个组建都套了 validation，所以这个规则开启的意义不大。</span>\n    <span class=\"token string\">'react/require-default-props'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 理由同上</span>\n    <span class=\"token string\">'import/no-extraneous-dependencies'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 在 src 下面，devDependencies 里的库不应该被引用，但是对于 test 或者 storybook 的部分，是可以允许的</span>\n    <span class=\"token string\">'id-blacklist'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 这里规定了一些不应该使用的单词，会以 warning 的形式给出。主要是一些已经被 marketing 团队弃用的说法，比如 codeplan 已经改成 campaign 了</span>\n                        <span class=\"token comment\">// visitor monitor 也改叫 agent console 了，operator 改成 agent 了。这些说法的改变，理应同时造成代码层面的改变，不然陈旧的代码不利于后期</span>\n                        <span class=\"token comment\">// 其他后加入工程师的理解（因为他们显然不会了解其中的发展历史）。但是受限于改动可能会涉及到很多的地方（特别是 codeplan 这个字段，在一些对象中作为属性</span>\n                        <span class=\"token comment\">// 存在，改不全容易出现问题），所以暂时只是 warning，而不是 error 级别的报错。</span>\n                        <span class=\"token comment\">// 另外，注意到这里没法区分大小写等不同的等价写法，所以对于一个词可能出现的多种写法，最好都加上，比如 codeplan，codeplans，codePlan，codePlans 等</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div></section><section><h2>.gitignore</h2><p>一些不需要 git 签入的内容。</p><p>原则上来说，编译生成的内容不应该签入到库里面（因为每个人都可以编译生成），临时文件/cache 等不应该签入到库里面。</p><p>注：gitignore 中写到的内容不代表一定不会在库里出现。如果一个文件已经在库里了，后来又加到了 gitignore 中，那么这个文件不会被删除的。如果需要删除，执行 <code class=\"language-text\">git rm xxx</code> 才行，执行完，签入后，这个文件不会再被加入到库里面。</p></section><section><h2>.eslintrc_old.js / .gitmodules / bitbucket-pipelines.yml / ci.bat / pack.bat / zip.bat / zip240.bat</h2><p>可以删掉的文件，其中，bitbucket-pipelines.yml 是代码还在 bitbucket 的时候，配置的 pipleline，现在已经没用了。</p><p>pack.bat 的部分，应该可以由 build/deploy.js 的代码取代了。</p><p>zip.bat 和 zip240.bat 应该是一些可以上传压缩包到指定 目录/ftp 的脚本。在内网开发环境中应该用不到了。另外，如果今后需要用到自动化的脚本，建议直接写 JavaScript 的脚本，然后用 node 运行，灵活性更大一些。也没有操作系统的限制，参考 deploy.js 的代码。</p></section><section><h2>.stylelint</h2><p>stylelint 的部分，扩展了 stylelint-config-standard</p></section><section><h2>branding.yml</h2><p>之前做 livechat100 项目的时候新加入的文件。这里配置了程序用到的，和品牌相关的一些内容，比如 logo 的样式，文字，链接地址等。虽然 livechat100 已经不再维护了，但是考虑到还有在使用的 partner 项目，建议保留 branding.yml 的配置数据，方便 partenr 项目根据这个文件生成新 partenr 的编译文件。</p><p>branding.yml 的顶层 property name 就是 branding 的名字。对应的 value 就是配置信息。具体的使用方式可以参考上面 build 部分的说明。</p><p>文件中有比较详细的属性用途说明，这里不赘述了。</p></section><section><h2>jest.e2e.config.json / jest.setup.js</h2><p>这两个文件是给 npm run e2e 使用的，说明见 test 目录下文件的说明部分。</p></section><section><h2>jest.global.js</h2><p>这里定义了全局变量，主要包含几个部分：</p><ul>\n<li>window.Comm100API 的定义，这个是贴代码的网站上都应该有的</li>\n<li>process.env.xxx 的定义，这个是编译环境里肯定会给的，所以测试环境里也要都提供</li>\n</ul></section><section><h2>jsconfig.json</h2><p>这个文件和一般 TypeScript 项目中的 tsconfig.json 文件比较类似，可以帮助 VSCode 了解当前 JavaScript 项目的一些配置信息。重点主要还是指定了 <code class=\"language-text\">baseUrl</code> 和 <code class=\"language-text\">paths</code> 这两个部分，这样 VSCode 也可以知道 rollup 里面配置的 alias 的路径了。（注意，<code class=\"language-text\">import &#39;css/xxx&#39;</code> 的部分不需要写到 paths 里面，因为 css 就是顶层下面的一个目录，所以 <code class=\"language-text\">baseUrl: &#39;.&#39;</code> 就已经保证了 <code class=\"language-text\">css/xxx</code> 可以被直接找到了）</p><p><code class=\"language-text\">baseUrl</code> 的意思是，当遇到非相对路径的时候，VSCode 会以 <code class=\"language-text\">&#39;.&#39;</code> 为其实位置，计算真实路径。</p></section><section><h2>ngrok.exe</h2><p>应该是一个客户让局域网的文件在广域网里被访问到的工具，具体可以文 Roy。考虑到公司的开发环境限制很多，这样直接暴露局域网的工具，不是非常建议直接使用。如果需要调试其他设备，建议用 Wi-Fi 链接到同一个局域网下面，然后就可以直接访问了。另外，https 也可以通过生成自签名证书的方式解决。</p></section><section><h2>package.json</h2><p>一些说明：</p><ul>\n<li>\n<p>version：这个值是会写到编译结果最上面的注释里面去的，每次发布之前应该都要修改</p>\n</li>\n<li>\n<p>scripts</p>\n<ul>\n<li>js：编译 js，<code class=\"language-text\">npm run js -- --watch</code> 可以开启 watch 模式</li>\n<li>js:cordova：编译 cordova 版本的 js</li>\n<li>js:prod：编译 prodction 版本的 js</li>\n<li>uglify:cordova：不太清楚</li>\n<li>css：编译 css（参考 build/less.config.js 中的说明）</li>\n<li>css:watch：带 watch 模式的编译 css</li>\n<li>build：编译 css 和 js</li>\n<li>build:iframe：编译 socialIframe（这个应该是给 Facebook / Google+ 登陆用的，其中 Google+ 因为已经停止运营，所以代码被删除了）Facebook 的登陆需要页面是在注册过的地址下面的（也就是 comm100.com 下面，所以需要一个额外的页面做交互沟通，同时满足 Facebook App 注册时候的信息规则）</li>\n<li>build:chatwindow：编译弹出式窗口的 html</li>\n<li>build:preview：编译 control panel 的 preview js</li>\n<li>build:botpreview：编译 bot 里面用到的 preview js</li>\n<li>build:view：编译 screenshot 命令中需要用到的 view.js，需要将生成的 dist/view.js 放到 dev/view.js 才能运行 screenshot 命令（见 screenshot.js 的说明）</li>\n<li>test：运行 jest 单元测试（用了 —runInBand，因为发现不安顺序一个个执行的话，有些单元测试可能会报错。这里最好是能在后续的版本中修复问题，去掉 —runInBand）</li>\n<li>test:watch：watch mode 打开，只跑修改了的文件的单元测试</li>\n<li>e2e：一个实验性质的 e2e 测试，见 test 目录下的说明</li>\n<li>story：运行 storybook 的服务器，目前基本不太能使用，重新开启需要修复一些问题，见 .storybook 下面的说明</li>\n<li>lint-staged：签入 git 文件时候需要做的 lint 检查，具体配置写在 package.json 里面</li>\n<li>lint：同时检查 js 和 css</li>\n<li>lint:js：检查 js 文件，用 eslint</li>\n<li>lint:css：检查 css 文件，用 stylelint</li>\n<li>build:font：编译字体</li>\n<li>server：开启一个开发调试用的服务器</li>\n<li>release：打包给测试的时候需要用的命令，所有用到的编译步骤这里都会走一遍</li>\n<li>release:livechat100：默认 release 只会编译 comm100 的内容，这个命令是编译 livechat100 的，可以删掉了</li>\n<li>zip：可以删掉了</li>\n<li>zip240：可以删掉了</li>\n<li>build:240：可以删掉了</li>\n<li>start：一个命令同时开启调试服务器和开启 js 的 watch 模式编译，理论上应该还要加上 css watch mode 编译，同时需要在 server 相关代码修改的时候重启 server，这部分改好了应该对开发体验有帮助（修改文件就重启 node 的部分，可以参考使用 <a href=\"https://github.com/remy/nodemon\">nodemon</a>）</li>\n<li>screenshots：用 puppeteer 做的 e2e 测试，见 screenshots.js 的说明</li>\n<li>customcss-full：这部分 mark 比较清楚</li>\n<li>customcss-classic：这部分 mark 比较清楚</li>\n<li>customcss-circle：这部分 mark 比较清楚</li>\n<li>build:pciform：这部分 mark 比较清楚</li>\n<li>build:pciformPreview：这部分 mark 比较清楚</li>\n</ul>\n</li>\n<li>\n<p>lint-staged 这里的配置主要规定了当有文件签入的时候，应该进行哪些检查（.js/.jsx 文件用 eslint 检查，.css 文件用 stylelint 检查），如果报错，理论上无法 git 签入成功（注意，这里的 lint-staged 只是一个君子协定，前端肯定是可以绕过去的，后续应该考虑在服务器端通过 CI 的配置，进行检查，如果不能通过 lint 应该要由服务器来拒绝签入）</p>\n</li>\n<li>\n<p>pre-commit: [‘lint-staged’] 这里定义了签入文件的时候应该执行 <code class=\"language-text\">npm run lint-staged</code></p>\n</li>\n<li>\n<p>pre-push 在 push 代码之前，应该执行 lint 和 test 代码。同样，这个也是君子协定，前台可以通过 <code class=\"language-text\">--no-verify</code> 绕过去。后续还是应该通过 CI 的配置来由服务器拒绝不合格的代码签入。</p>\n</li>\n<li>\n<p>jest：这里配置了 jest 用到的设置信息</p>\n<ul>\n<li>collectCoverageFrom 定义了哪些文件应该算到 code coverage 中</li>\n<li>coverageThreshold 定义了最顶的代码覆盖率要求，即使测试都通过了，如果覆盖率不够，依然会测试不通过。这了需要尽可能提高覆盖率的值，目前 50～60 的阈值太低了，可以把目标定到 80 左右，太高也没必要</li>\n<li>transform 定义了文件应该经过什么样的预处理，比如 js 文件需要 babel 处理，css 文件用 rawTrasnformer 直接转化成一个空字符串被引用</li>\n<li>testUrl 定义了在 jest 的环境里面，url 地址是多少，这个在某些地方代码可能会需要访问 location.href 之类的字段</li>\n<li>setupTestFrameworkScriptFile 这里定义了最先需要执行 jest.global.js 来加入必要的 global 字段设置</li>\n<li>moduleNameMapper 这里是 jest 部分的 alias 设置，保持了和 rollup 相同的配置，这样 jest 也可以找到引用文件的真实位置</li>\n</ul>\n</li>\n<li>\n<p>browserlist 应该可以删掉了，没有在使用，和 browserlist.js 的配置也不太相同</p>\n</li>\n<li>\n<p>server-version 这个字段只在 deploy 的时候会用到，把 js 放到 chatserver 目录下面的时候，需要一个 server 的版本号作为目录的名字，这个名字在这里定义</p>\n</li>\n</ul></section><section><h2>src</h2><section><h3>entry.xxx.js</h3><p>这里有四个 entry 入口，基本上都是差不多的，主要是针对环境稍有不同。.dev.js 是给调试用的。cordova 是给 cordova 特别用的。</p><p>注：entry 的内容应该尽可能的小。根据 <a href=\"https://stackoverflow.com/questions/2613734/maximum-packet-size-for-a-tcp-connection\">https://stackoverflow.com/questions/2613734/maximum-packet-size-for-a-tcp-connection</a> 这里的说法，虽然一个 TCP 包理论上的最大容量有 64kb，但是实际上一般只能由 1.4~1.5kb 左右。如果 entry 的大小可以小于这个值的话，不需要发送第二个 HTTP 的 TCP 包，对传输效率有一定的好处。</p><p>在 entry 的代码里面，主要是生成了一个 iframe，然后再 iframe 里面加载真正的 bundle.js。这里的 bundle.js 的内容是编译的时候写死的。见 rollup-plugin-hash.js</p></section><section><h3>index.js</h3><p>这个是主入口文件。</p></section><section><h3>polyfill.js</h3><p>这里手动维护了一些需要用到的 polyfill 文件。async 的部分被注释掉了，因为生成的代码比较大。访客端的结果力求小，不建议用。</p></section><section><h3>gallery.js</h3><p>这里的 window.run 暴露出的解耦是给 screenshots.js 用的。它会创建一个 iterator，然后循环创建各种类型的 state。</p><p>简单来说，会先通过创建一些简单的 generator 函数，来创建各种情况下的 state。以 textButton 这个函数举例，会生成两个情况，分别是文字是 Live Chat 的文字按钮和文字是 Another Text 的文字按钮。各种 genrator 函数通过 combineAll 或者 oneOf 进行合并，可以生成各种情况下的 state。combineAll 就是对各个 genrator 函数的结果做笛卡尔乘积；oneOf 则是将各个函数的结果现行拼接在一起，如果 state 的情况是相斥的，用 oneOf，否则用 combineAll。</p><p>比如说，button 和 chat window 不会同时出现，这里的 state 之间就可以用 oneOf；比如 chat window header 的情况会根据主题色，是否有 banner 图片等条件的不同而不同，所以这些情况应该用 combineAll 来合并。</p></section><section><h3>preview.js</h3><p>这个页面是给 control panel 用的入口函数。开放了一些接口，可以用于再指定位置生成 dom tree。思路是这样的，对于不同的情况，开放接口，control panel 的页面上提供具体的数据，然后再接口里面，生成相对应的 state，然后根据 state 生成对应的 ui，并插入到指定的位置。</p><p>在 control panel 上的 js 调用接口后，大致需要做这个几件事情：通过调用方给定的数据，生成一个 state（会包含一些默认的 state 数据，见 initial 函数），创建一个简单的 reducer 函数（只做一件事情，就是接收到 update action 的时候，把 action.payload 里面的数据拿出来，合并到 state 中），用 state 和 reducer 来创建 store，然后渲染 container（不同的接口渲染不同的 container）。</p><p>对于开放的接口来说，做两件事情：首先是初始化，需要提供默认的数据以及渲染到的位置；然后，接口会返回一个 update 函数，这个函数接受一个参数，提供 params 后刷新 dom。</p><p>以 button 这个接口为例，最开始接受的参数是 container（也就是需要渲染到的位置，dom），btn （button 相关的配置），ifOnline （布尔值，确认按钮显示 online 还是 offline 的效果）。initial 函数调用的时候，会将上面给的几个参数合并成一个初始化的 state，在 initial 函数的内部，则会将这些信息和其他一些默认的字段进行合并，生成 state；同时，initial 函数返回一个 update 函数，control panel 中可以存储这个返回的函数，在界面上用户做了其他改动之后，调用这个函数，提供新的 state 数据来刷新 dom。</p></section><section><h3>type.d.ts</h3><p>这里定义了 redux state 的结构，但是并没有长时间维护，实际结构可能和 type.d.ts 的内容有区别。</p><p>如果需要获取当前的 state 结构，最好的方法是找一个 preview 的页面，然后用 window.store 拿到 redux store 的实例，然后用 getState 来获取 state 数据。（因为访客端是运行在 iframe 环境下面的，所以在 console 中运行 window.store 的时候，需要注意将运行的环境选择成 <code class=\"language-text\">comm100-iframe(about:blank)</code>）</p></section><section><h3>view.js</h3><p>这个文件是给 <code class=\"language-text\">npm run screenshots</code> 使用的，具体的说明见 screenshot.js 的地方。总体上来说，这里的接口接受 state 作为参数，然后补上一些可能需要的数据（比如，在 puppeteer 将 state 数据从 node.js 的运行环境移动到 chrome 的过程中，date 的部分被 stringify 过了，所以需要在 view.js 里面再把 date 的部分重新转化为 date），创建一个 store（这里的 store 把 dispatch 功能删掉了，这样 UI 的部分不会因为 mount 之类的事件发生变化），最后通过原本的接口把 UI 渲染出来。</p></section><section><h3>safeStorage.js</h3><p>对于没有提供 localStorage/sessionStorage 的情况，safeStorage 函数会提供一个 mock。这里需要注意的一点是：private 模式下，会启用这个 mock。但是 memoryStorage 的实现会在 window 上增加一个对象。注意这里不能把对象名字取成 localStorage 或者 sessionStorage，浏览器不允许覆盖 window.localStorage 的值。改成用 local-storage 或者其他名字就可以了。有些版本依然存在这个问题。</p></section><section><h3>component.js</h3><p>这里主要放了一些 preact 项目中可能会用到的操作 virtual dom 渲染的函数。主要可能用到的两个：</p><p>renderToContainer：访客端项目有很多需求是需要将一段 dom tree 渲染到另外一个地方（比如把 button 的部分渲染到用户指定的 div 下面）。但是，从程序上，并不希望因为这样的渲染需求，而把完整的 virtual dom tree 给拆分成几段。renderToContainer 的作用是，在指定了 context 和 container 之后，调用返回结果里的 render 函数，可以把结果渲染到之前指定的 container 下面。实际的使用主要是 Iframe.jsx 和 migration.js 这两个地方在用，后续会介绍。</p><p>shouldComponentUpdateGen：这个是一个辅助函数，会根据指定的 propKeys 和 stateKeys 来判断是否需要重新 render；在 development 模式下面，还会提供一些额外的帮助信息：如果 props 或者 state 发生了变化，但是 shouldComponentUpdate 应该返回 false，那么会在 console 中输出相关的信息。这样比较容易帮助定位问题（主要是改了 state 但是 UI 没有变化的情况）。</p></section><section><h3>subscription/api.js</h3><p>这个文件主要是为 window.Comm100API 提供 api 接口的。主要是 do, get, set, on 四个接口。同时，老版本的接口也会依然提供，但是会加上 deprecateWarning，调用的时候 console 会给出 warning。另外，老版本有一个 setPrechatFields 的接口，这个新版本没加上，可以考虑后续加上。</p><p>api 的接口需要放到 subscription 里面，主要是因为：api 会获取/赋值 redux state，同时没有特定的 UI 相关，所以 subscription 的概念比较合适一些。</p></section><section><h3>subscription/ui.js</h3><p>UI 的渲染，本质上也是一个 subscription，因为是需要根据 redux store 来变化 UI，所以这个部分也是放到了 subscription 的下面。</p></section><section><h3>store/batch.js</h3><p>这个 enhancer 的需求是这样的：每一次 store.dispatch 之后，都会同步触发一次 store.subscribe 中注册过的回掉函数。如果一次用户的操作/网络返回只触发一次 store.dispatch，那么是不会有问题的。但是，一次用户的操作可能会触发不止一个 store.dispatch（这里的出发点是希望将 action 尽量的原子化，一个 action 对应一种类型的 state 变化，所以一个用户操作可能设计多个 action）。当一个操作触发多次 action 操作的时候，就会导致一个操作触发了多次的 UI 渲染。对于 react 来说，渲染是异步的，所以实际上触发的渲染可能还是只有一次。但是要注意到的是，container 依然被触发了很多次，导致计算 props 的过程有不必要的冗余。batch 的作用是，确保多次发送 action，但是只触发一次 subscription 的回调。</p><p>这里最重要的 export 是 enhancer 函数，这个 enhancer 代理了原来 store 中的 subscribe 函数。新的代理函数会记录下所有的 subscription，但是当真正的 store 触发 subscription 之后，并不一定会马上触发 subscription 函数，enhancer 会确认没有新的 action pending 的时候，才会真正触发 subscription。</p><p>计算是否有 pending action 的代码在 middleare 里面。当接收到一个 batch action 之后，会先计算处 payload 里面的 action 的总数，然后每 dispatch 一个 action，就 pendingAction 减一。（见 actions.reduce 的函数）这样，当 pendingAction 是零的时候，就知道所有的都已经发送过了，subscription 可以被真正调用了。</p><p>由于不同的 middleware 都有可能发送这种 batch action，所以需要在每一个这样可能的 middleware 的后面，都跟上一个 batch middleware。这样，batch middleware 就可以将 batch action 拆分成一个个的子 action，对于后续的 middleware 和 reducer 来说，batch action 就是不存在的，接收到的依然是每一个个原子 action。</p></section><section><h3>store/messages.js</h3><p>这个 middleware 拦截了 message 相关的 action，然后判断是否需要触发一些额外的动作，比如 api 的调用。另外，agentTyping 的消息接收到之后，10s 后删除 agentTyping，也是在这个 middleware 里处理。</p></section><section><h3>store/cobrowsing.js</h3><p>这个 middleware 会根据 store.state 中 cobrowsing 相关的数据，来处理 cobrowsing 相关的动作，包括加载 script，开启 cobrowsing 等等。</p><p>getCSS 根据主题色生成 glance UI 相关的 CSS 代码 （主要是一些 modal 层的按钮颜色，样式等），在第一次开始 cobrowsing 的时候会往页面上插入这段 css。</p><p>加载 script 的时候，会做这么几件事情：如果当前 URL 带有 cobrowseDebug 参数，那么会加载本地的一个 glance script（不建议使用，建议去掉这部分代码），否则加载 glance 的代码。加载的时候，需要一些配置，其中 groupId 是服务器给的。glance 的服务是需要写入 cookie 来记内容的。getPossibleDomain 的部分做这样的操作，程序会尝试在当前域名下写入 cookie，如果失败的话，就会去父域名上写入 cookie，只要有可以写入 cookie 的域名，就给 data-cookiedomain，这样 glance 就会尝试在这个设置的 domain 下面写 cookie；如果全部都写入失败了，就会用 data-cookietype=‘ls’ 禁用 cookie，改用 localstorage 来写数据。这里这么设计，主要是有些客户可能会用 amazon 的云服务，直接把 cookie 写到根域名下面是不行的，只能尝试在当前的子域名下面写 cookie。如果都不能写 cookie（可能是有了某些设置），也要用 localstorage 保证大概率的使用没有问题。</p><p>在 initCobrowsing 的时候，会针对 differentDomain 的部分做一些 hack。默认情况下，glance 需要用户做一些额外的配置才可以跨域（用户需要在一个简单页面上加入 glance 的代码，glance 在跳转到另外一个域名的页面之前，会先 window.open 打开这个简单页面，然后调用方指示这个简单页面在当前的域名下先写好 cookie，然后再实行真正的跳转工作。到了新的域名之后，cookie 已经在了，就可以确保跨域了。）但是这样的方案，需要用户做设置，并不是非常好。这里的代码（ln210-224）主要就是为了规避这部分的设置，直接由我们的代码来完成 cookie 的写入。首先是判断当前 cobrowsing 是不是跨域的方法：通过聊天消息判断出来当前应该是在 cobrowsing 的过程中，但是无法读取到 glance 的 cookie，这个时候就需要手动插入 cookie 的。cookie 的结构如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  ssnid<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>groupId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>sessionCode<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>callId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// groupId 和 sessionCode 服务器都是知道的</span>\n  <span class=\"token comment\">// callId 是 glance 生成的，服务器不清楚，但是本地在开始 cobrowsing 的时候，可以从 cookie 里拿到</span>\n  <span class=\"token comment\">// 这里拿到 callId 后，会存放在消息里（startCobrowse 的消息），发送给服务器（见 onSessionStart 函数）</span>\n  <span class=\"token comment\">// 这样，在页面刷新重新拿消息之后，程序就可以从 startCobrowse 中读取到当前的 callId</span>\n  <span class=\"token comment\">// 从而拼接出完整的 ssnid</span>\n  <span class=\"token constant\">R</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不清楚含义</span>\n  yb<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不清楚含义</span>\n  Od<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不清楚含义</span>\n  Fa<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'domain'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 当前的 domain 字符串</span>\n  boxstate<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不清楚含义</span>\n  expanded<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不清楚含义</span>\n<span class=\"token punctuation\">}</span></code></pre></div></section><section><h3>components/HoC/heartbeat.js</h3><p>这个 High order Component 的作用，就是根据传入的参数（参考 Heartbeat.propTypes 的定义），来调用 hCallback 这个回调函数。</p><p>在 component 的层面做 heartbeat，而不是放到 subscription 等地方，主要也是考虑到了 heartbeat 的不同情况和 UI 的展示基本是对应的。（比如 chat button 情况和 chatting 情况的 heartbeat 是不同的）。根据 Component 是否 mount 来开启和关闭 heartbeat，这样逻辑只需要写一次就可以了（既负责展示 UI，也负责调整 heartbeat）。</p><p>但是，把 heartbeat 的代码真的写道 component 里面是不妥的。因为 UI 不应该去关心 heartbat 的部分，这个和 UI 本身无关。所以这里使用了 HoC 来包裹原先的 component，赋予 UI 可以 heartbeat 的功能。</p></section><section><h3>components/HoC/language.jsx</h3><p>给 UI 加上 language 相关的 context，这样子元素可以直接拿到语言了。这里，默认需要 props 一定带有 languageTag 的属性，程序会通过这个 tag 去 constants/languages.json 里面找对应的语言包，赋值给 context。</p><p>子元素可以通过 <code class=\"language-text\">utils/helper</code> 的 getLanguages 辅助函数，从 context 中拿到 languages</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> languages <span class=\"token operator\">=</span> <span class=\"token function\">getLanguages</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>languages<span class=\"token punctuation\">.</span>xxx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// constatns/languages.json 中，languageTag （比如 en）下面，xxx 字段的语言翻译</span></code></pre></div></section><section><h3>components/HoC/loading.js</h3><p>类似于 React.Suspense，在 loadFn 没有加载完成前，显示 loading 的组件，加载完成后显示原始组件。如果加载失败就什么都不显示。</p></section><section><h3>components/HoC/migration.js</h3><p>这个 HoC 的作用，是将指定的元素渲染到指定的 container 下面，而不是当前的 dom tree 下。这个主要是给 button 服务的。因为聊天按钮需要渲染到客户指定的元素下面。</p><p>注意，对于这种没有实际含义的组件，render 函数需要 <code class=\"language-text\">return &lt;div /&gt;</code> 而不是 <code class=\"language-text\">render null</code> 或者 <code class=\"language-text\">render true</code> 之类的。这个是为了解决在 IE 里的一个问题。preact 会默认把 component 的渲染信息放到当前渲染好的 dom 组件上。对于 null 或者 true 之类的来说，preact 会默认渲染一个 emptytextnode。IE 做了一个错误的优化，回把 emtpytextnode 上赋值的元素 gc 掉，这会导致一定时间之后，preact 重新渲染元素的时候，无法知道上一次渲染的信息，导致渲染错误。</p></section><section><h3>components/HoC/validation.js</h3><p>preact 本身不检查 proptypes。这个 HoC 可以在 render 的时候检查 props 的信息，给出 warning，然后正常的渲染出组件。</p></section><section><h3>components/HoC/render.js</h3><p>这里公开的 API 分成两个部分，一个是 RenderProvider 组件，用于在 context 中注册一个 getRender 的函数。getRender 函数是从 subscription/api 里面拿出来的（见 Root.jsx 的代码）。注册好了之后，子元素就可以直接从 context 里面拿到 getRender 函数，直接调用使用了。</p><p>第二个部分是 render 或者 renderWindow 的 API。这两个 High order Component 的功能是类似的。以 render 函数为例，name 和 key 两个参数，name 是对应的 api 的名字，key 是 props 对应的 key，传递给 api 调用。调用完成后，如果返回了 element（ln 16-20），就用 api 指定的元素，否则使用自己的元素（这里的行为可以参考 Comm100API.render api 的行为定义）。renderWindow 的 api 也是类似的，区别在于，renderWindow 需要根据 window tab 的不同，调用不同的 api。</p></section><section><h3>components/Window/WindowBase.jsx</h3><p>访客端有三种窗口类型，Bubble / Circle / Classic。这里的设计是这样的：大部分 window 相关的逻辑都是一致的，都写在了 WindowBase 里面。但是三种类型的窗口可能会有一些行为上的不同，比如窗口大小之类的。所以这个目录下面有三个文件，分别是 BubbleWindow.jsx / CircleWindow.jsx / ClassicWindow.jsx，三个文件都定义了各自的组件。和一般的组件不太一样，这三个组件是 extends Window 而不是一般的 extends Component。然后只覆盖基类上需要修改的几个函数，比如 setWinSize / getWinStyle / getSideWinStyle 等。以此实现不同窗口的行为不同。</p><p>但是从实践下来的效果看，感觉上这里的设计并不是非常的好。可能还不如直接使用 High Order Component 来的方便。另外，这里的几个文件都太大了，可以考虑做拆分。</p></section><section><h3>components/functionality</h3><p>这里下面的几个文件，都是一些功能性的 components，本身不渲染什么内容，但是会设定一些额外的 side effects，比如 flash title 是闪烁 tab 的 title 字段，googleanalytics 是触发 ga 事件，head 是用来在 head 标签中插入一些标签，style 则是在 head 中插入样式。</p><p>注意：render 一定要返回 <code class=\"language-text\">&lt;div /&gt;</code>，解释见 HoC/migration.js 的部分。</p></section></section></section>","frontmatter":{"title":"交接","date":"2019-04-09","modified":"2019-04-09","description":""}}},"pageContext":{"slug":"/handover/","previous":{"fields":{"slug":"/handover1/","type":"draft"},"frontmatter":{"title":"交接","category":"","tags":""}},"next":{"fields":{"slug":"/alias-for-web-project/","type":"blog"},"frontmatter":{"title":"Web 应用的 Alias 配置","category":"Tools","tags":"Tools, JavaScript"}}}}