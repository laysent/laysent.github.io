{"data":{"site":{"siteMetadata":{"blogTitle":"LaySent's Blog","author":"LaySent"}},"markdownRemark":{"id":"cdd635d0-96ad-52a3-889e-6e9b1bb44499","html":"<p><a href=\"https://w3c.github.io/webappsec-subresource-integrity/\">spec</a></p>\n<p>开发者需要用户从 CDN 上下载脚本，而且必须相信这些下载的内容是符合预期的。攻击者可以利用这一点，诱使用户下载到不正确的脚本，从而达到攻击的手段。诱使的方法有：DNS 污染或者直接修改 CDN 上的文件内容。</p>\n<p>注意到，TLS 也好，HSTS 也好，pinned public keys 也好，都只能保证用户是和指定的服务器进行沟通的，但是不能保证用户使用了指定的文件内容。攻击者如果可以不动 server，只修改内容的话，这些防范手段都失效了。所以，需要提供一种手段，让开发者可以不仅仅指定服务器，也可以指定服务器上文件的内容。</p>\n<section><h2>use case</h2><ol>\n<li>对于 CDN 上的脚本，确保内容是正确的</li>\n<li>对于引用的第三方脚本，确保内容是之前认真审阅过的版本</li>\n<li>A user agent wishes to ensure that JavaScript code running in high-privilege HTML contexts (for example, a browser’s New Tab page) aren’t manipulated before display. Integrity metadata mitigates the risk that altered JavaScript will run in these pages’ high-privilege contexts.\n(???)</li>\n</ol></section>\n<section><h2>概念</h2><p>digest\norigin / cross-origin / same-origin</p><p>Augmented Backus-Naur Form\nWhite Space</p></section>\n<section><h2>integrity 的组成部分</h2><p>cryptographic hash function，如 sha256，sha384，sha512 等\ndigest 具体的 base64 值\noptions 这个还没有具体的定义，但是以后可能会有，比如 MIME</p></section>\n<section><h2>validation</h2><p>有多个 integrity 的情况，浏览器会选择最强的算法的结果；对于不支持的算法，浏览器会自动忽略。这样，开发者就可以一次性写多个 integrity，新的浏览器会有更好的算法，老的浏览器也可以选择支持的老算法，而不会有问题。浏览器内部会实现一个 <code class=\"language-text\">getPrioritizedHashFunction</code> 函数，用于判断两个 Hash 算法，哪一个有更高的优先级。如，<code class=\"language-text\">getPrioritizedHashFunction(&#39;sha256&#39;, &#39;sha512&#39;)</code> 会返回 <code class=\"language-text\">&#39;sha512&#39;</code>；<code class=\"language-text\">getPrioritizedHashFunction(&#39;sha256&#39;, &#39;sha256&#39;)</code> 会返回 <code class=\"language-text\">&#39;&#39;</code>。</p></section>\n<section><h2>Request verification algorithms</h2><p>可以在 Content-Security-Policy 中指明 require-sri-for 来指定强制 integrity 检查（opt-in 的功能）。可选项是 script 或 style 或两者都写。如果请求是指定的某种类型，且 integrity 是空，那么请求会被 block。</p></section>\n<section><h2>计算方法</h2><p>算法用在没有经过 encoding 的内容基础上，除非浏览器想要在 encoding 的基础上来使用内容。</p><p>为了避免黑客通过暴力穷举的方式来验证 integrity，从而猜出原始内容，integrity 的验证只能在同域或者 CORS 的情况下完成。具体来说，response type 需要是 basic，cors 或者 default 的时候，才可以检查是否正确。basic 是 same-origin 的情况，cors 是对方服务器允许跨域，default 是 service worker 生成的合法 response。</p><p>As noted in RFC6454, section 4, some user agents use globally unique identifiers for each file URI. This means that resources accessed over a file scheme URL are unlikely to be eligible for integrity checks.\n有些浏览器对每个 file 有独一无二的 id，这使得 integrity 检测对本地文件就不可用了。（因为不同域）</p><p>subresource integrity 不需要强制在 HTTPs 的环境下使用。非 secure 环境也可以用。但是这样的使用是无法保证安全的（见 5.1）</p><p>算法允许一个 Hash 函数提供多个结果，只要满足了其中一个，就算检查通过。</p><div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://example.com/example-framework.js<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\">integrity</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>sha384-Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7\n                   sha384-+/M6kredJcxdsqkczBUjMLvqyHb1K/JThDXWsBVxMEeZHEaMKEOEct339VItX1zB<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\">crossorigin</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>anonymous<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div><p>这样的目的是：一个 URL 可能会对应到不同的结果，或者有些浏览器插件（比如 HTTPS Everywhere）可能会修改请求（比如将 HTTP 请求修改为 HTTPs）从而导致最终的结果是不同的。</p></section>\n<section><h2>报错</h2><p>如果 integrity 的检查失败了，浏览器会报错。开发者应该捕获这个报错并提供 fallback 资源。</p><p>对于失败的资源，浏览器不会使用其内容。</p></section>\n<section><h2>3.9 Elements</h2><p>（没看懂）</p></section>\n<section><h2>4 Proxies</h2><p>需要避免中间的服务器对返回数据做修改。有几个方案：1. 修改内容的时候把 integrity 也改了；2. 不修改内容，Cache-Control 增加 no-transform</p></section>\n<section><h2>5.1 HTTP 依然是不安全的</h2><p>攻击者可以修改 HTTP 的内容，包括修改 integrity 的值，或者干脆直接把 integrity 删掉。</p></section>\n<section><h2>5.2. Hash collision 攻击</h2><p>有些 Hash 算法本身有缺陷，比如 MD5，或者 SHA-1。目前情况下，建议 SHA-384 作为基准。（建议浏览器多关注算法方面的问题，如果一个算法爆出来不佳，应该考虑不支持）</p></section>\n<section><h2>5.3 CORS</h2><p>只有明确了 CORS 的才可以进行 integrity 检查，主要是为了避免几个问题：</p><ol>\n<li>攻击者可以加载某个资源 + Hash，通过是否失败得知资源是否是预想的内容。举例来说，用户登陆之后，某些内容可能会发生变化，这就是的 Hash 检查可以得知用户是否登陆</li>\n<li>如果一个 API 是返回带有登陆信息的 JSON 数据，那么攻击者可以通过生成各种常见登陆用户名 + 密码组合的 JSON，算出对应的 integrity，然后判断是否猜对</li>\n</ol></section>","frontmatter":{"title":"Subresource Integrity Spec 笔记","date":"2019-03-31","modified":"2019-03-31","description":""}}},"pageContext":{"slug":"/notes-of-subresource-integrity-spec/","previous":{"fields":{"slug":"/subresource-integrity-and-error-handling/","type":"blog"},"frontmatter":{"title":"Subresource Integrity 出错时的处理方案","category":"Web","tags":"Web, JavaScript"}},"next":{"fields":{"slug":"/ledger/","type":"draft"},"frontmatter":{"title":"ledger","category":"Tools","tags":"Tools"}}}}