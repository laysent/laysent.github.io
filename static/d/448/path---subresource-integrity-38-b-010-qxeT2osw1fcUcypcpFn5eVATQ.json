{"data":{"site":{"siteMetadata":{"title":"LaySent's Blog","author":"LaySent"}},"markdownRemark":{"id":"0be79a56-fac6-5d16-a09c-193fb6331962","html":"<blockquote>\n<p><a href=\"https://laysent.github.io/subresource-integrity-demo/index.html\">在线演示</a></p>\n</blockquote>\n<p>当前，大量的前端引用资源文件是放在 CDN 上进行加速的。因为文件不存放在自己的服务器上，这些文件的安全性实际上是交由 CDN 来保证的。为了防止这些资源文件被篡改造成的安全问题，integrity 提供了浏览器层面的资源文件校对功能，以确保真正使用到的资源文件都是没有被篡改的（如插入挖矿代码）。</p>\n<h1>使用</h1>\n<p>（<a href=\"https://laysent.github.io/subresource-integrity-demo/integrity.html\">在线演示</a>）</p>\n<p>在资源文件中，可以加上 integrity 属性，用于指明文件的校验码。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span>\n  <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://example.com/example.js<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\">integrity</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>sha384-correct+hash+here<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\">crossorigin</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>anonymous<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>integrity 属性，主流浏览器都是支持的，包括最新版的 Chrome，Firefox，Edge，Safari，Opera 等。但是 Internet Explore 不支持。具体的支持列表见 <a href=\"https://caniuse.com/#search=sri\">https://caniuse.com/#search=sri</a>。</p>\n<h2>integrity</h2>\n<p>在上面的例子中，<code class=\"language-text\">sha384-</code> 指明了 hash 值的具体类型（目前可以使用的值包括 <code class=\"language-text\">sha256</code>, <code class=\"language-text\">sha384</code>, <code class=\"language-text\">sha512</code>）。之后的字符串是具体的 hash 值。integrity 属性可以一次性指定多个 hash 值，用空格分隔就可以了。例如 <code class=\"language-text\">integrity=&quot;sha256-xxx sha384-xxx sha512-xxx&quot;</code>。需要注意的是，当多个 hash 值一同给出时，浏览器会以 <code class=\"language-text\">sha512</code> > <code class=\"language-text\">sha384</code> > <code class=\"language-text\">sha256</code> 的顺序选择提供结果中强度最大的来使用。如果这个结果是正确的，那么验证通过；否则验证失败，不论其他的结果是否是正确的。</p>\n<p>举例来说，如果 <code class=\"language-text\">integrity=&quot;sha256-correct sha512-wrong&quot;</code> 是提供的 integrity，那么 <code class=\"language-text\">sha512</code> 会被浏览器采纳使用。而由于 <code class=\"language-text\">sha512</code> 的结果是错误的，所以资源加载失败，此时 <code class=\"language-text\">sha256</code> 的结果并没有被考虑。</p>\n<h2>CORS</h2>\n<p>在使用 integrity 的时候，往往需要配合 <code class=\"language-text\">crossorigin=&quot;anonymous&quot;</code> 一同使用。这是因为，integrity 的主要目的，是为了确保第三方资源加载时的正确性。而浏览器如果需要检查一个跨域文件的 hash 值是否是正确的，需要资源在加载的时候，以 <code class=\"language-text\">crossorigin=&quot;anonymous&quot;</code> 方式声明，同时需要对方服务器的确认（即，在 HTTP 头中提供正确的 <code class=\"language-text\">allow-control-allow-origin</code>）。如果加载的资源文件不存在跨域问题，那么这里的 <code class=\"language-text\">crossorigin=&quot;anonymous&quot;</code> 是非必须的。但是在非跨域情况下，integrity 的设置也没有太大意义。</p>\n<h1>行为</h1>\n<p>当遇到资源文件的加载带有 integrity 属性时，浏览器会首先下载这个资源文件，然后对资源文件的内容进行比对。如果比对成功，那么这个脚本/样式文件会被执行；如果比对失败，那么文件不会被执行，<code class=\"language-text\">network error</code> 会被抛出。这里，在 console 中可以看到具体的报错信息。但是出于隐私的考虑，在 JavaScript 代码中，报错不会提供详细的信息，只会告知 <code class=\"language-text\">network error</code>。</p>\n<h2>Preload</h2>\n<p>（<a href=\"https://laysent.github.io/subresource-integrity-demo/integrity-and-preload.html\">在线演示</a>）</p>\n<p>根据 <a href=\"https://github.com/w3c/preload/issues/127\">https://github.com/w3c/preload/issues/127</a> 和 <a href=\"https://github.com/w3c/webappsec-subresource-integrity/issues/26\">https://github.com/w3c/webappsec-subresource-integrity/issues/26</a> 的描述，Chrome 浏览器在处理 preload 和 integrity 配合使用的资源上存在问题。简单来说，当 preload 加载的时候，资源就已经被编译解析了，而原始的文本资源被丢弃。因此，当浏览器之后运行到具体的资源加载语句的时候，由于没有了原始文本，就无法计算具体的 hash 值，也就无法确认 integrity 是否正确，只能不得已重新请求一次。而最终使用的是第二次请求的资源，preload 的结果会被丢弃，Chrome 也会在 console 中给出 warning。</p>\n<blockquote>\n<p>A preload for ‘xxx’ is found, but is not used due to an integrity mismatch.</p>\n</blockquote>\n<p>试验了一下，Safari 似乎没有相同的问题。Firefox 本身还不支持 preload。如果在 <code class=\"language-text\">about:config</code> 中将 Firefox 的 <code class=\"language-text\">network.preload</code> 功能打开，那么 Firefox 的表现行为看上去和 Chrome 是相同的，但由于没有足够的信息，尚不清楚实际上是否和 Chrome 一样，最开始 preload 的资源被遗弃了。</p>\n<p>另外，在跨域的请求中，如果实际请求资源的时候有 <code class=\"language-text\">crossorigin=&quot;anonymous&quot;</code>，那么 preload 需要提供同样的 <code class=\"language-text\">crossorigin=&quot;anonymous&quot;</code>，否则资源文件依旧会被请求两次，无论是否有 integrity。</p>\n<h2>Prefetch</h2>\n<p>（<a href=\"https://laysent.github.io/subresource-integrity-demo/integrity-and-prefetch.html\">在线演示</a>）</p>\n<p>prefetch 的优先级比 preload 低很多，行为也有所不同。对于 prefetch 来说，下载完成的文件会被存储在 cache 中，当实际文件请求到的时候，会生成一次请求，并从 cache 中把文件取出来使用。是否有 integrity 对此行为不会造成影响。</p>\n<h1>生成</h1>\n<p>使用下面的 node.js 代码可以生成具体文件对应的 hash 值：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> crypto <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'crypto'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ncrypto<span class=\"token punctuation\">.</span><span class=\"token function\">createHash</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sha256'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">digest</span><span class=\"token punctuation\">(</span><span class=\"token string\">'base64'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>同样，也可以使用 <a href=\"https://laysent.github.io/sri-hash-generator/\">Web App</a> 来在线生成文件的 integrity 值。</p>\n<h1>Content-Security-Policy</h1>\n<p>（<a href=\"https://laysent.github.io/subresource-integrity-demo/content-security-policy.html\">在线演示</a>）</p>\n<p>在 HTTP 头中增加 <code class=\"language-text\">Content-Security-Policy</code> 的设置，可以要求浏览器强制对加载的脚本/样式文件进行校验。例如</p>\n<ul>\n<li><code class=\"language-text\">Content-Security-Policy: require-sri-for script;</code> 可以对脚本文件进行校验</li>\n<li><code class=\"language-text\">Content-Security-Policy: require-sri-for style;</code> 可以对样式文件进行校验</li>\n<li><code class=\"language-text\">Content-Security-Policy: require-sri-for script style;</code> 可以同时对脚本和样式进行校验</li>\n</ul>\n<p>注意，无论是否设置了上述 HTTP 头，浏览器都会对拥有 integrity 属性的资源进行校验。这里当 HTTP 头设置了之后，会强制让没有设置 integrity 属性的资源文件加载失败。可以作为一个调试工具来检查是否有遗漏的内容。</p>\n<p>如果不在 HTTP 头中带这一条，也可以在 HTML 中增加如下的代码，能达到同样的效果：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">http-equiv</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Content-Security-Policy<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>require-sri-for script style<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>这个 HTTP 头的校验功能，在当前版本（Chrome 70）中还未被默认打开。这意味着，即使请求带有以上任何一种 HTTP 头，Chrome 也不会对 HTML 中引用的资源文件做强制校验。当 Chrome 监测到以上的任意一种 HTTP 头之后，会在 console 中输出：</p>\n<blockquote>\n<p>The Content-Security-Policy directive ‘require-sri-for’ is implemented behind a flag which is currently disabled.</p>\n</blockquote>\n<p>如果需要让 Chrome 运行检测，需要访问 <a href=\"chrome://flags/#enable-experimental-web-platform-features\">chrome://flags/#enable-experimental-web-platform-features</a>，并打开实验功能。</p>\n<p>Firefox 和 Safari 暂时不支持该功能。</p>\n<h1>注意</h1>\n<p>在使用 <code class=\"language-text\">webpack</code> 的 <code class=\"language-text\">hot-reload</code> 功能，或是使用 proxy 服务器对资源文件进行替换的时候，如果有 integrity 会导致使用失败。<code class=\"language-text\">hot-reload</code> 需要保证每次资源的变动都重新计算出正确的 integrity 值，才能保证使用；proxy 服务器需要首先修改 html 中的内容（比如直接去掉 integrity，然后才能保证之后修改资源文件依然可以使用）。</p>\n<p><code class=\"language-text\">webpack</code> 可以使用 <code class=\"language-text\">webpack-subresource-integrity</code> 插件来完成自动编译 integrity 的功能：<a href=\"https://github.com/waysact/webpack-subresource-integrity\">https://github.com/waysact/webpack-subresource-integrity</a></p>\n<h1>参考</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity\">https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity</a></p>\n<p><a href=\"https://github.com/waysact/webpack-subresource-integrity\">https://github.com/waysact/webpack-subresource-integrity</a></p>\n<p><a href=\"https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf\">https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf</a></p>","frontmatter":{"title":"Subresource Integrity","date":"2019-01-06","modified":"2019-01-06","description":"Subresource Integrity (SRI) 的基本用法、目的、行为，以及配合 Preload，Prefetch 等一同使用时的注意事项"}}},"pageContext":{"slug":"/subresource-integrity/","previous":null,"next":{"fields":{"slug":"/migration-from-c-library-to-node-addon/"},"frontmatter":{"title":"使用 N-API 移植现有 C 语言库"}}}}