{"data":{"site":{"siteMetadata":{"blogTitle":"LaySent's Blog","author":"LaySent"}},"markdownRemark":{"id":"62c30657-866f-5917-9c78-6c385a324b24","html":"<section><h1>访客端</h1><section><h2>storybook</h2><p>storybook 是一个库，用于展示 React 组件的效果的。在访客端项目中，这个功能已经基本不用了。如果需要重新使用，需要先修复 <code class=\"language-text\">.storybook</code> 目录下 webpack.config.js 文件中的配置问题：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  resolve<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    alias<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// ...</span>\n      <span class=\"token string\">'@'</span><span class=\"token punctuation\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'..'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'src'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'css'</span><span class=\"token punctuation\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'..'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'css'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>加上上面的两行之后，<code class=\"language-text\">npm run story</code> 命令就可以正确执行了。执行成功后，会在 6006 端口开启一个新的服务（6006 是写死在 npm script 的定义里的，见 package.json 文件）。访问这个地址，可以看到各种控件的实时展示。修改 src 文件夹下任意一个 xx.story.js 的文件，保存之后，就可以看到最终的结果。</p><p>这里，由于访客端用的是 preact 而不是 react，与 storybook 的默认配置不同，所以在 webpack.config.js 中，用 resolve alias 的方式配置了使用 preact-compat 来做兼容。兼容的效果不是百分百的。只是大体上可以达到使用的效果。</p><p>但是目前这个部分已经无人维护了。很多控件的展示存在错误。如果需要重新使用起来，需要把这里一些报错的地方先修复掉。</p><p>.storybook/config.js 文件主要是针对 storybook 的一些配置。重点做了两件事情：</p><ol>\n<li>将各个 css 文件从 css 文件夹下面读取出来，将颜色信息和字体信息替换掉，然后以 style 的形式插入到页面中</li>\n<li>监听 src/components 下面，以 story.jsx 结尾的文件改动，一旦发生变化，就重新渲染。</li>\n</ol><p><code class=\"language-text\">npm run story</code> 定义在 package.json 中，实际运行的是 <code class=\"language-text\">start-storybook -p 6006 -c .storybook -s ./css</code> 命令，其中 start-storybook 是 storybook 提供的 bin，p 指定了端口号，c 指定了配置文件的位置，也就是 .storybook 目录，s 指定了静态目录的为止。</p></section><section><h2>vs</h2><p>.vs 目录应该是被无意中签入的，实际并未用到</p></section><section><h2>vscode</h2><p>.vscode 目录下存放的是和 VSCode 相关的一些配置文件。因为平常的前端开发，一般都使用 VSCode 作为主要的编辑器，这里的配置一旦提交到代码库中，将能一定程度上的同步各个开发人员之间的编辑器配置。</p><section><h3>launch.json</h3><p>这个文件配置是为了 VSCode Debug 的时候使用的。</p><p>这里 configurations 里面，第一个写的内容应该是没有实际作用的。configurations 第二个配置主要是为了 Jest 在做单元测试的时候，调试用的。下面以调试 helper.test.js 为例，简单介绍一下用 VSCode 调试的步骤：</p><ol>\n<li>打开 helper.test.js 这个文件，位置是 src/utils/helper.test.js</li>\n<li>在 VSCode 中，选中左侧菜单的第四个 icon，可以进入 Debug 的面板</li>\n<li>在 Debug 面板的右侧顶部下拉菜单中，选择 Jest Debug，及使用 launch.json 中第二个 configurations 的配置</li>\n<li>在 helper.test.js 文件的任意位置，点击行标，设置断点（比如，点击 499 在第 499 行设置一个断点）</li>\n<li>在右侧顶部选中 > 按钮，开始 Debug 模式</li>\n<li>VSCode 会开始用 jest 运行 helper.test.js 文件，并在 499 行挺住</li>\n<li>可以通过 VSCode 了解当前的程序运行状态，或者单步调试来执行后续代码</li>\n</ol><p>launch.json 配置里的一些说明：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  type<span class=\"token punctuation\">:</span> <span class=\"token string\">'node'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 运行环境是 Node</span>\n  request<span class=\"token punctuation\">:</span> <span class=\"token string\">'launch'</span><span class=\"token punctuation\">,</span>\n  protocol<span class=\"token punctuation\">:</span> <span class=\"token string\">'inspector'</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Jest Debug'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 显示在 Debug 下拉菜单中的名字</span>\n  program<span class=\"token punctuation\">:</span> <span class=\"token string\">'${workspaceRoot}/node_modules/jest/bin/jest'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 执行文件的位置</span>\n  stopOnEntry<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不需要在运行一开始就直接停住，默认是直接在文件设置断点的地方停住就可以了</span>\n                      <span class=\"token comment\">// 对于单元测试来说，只需要在有问题的测试用例中停顿就可以了</span>\n                      <span class=\"token comment\">// 如果是其他的情况，在调试一开始的时候就直接停住，有助于设置进一步的断点位置</span>\n  args<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'--runInBand'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token string\">'--env=jsdom'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 访客端需要 jsdom 作为运行环境</span>\n    <span class=\"token string\">'${fileBasename}'</span> <span class=\"token comment\">// 这里默认只执行打开着的那一个文件，如果打开的是 helper.test.js 就只执行这一个文件</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  runtimeArgs<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'--inspect-brk'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  cwd<span class=\"token punctuation\">:</span> <span class=\"token string\">'${workspaceRoot}'</span><span class=\"token punctuation\">,</span>\n  sourceMap<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  console<span class=\"token punctuation\">:</span> <span class=\"token string\">'integratedTerminal'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div></section><section><h3>settings.json</h3><p>settings.json 文件主要记录的是 VSCode 在本项目中的一些配置，一定程度上在开发人员间做到配置共享。以下是一些说明：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  <span class=\"token string\">'javascript.validate.enable'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token comment\">// 默认 VSCode 会做一些 JavaScript 的检查。但是对于一些较新的语法，可能会导致 VSCode 检查出现错误。项目中直接使用 ESLint 做检查，这里默认就把 VSCode 的检查关闭了。考虑到这几年 JavaScript 的支持发展很快，大部分在访客端中用到的功能应该都已经默认支持了，可以考虑重新打开来看看效果。</span>\n  <span class=\"token string\">'files.exclude'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 这里主要设置了一些不需要在 VSCode 中展示出来的文件，包括 node_modules 等。如果</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token string\">'files.eol'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'\\n'</span> <span class=\"token comment\">// 使用 \\n 而不是 \\r\\n 这个 Windows 默认的转行符号，保持不同系统间的统一。ESLint 也有专门针对这一点的 rule 配置</span>\n  <span class=\"token string\">'search.exclude'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 这里配置了一些不需要在搜索结果中出现的文件，基本上除了 src 和 css 中的文件，其他的基本都不需要可以搜索到（css 中编译出来的 .min.css 文件耶不需要可以搜索到。这里的配置可以按需调整</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'file.associations'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 有一些文件，VSCode 无法通过后缀来判断文件的语法类型，这里可以做配置</span>\n    <span class=\"token comment\">// 注意：这里的配置是写错了的，应该是 files.associations，而不是 file.associations</span>\n    <span class=\"token comment\">// 这里的配置实际上是没有生效的，需要修改一下</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'editor.rulers'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">80</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 这里会在 80 个字符和 100 个字符处各增加一个竖线。一般不建议超过一行 80 个字符，ESLint 中配置了代码长度不能超过 100 个字符，否则会报错。这里的 rulers 主要是视觉上提供一个边界提醒</span>\n  <span class=\"token string\">'editor.tabSize'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token comment\">// 默认将 tab 等同于两个空格，保持视觉上的良好体验，同时也不至于占太多控件</span>\n  <span class=\"token string\">'editor.insertSpaces'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// VSCode 会在按下 tab 的时候，插入 space</span>\n  <span class=\"token string\">'files.trimTrailingWhitespace'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// VSCode 会在保存的时候，将每一行文末多余的空格给删除</span>\n  <span class=\"token string\">'stylelint.config'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'extends'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'stylelint-config-standard'</span> <span class=\"token comment\">// 针对 stylelint 的配置，指明用到的配置文件是 stylelint-config-standard</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token string\">'cssrem.rootFontSize'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">15</span> <span class=\"token comment\">// 这两个都是 cssrem 插件的配置，访客端默认的 1rem = 15px，定义的位置在 chat-button.less，side-window.les 和 style.less 中都有涉及</span>\n  <span class=\"token string\">'cssrem.autoRemovePrefixZero'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span></code></pre></div></section></section><section><h2>api</h2><p>这个目录下面，存放的是访客端对外开放的 JavaScript API 的文档，以及展示文档需要用到的 <a href=\"https://github.com/docsifyjs/docsify\">docsify</a> 代码。</p><p>文档的实体内容写在 readme.md 文件中。</p><p>docsify 相关的主要是 docsify.min.js，<a href=\"unpkg.com/docsify/lib/plugins/search.min.js\">search.min.js</a> 以及 style.css 三个部分。其中 docsify.min.js 是 docsify 的核心功能，search.min.js 提供了 docsify 的搜索插件，style.css 是对应的样式文件。我们使用的是 4.3.13 版本。</p><p>index.html 里面，除了设置了一些 meta 值之外，主要有一个 <code class=\"language-text\">window.$docsify</code> 的配置。说明如下：</p><div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  search<span class=\"token punctuation\">:</span> <span class=\"token string\">'auto'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 默认搜索</span>\n  loadNavbar<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 设置为 true，navbar 会从 _navbar.md 中读取内容。这里其实可以设置为 false，_navbar.md 实际中并未使用</span>\n  homepage<span class=\"token punctuation\">:</span> <span class=\"token string\">'../readme.md'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 主页就是 API 文档的正文（和 index.html 同级的 readme.md 文件）</span>\n  loadSidebar<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 没有 sidebar</span>\n  maxLevel<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 目录最多三层深</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Comm100 Live Chat'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 侧边栏顶部的文字</span>\n  themeColor<span class=\"token punctuation\">:</span> <span class=\"token string\">'#329fd9'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 主题色</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>更多的配置，见<a href=\"https://docsify.js.org/#/configuration\">官方文档</a>。</p><p>文档最终发布的位置，见：<a href=\"https://ent.comm100.com/LiveChatFunc/doc/CustomJS/index.html\">https://ent.comm100.com/LiveChatFunc/doc/CustomJS/index.html</a></p><p>编译的时候完成后，api 整个目录会被放到 ent 和 hosted 下，livechatfunc/doc/customJS 目录下面。这里的位置配置见 branding.yaml 中，deploy 下 api 的部分</p><section><h3>remark lint</h3><p>文档新增加了 markdown 的 lint 功能。使用的命令是 <code class=\"language-text\">npm run lint:md</code>，使用的工具是 <code class=\"language-text\">remark-cli</code> 以及 <code class=\"language-text\">@laysent/remark-preset-lint</code>。在 <code class=\"language-text\">.remarkrc</code> 中，对原来 <code class=\"language-text\">@laysent/remark-preset-lint</code> 的定义做了个性化修订，主要是最长的代码长度修正为 100 个字符。如果 api/readme.md 文件做了修改，签入代码前也会做检查，git push 前 lint 的检查部分也有 markdown 的检查。（具体参考 package.json 里面 <code class=\"language-text\">pre-push</code> 和 <code class=\"language-text\">pre-commit</code> 部分的定义，lint-staged 的定义在 <code class=\"language-text\">lint-staged</code> 下面）</p><p>增加了 lint 工具之后，也对文档做了细小的调整。主要是：</p><ol>\n<li>几个过长的 header title 被缩短了</li>\n<li>去掉了一些不可见的零宽空格</li>\n<li>增加了一些必要的空行</li>\n</ol><p>这部分的代码还没有正式发布。</p><p>TODO：针对第一点，修改的 header 标题需要 marketing 团队确认，是否符合要求。</p></section></section><section><h2>assets</h2><p>assets 目录下存放了非常少量的图片资源。Rollup 不具备打包各种非 JavaScript 内容的能力，所以这里要处理图片并不非常容易。现在的做法是这样的：在 assets 下面放好文件，然后程序在编译的时候会去读取这些文件，将这些文件的内容转化成 base64 编码的字符串，然后赋值给 process.env.ASSETS.filename.png 这样的全局变量。程序中以字符串的形式对这些内容引用。这里，编译的过程见 build/getEnvValues.js 文件。</p></section><section><h2>build</h2><section><h3>browserlist.js</h3><p>这个文件里面主要定义了 browserlist 的配置，browserlist 的配置是给 Babel 编译使用的。babel-preset-env 会根据 browserlist 的配置，来选择哪些语法需要被转换，哪些语法可以直接使用。目前，访客端的浏览器支持如下：</p><ul>\n<li>占有率在 5% 以上的浏览器</li>\n<li>每个主流浏览器的最新两个版本</li>\n<li>IE9+</li>\n</ul></section><section><h3>build.iframe.js</h3><p>这个文件的作用是编译出页面文件。访客端有一些地方需要用到页面文件，比如说弹出式窗口，（）等。这些页面文件统一都用这个文件编译出来。在编译的时候，通过给定一个参数来指定最终编译出来的文件的名称。比如 <code class=\"language-text\">node ./build/build.iframe.js xxx.html</code>，那么最终编译出来的文件就是 xxx.html。如果不指定，程序会报错，不会执行（见文件的最后几行代码）</p><p>程序的执行逻辑如下：</p><ol>\n<li>根据指定的 xxx.html 文件名，找到 src/xxx 目录下的 index.js 文件，作为编译的起始文件（ln 181）</li>\n<li>编译完成后，生成 iife 形式的最终代码（ln 129）</li>\n<li>读取 iframe.ejs 模板文件，把生成的代码插入到 &#x3C;%- script %> 指定的位置（ln 134-139）</li>\n<li>压缩 HTML 代码（ln 140-152）</li>\n<li>在 HTML 的顶部增加一些编译的信息。包括当前的版本号（从 package.json 中读取），build 的时间（这里手写了一个输出时间格式的函数 now，主要是为了模糊时区的信息，不让人知道编译时间集中在东八区的白天），git 的 commit id 。这些信息主要的作用是，在发布之后，如果出现了问题，比较容易知道具体是从哪里编译出来的版本；同时，测试在测试版本的时候，也可以通过这里的数据简单检查一下，看是否使用到了最新提交的版本。</li>\n<li>将最终的代码存储到 dist 目录下，同一份代码会生成多份输出文件。内容是一样的，但是文件名不同，主要是增加了 free （给免费服务器用），或者增加了 hash 值（用 sha1 计算出来的指纹）。具体的使用，Roy 比较清楚。</li>\n</ol><p>其中，JavaScript 部分的编译配置如下：</p><ul>\n<li>会根据命令行是否有 —production 或 -p 来确定是否要编译压缩的代码。如果要，就使用 uglify 来压缩代码。其中，ascii<em>only 的配置让 uglify 只使用 ascii 的字符而不使用 unicode，避免不必要的解析问题。unsafe</em>math 和 side_effects 可以在一定程度上进一步压缩代码，主要是可以提前计算部分信息。目前使用上没有发现异常。如果这里的压缩导致了程序异常，可以考虑把相关的配置去掉。</li>\n<li>rollup-plugin-json 使得程序可以直接 import json 文件，import 后的值就是一个 JavaScript object</li>\n<li>\n<p>alias 的部分做了这么几件事情：</p>\n<ul>\n<li>import 的时候不需要指定后缀，默认会试试 .js 或者 .jsx，都不行的话就不添加额外的后缀，这是 resolve 的定义部分</li>\n<li><code class=\"language-text\">@/xxx</code> 会被指定为 <code class=\"language-text\">src/xxx</code>，是一个简写的方式，用绝对引用代替一般的相对引用</li>\n<li><code class=\"language-text\">css/xxx</code> 会被指定为 <code class=\"language-text\">css/xxx</code>，也是一个简写的方式，这样深层的 js 文件可以直接引用顶层的 css 目录下的文件，而不需要写很多的 <code class=\"language-text\">../</code></li>\n</ul>\n</li>\n<li>resolve plugin 的作用有点忘了（看上去 browser:false 的部分不是非常必要），可以试试删掉会出现什么问题，会比较清楚当初为啥加上</li>\n<li>babel 的部分是 babel 的配置：不使用顶层的 babelrc 文件（babelrc: false），presets 主要是用到了 babel-preset-env（browserlist 的配置在这里使用），babel-preset-stage-3 和 babel-preset-react。访客端的项目，babel 还没有升级，升级之后这里 stage 的配置应该就不需要了。plugin 的部分，transform-react-jsx 是转化 jsx 文件用的，由于使用的是 preact 而不是 react 库，需要指定 pragma: ‘h’；external-helpers 可以插入一些必要的辅助函数；transform-string-join 是一个小的 babel 插件，可以提前计算 string 的合并，把 <code class=\"language-text\">[&#39;a&#39;, &#39;b&#39;].join(&#39;,&#39;)</code> 编译成 <code class=\"language-text\">&#39;a,b&#39;</code>，具体可以看这个插件的说明文档。如果是 production 模式，孩会用 transform-remove-console 来删掉 console 的使用（IE9 默认不开 devtool 使用 console 会报错，线上也不应该有额外的 console 输出）transform-react-remove-prop-types 可以把 .propTypes 的定义删除（这里因为 JavaScript 的动态性，默认 .propTypes 是不会删除的，但是从业务上来说，线上的代码不需要 propTypes 的检查，删除不影响使用，还可以减少包的大小）</li>\n<li>replace 的部分，可以把一些定义过的 process.env. 变量替换为具体的值。（比如把 process.env.ASSETS.xxx.png 替换为 assets/xxx.png 文件的 base64 字符串等，具体说明见 getEnvValues.js 文件部分）</li>\n</ul></section><section><h3>deploy.js</h3><p>这个文件做一个非常简单的事情，把 dist 目录下编译好的内容，根据 branding.yaml 中的配置，复制到 deploy 目录下指定的子目录中。这样的目的，是可以方便提供一个完整的包给测试。</p><p>从 dist 目录到 deploy 目录的文件映射关系，见 branding.yaml 中的 deploy 字段（每个 branding 都会有一个 deploy 字段，其中 livechat100 的部分应该已经没有用了，这个 branding 已经不在维护了）</p><p>branding.yaml 中的 deploy 书写，形式如下：key 的部分是 dist 中目录的名称，key 对应的 value 是一个数组，表示映射到的 deploy 目录的位置。这里的映射是一个一对多的关系，因为存在很多个不同的服务器，都需要发布。这里，key 的文件名允许出现 *，可以匹配一段不包含 . 的字符串（见 ln 13），主要是用来匹配 hash 值的。value 数组中的字符串，可以使用 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">示</mi><mi mathvariant=\"normal\">原</mi><mi mathvariant=\"normal\">始</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">文</mi><mi mathvariant=\"normal\">件</mi><mi mathvariant=\"normal\">名</mi><mi mathvariant=\"normal\">称</mi><mi mathvariant=\"normal\">，</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi mathvariant=\"normal\">.</mi><mi>j</mi><mi>s</mi><mi mathvariant=\"normal\">会</mi><mi mathvariant=\"normal\">在</mi><mi mathvariant=\"normal\">复</mi><mi mathvariant=\"normal\">制</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">时</mi><mi mathvariant=\"normal\">候</mi><mi mathvariant=\"normal\">直</mi><mi mathvariant=\"normal\">接</mi><mi mathvariant=\"normal\">替</mi><mi mathvariant=\"normal\">换</mi><mi mathvariant=\"normal\">掉</mi><mi mathvariant=\"normal\">；</mi></mrow><annotation encoding=\"application/x-tex\">name 表示原始的文件名称，deploy.js 会在复制的时候直接替换掉；</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">e</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">示</span><span class=\"mord cjk_fallback\">原</span><span class=\"mord cjk_fallback\">始</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">文</span><span class=\"mord cjk_fallback\">件</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord cjk_fallback\">称</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">.</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord mathdefault\">s</span><span class=\"mord cjk_fallback\">会</span><span class=\"mord cjk_fallback\">在</span><span class=\"mord cjk_fallback\">复</span><span class=\"mord cjk_fallback\">制</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">候</span><span class=\"mord cjk_fallback\">直</span><span class=\"mord cjk_fallback\">接</span><span class=\"mord cjk_fallback\">替</span><span class=\"mord cjk_fallback\">换</span><span class=\"mord cjk_fallback\">掉</span><span class=\"mord cjk_fallback\">；</span></span></span></span>server-version 表示对应的服务器版本号，在 deploy.js 中会做替换，这里的值是从 package.json 里的 server-version 中取得的。</p><p>同时，如果一个 dist 中的文件名是 branding-name.filename 的形式，最终复制到 deploy 目录下的时候，branding-name 会被删除，最终的名字是 filename。如果 branding-name 的部分和指定的 branding name 不符合，那么这个目录/文件就不会被复制。</p></section><section><h3>getBranding.js</h3><p>这个文件提供了和 branding 相关的各种辅助函数。在之前的项目里，有需求需要一份代码可以编译出不同 UI，不同商标的最终代码。因而需要一个 branding.yaml 文件来指定一些差异化的地方（比如 logo）。在实际编译的时候，通过命令行 —branding xxx 来指定当前需要编译的 branding 是哪一个（对应到 branding.yaml 中顶层的某一个 key，比如 —branding comm100 用于编译 comm100）</p><ul>\n<li>getName 用于检查通过命令行 —branding 提供的 branding 是哪一个</li>\n<li>getConfig 用于根据提供的 branding name 来读取 branding.yaml 中相对应的 branding 配置，返回是一个 object</li>\n<li>getAllConfig 用于获取所有的 config</li>\n<li>hasNameProvided 用于判断 —branding name 是否提供了</li>\n</ul></section><section><h3>getEnvValues.js</h3><p>这个文件主要是给 rollup 中的 replace 用的，用于字符串的替换。主要做这么几个事情：</p><ol>\n<li>process.env.NODED_ENV 判断是否是 production，还是 development</li>\n<li>process.env.IS_PREVIEW 判断当前的运行环境，是不是给 Control Panel 中，LiveChatFun 下面的聊天窗口 preview 使用的</li>\n<li>process.env.USE_PARENT 这个用于决定代码中是否可以直接使用 window 作为顶层的 object（对于嵌入式窗口来说，window.top 才是顶层，但是对于弹出窗口来说，没有了 iframe，直接 window 就是顶层了）</li>\n<li>process.env.IS_CORDOVA 用于判断是否是 cordova 的代码，true or false</li>\n<li>process.env.IS_GALLERY 用于判断当前的代码是不是给 gallery 用的（gallery 通过生成各种 redux state 来创建各种 UI 结果，通过图像对比来判断代码改动是否符合预期）</li>\n<li>process.env.IS_BotPreview 判断是否是 control panel bot 部分的 preview</li>\n<li>webrtc-adapter 在 Cordova 的环境下不应该被引用（rollup 不支持动态的 import，所以这里用 replace 的方法直接删除 webrtc-apdater 引用的相关代码）</li>\n<li>process.env.BRANDING.xxx.yyy 的值，就是 branding.yaml 中，某一个 branding 下面，xxx.yyy 的值（这里的 branding 通过 —branding name 来指定）</li>\n<li>process.env.ASSETS.xxx.png 的值，是一个 base64 的字符串，对应的是 assets 目录下的 xxx.png 图片的值。由于图片很少而且比较小，直接通过 base64 的方式编译到 js 文件中并不会增加太多额外的代码量。</li>\n</ol></section><section><h3>iframe.ejs</h3><p>build.iframe.js 中需要用到的模板文件。在编译 html 文件的时候，目前都会公用这个模板文件。主要的区别就是插入的 script 不同，script 是通过 build.iframe.js 编译出来的，不同的文件对应的入口文件不同，所以最终的结果不同。</p></section><section><h3>less.config.js</h3><p>这个文件是用于编译 css 文件的。访客端的 css 使用了 less 作为编译器。目前需要编译出来的 css 一共有三个，分别是 style.min.css / chat-button.min.css / side-window.min.css，对应的入口文件分别是 style.less / chat-button.less / side-window.less（见 ln 34-35）</p><p>如果命令行检测到了 —watch，那么就会开启 less 编译的 watch 模式，每次 less 文件改动，都会触发重新编译。同时，如果开启了 js 的 watch 编译模式，css 的改动又会触发 js 的编译，最终编译完成后，刷新页面就可以看到效果。</p><p>convertAll 函数加上了 debounce，也是考虑到 watch 模式下，一个简单的改动可能多次触发编译。确保 100ms 内的多次修改只会触发一次真正的编译。</p><p>less 的编译用到了两个插件，分别是 autoprefix（用于给老版本的浏览器加上一些 prefix 的支持，用到的 browserlist 信息依然来自 browserlist.js），一个是 clean-css，用于 css 的代码优化。</p></section><section><h3>rawTransformer.js</h3><p>这个是给 jest 使用的模块。直接把引用 css 的地方直接处理成空字符串。（使用位置见 package.json 中 ln 185）</p><p>因为在 rollup 的配置里面，css 也是被处理成 plain string 直接引用的，所以在单元测试的时候，至少保证变量的类型是一样的。但是，因为单元测试 js 的内容不关心具体 css 的值，所以这里的输出只需要空字符串就可以了，不需要具体的内容。</p></section><section><h3>release.js</h3><p>这个文件是 npm run release 的时候调用的。做这么几件事情：</p><ol>\n<li>检查是否有没签入的 git 改动，有的话不允许 release 编译。这里的目的，是为了避免在没有签入的情况下，本地编译一个最终会上线的包。由于没有签入，一旦后续需要修改 bug，会导致找不到原来的基准版本。造成不必要的麻烦。（注：这里的代码不知道为什么被删除了，建议找回来）</li>\n<li>删除 dist 和 deploy 两个目录下的内容</li>\n<li>依次执行各个编译命令</li>\n<li>npm run build:font 编译字体</li>\n<li>将 css/image 文件下的图片复制到 dist 目录下，每一个 branding name 复制一份（ln 83-86）</li>\n<li>将 api 文档复制到 dist 目录下，每一个 branding name 复制一份（ln 89-91）</li>\n<li>编译 css （ln 93）</li>\n<li>编译 JavaScript （buildJavaScript 函数）</li>\n<li>将 dist 目录下，指定 branding name 相关的文件都复制到 deploy 中（复制到 deploy 的方法见 deploy.js）</li>\n</ol></section><section><h3>rollup-plugin-hash.js</h3><p>这个是 rollup-plugin-hash npm 包的修改版本。首先，计算 hash 的时候会去掉顶部的注释，因为这里包含了编译时间，并不希望每次仅仅因为编译时间不同导致最终的 hash 值不同。</p><p>其次，针对编译出来的不同文件，如 bundle.xxxx.js，需要生成对应的 newlivechat 文件。对于贴代码的网站来说，首先下载的就是这个 newlivechat 文件，newlivechat 里面需要指定具体去下载哪个 bundle.xxx.js。这个指定的过程是在编译阶段写死的。另外，这里再生成的时候还会根据 branding name 做替换。比如说，comm100 使用的 api 名字是 window.Comm100API，而 livechat100 （已经弃用）用到的可能是 window.LiveChat100API。编译的时候会做字符串的替换（见 replaceCode 函数）</p><p>注意到除了 newlivechat.js 之外，还有 newlivechat.cordova.js / newlivechat.free.js / newlivechat.free.cordova.js 等，针对不同用途的入口文件。</p><p>其中，.free.js 这个是给免费用户使用的。免费用户在请求的时候，服务器会直接给这个 .free.js 的内容。这样的设计是为了给差异化发布使用的。最后的版本，可以先只发布免费的部分，免费用户使用没有问题之后，再全量上线。</p><p>另外，会在文件底部加上 map 文件的引用地址。因为我们的流程中一直没有对 map 文件的管理和发布，所以实际上这里的 map 一直都没有用起来，无法帮助线上问题的定位。这里需要改进。</p><p>另外，newlivechat.dev.js 是一个特殊的入口文件，这个入口是给调试使用的。调试的时候，不会生成 bundle.xxx.js 而是生成 bundle.js 文件。这样避免了每次修改之后都生成不同文件的麻烦。newlivechat.dev.js 中也直接指定 bundle.js。</p></section><section><h3>rollup.botpreview.config.js</h3><p>这个不太了解。</p></section><section><h3>rollup.config.js</h3><p>这个是访客端 js 文件编译的配置文件。这里大部分的配置和 build.iframe.js 中 rollup 的配置是一样的。不同的几个地方：</p><ol>\n<li>用 string({ include: ‘*<em>/</em>.css’ }) 来处理 css 文件，将 css 的内容读出来，转化成一个字符串，在 js 中直接引用。（在 js 里面，需要将这个字符串通过 style 的 tag 插入到 dom 中）</li>\n<li>redux-logger 这个库常年没有人维护了，依然用的是比较早的 nodejs module export 方法，所以需要用 commonjs 来转化一下（rollup 默认只支持 es6 的 import/export）</li>\n<li>license 的部分给编译好的 js 加上了一个顶部的注释，主要包括了当前编译的时间（时间去掉了时区的影响，不暴露编译大部分是在东八区白天进行的事实），版本号，最后一个 git 提交。</li>\n</ol><p>由于 rollup 的编译结果还是比较容易识别的，在不压缩的情况下，去掉了 sourcemap，反而调试方便一些。</p></section><section><h3>rollup.pciform.config.js</h3><p>这个不太了解。</p></section><section><h3>rollup.preview.config.js</h3><p>这个文件是为了编译出 preview.js 的，这个文件是给 control panel 中预览聊天窗口使用的。</p><p>大部分的配置和前面的 rollup.config.js 是一致的，最后加上了一个 onwrite 的回调，生成 preview 和 preview.next 两个文件。preview.next 是给免费用户使用的。在某些情况下，可以只发布这个 preview.next.js 这样只有免费用户会看到代码的改动。（应该配合 newlivechat.free.js 一起发布，这样后台和网站上看到的都会是匹配的，且只有免费用户受到影响，收费客户没有变化）</p></section><section><h3>rollup.view.config.js</h3><p>这个文件可以编译出 view.js。只提供一个对外的接口，接口接受一个 state 参数，函数会在 id 是 process.env.BRANDING.ids.uiContainer 的 div 下面，生成 dom tree。（uiContainer 的定义见 branding.yaml）</p><p>有了这个函数，就可以批量生成各种情况下的 redux state，然后用 puppeteer 来生成每一个 state 对应的 dom tree，截图生成效果。</p><p>如果有上一轮截图的结果的话，还可以通过像素级别的比较，查看当前和上一轮的代码改动造成的 UI 变化。</p></section><section><h3>t<em>onemaxon</em>platform.sql</h3><p>这个不太了解。</p></section><section><h3>uglify-cordova.js</h3><p>这个不太了解。</p></section><section><h3>font/font-generator.js</h3><p>在 css 目录下生成 Icon.css 文件（css 会用 cleancss 来进行压缩，ln 52），以及对应的字体文件。css 用的模板是 css-template.hbs（ln 43），html-template.hbs 暂时没有使用。</p><p>所有的字体 svg 都放在 css/icons 中，编译的时候会读取这里面的 svg 文件，最终生成字体文件。（ln 32-33）</p><p>最终生成的字体文件在 css/fonts 中。</p><p>在执行生成命令之前，updateIconHash 函数会删除上一次的编译结果。</p><p>注意，这里的字体文件路径会用 {FONT<em>URL</em>PREFIX} 来代替。在 js 中，会根据运行环境，将这个值替换成真实的 URL 地址。具体见 src/utils/business.js 中的 fontCSS 函数。</p></section></section><section><h2>cobrowse</h2><p>这个目录下放了一份 3.3.0 版本的 Glance 代码。主要是测试阶段，经常连不上 glance 的服务器，无法下载静态资源。之前有用过这样的方法来直接使用一个更容易拿到的静态资源。（见 src/store/cobrowisng.js ln 289）</p><p>在页面的 URL 中 search 里带上 cobrwoseDebug 就可以开启这个功能了。</p><p>不建议使用。</p><p>现在应该可以用合适的网络访问来避免这个问题了。建议删除这部分代码。</p></section><section><h2>css</h2><p>css 下面的 images 目录会直接复制到 deploy 中（见 branding.yaml 的配置和 deploy.js 的说明），所以可以直接在代码里面引用这些 images 文件。</p><p>css 下面的 fonts 目录和 images 目录类似。但是这里的文件一般是 css 文件直接引用的。</p><p>css 目录下面的入口文件有三个，style.less / chat-button.less / side-window.less。分别生成三个 style.min.css / chat-button.min.css / side-window.min.css，这三个文件分别在 src 中被直接引用。分别是给 chat window，adaptive chat button 和 side window 使用的。</p><p>variables.less 是一个比较特殊的文件，这里面定义了一些颜色的数据。这些颜色在定义的时候都是写成了非常特殊的值，从 #000001 开始。然后在实际运行的代码中，会通过字符串替换的方式替换成主题色和其他相对应的颜色。见 src/utils/busioness.js 中的 replaceThemeColors 函数。（这里的实现并不是非常的好，可以考虑改用 css variable。在实际运行的时候，如果 css variable 是支持的，可以直接使用，不支持的话再用字符串替换处理）</p></section><section><h2>dev</h2><p>这个目录下面存放了开发服务器相关的所有代码。</p><p>除了 server.js 外，大部分的代码是为了 mock 真实服务器而存在的。但是这部分代码已经不再使用了，一般调试的过程中还是建议直接链接一个真实的测试服务器。</p><p>需要说明的几个文件。</p><section><h3>gallery.html</h3><p>TODO</p></section><section><h3>portAssigner</h3><p>这个文件的意义，是为了给每一个开发者指定一个不同的端口号起始位置。这样所有人在同一台机器上进行开发的时候，不同的人起服务后使用的端口号是不一样的。（实际使用的端口号，是起始端口号加上 401，见 dev/server.js ln 16）</p></section><section><h3>screenshots.js</h3><p>因为我们的代码是通过 redux state 来驱动的，所以如果可以生成各种类型的 state，那么就可以渲染出各种情况下的 UI。这里的代码，就是为了做这个事情。通过 src/gallery.js 下面的代码生成各种 state，然后调用 dist/view.js （由 src/view.js 生成）来渲染出 UI，通过 puppeteer 得到最终的图片，通过和上一轮代码的渲染结果的像素对比，找出差异化的地方。</p><p>具体的执行逻辑是这样的：</p><ol>\n<li>require(‘../src/gallery.js’) 引入了 gallery 的代码。gallery 里面 window.run 暴露了接口。这个接口会在 screenshots.js 中通过 global.window.run 获取到（ln 11）</li>\n<li>执行比较需要用到 view.html / view.previous.html 两个入口页面，分别渲染出当前代码和之前一个版本代码的结果。两个页面的代码是一样的，只不过 view.html 引用的是 view.js，而 view.previous.html 引用的是 view.previous.js。</li>\n</ol><p>（在使用的时候，需要先用 rollup.view.js 编译出 dist/view 文件，然后拷贝到 dev 下面。运行 screenshots 出结果。然后，需要把 dev/view.js 修改成 dev/view.previous.js，因为这个版本就变成“上一个版本”了，下一次运行的时候，拷贝过来新的 view.js，可以直接和这个 view.previous.js 来进行执行结果的比较）</p><ol start=\"3\">\n<li>getBrowser 用 puppeteer 运行 chrome，位置定义在 30 行，不同的开发机不一定一样，这里可能需要修改</li>\n<li>pool 生成了一个线程池，最多 10 个 tab 一起运行。</li>\n<li>每隔一秒，从 iterator 中取下一个 state，然后放到 main 里面去渲染结果（渲染的时间超过了 1s，所以这里线程池 10 个最终会都用起来的）</li>\n<li>核心的代码在 main 函数里面，做了这么几个事情：</li>\n<li>访问 view.html，设置窗口的大小和 state.page.width / state.page.height 一致</li>\n<li>用 page.evaluate(s => window.view(s), state) 来渲染 state。这里需要通过 .evaluate 来将 screenshot 运行环境下的 state 提供给 puppeteer 的 chrome 环境。window.view 是 view.js 暴露出来的接口（见 rollup.view.js 说明）</li>\n<li>等待五秒后，截屏</li>\n<li>同样的步骤，访问 view.previous.html，生成一个针对同样 state 的截屏</li>\n<li>用 pixelmatch 来比较前后两个图片的差异，threshold 1%，如果超过阈值，就将结果生成到 diff 文件下</li>\n<li>当前版本的截图放到 screenshots/index.png 中</li>\n<li>screenshots.description.txt 中插入一条，记录当前这个 index 的图片，是根据什么样的 state 渲染出来的。（描述在 state.description 中，这个值的设置见 src/gallery.js）</li>\n</ol><p>由于 gallery.js 中 generator 生成了很多的 state，整个运行的过程大概需要两三个小时。建议放到中午吃饭或者晚上下班后进行，回头再来查看结果。</p><p>如果需要缩短运行时间，就需要对 gallery.js 中的代码做剪枝。但是这里不太容易，因为有可能把可能的情况给剪掉了。</p><p>另外，这里即使是相同的 view.js，也可能生成出不同的 screenshots，主要是一些简单的动画（如 loading）会造成视觉差异。可以在后续中考虑使用 process.env.IS_GALLERY 这个判断来去掉动画或其他可能影响到判断的地方，确保两次运行的结果是一样的。</p><p>另外，将 view.js 重命名成 view.previous.js 的过程也可以写道 screenshots.js 里面。建议在覆盖原来的 view.previous.js 前，备份一份原来的 view.previous.js，免得版本找不到了。这里的覆盖动作可以在全部 screenshots 比较完成后进行。</p></section><section><h3>server.js</h3><p>这个文件是用于开启调试服务器用的，主要做几个事情：</p><ol>\n<li>开始一个 mock 服务器（不再使用）</li>\n<li>为静态文件提供服务（参考 ln 378 开始的部分）</li>\n<li>对于 newlivechat.js 来说，除了提供入口文件之外，还需要和真实的服务器一样写入入口的服务器地址。针对不同的测试环境，可能需要修改这里的服务器地址。可以修改 getServerUrl 这个函数的返回值，数组至少一个值，第一个是主服务器地址，第二个是副服务器地址。</li>\n</ol></section><section><h3>test.html</h3><p>这个页面是测试时候用到的入口文件。这个页面做了几件事情：</p><ol>\n<li>如果 shouldMesseUp 设置为 true，会把页面上的一些 prototype 函数给改坏掉（因为我们的代码是运行在客户网站上的，我们的代码不能假设客户网站上的 prototype 是正确的，非常有可能客户自己修改了 prototype 的代码，比如重写了 Array.prototype.map 函数，直接调用可能导致错误。由于我们的代码已经运行在 iframe 中了，所以理论上来说这里应该已经不会有问题了，shouldMesseUp 暂时默认写的是 false）</li>\n<li>window.core 的设置也和上一条理由差不多。主要是为了保证 core-js 不会改客户网站上的代码，比如覆盖 window.core</li>\n<li>代码会从 url 中读取 siteid 和 plainid 的值。如果没有 plainid 就认为是 dynamic campaign。然后就插入相对应的代码。</li>\n</ol></section></section><section><h2>test</h2><p>test 目录下面放了一些实验性质的代码，主要是用 Puppeteer + Jest 来尝试做和 screenshot.js 类似的功能。jest 原生提供了比较好的 snapshot 比较功能，加上 toMatchImageSnapshot 这个功能扩展的帮助，可以比 screenshot.js 中自己手写代码方便一些。toMatchImageSnapshot 这个功能是在 jest.setup.js 中定义扩展的。而 jest.setup.js 是在 jest.e2e.config.json 中定义使用的，jest.e2e.config.json 是在 package.json 的 e2e 命令中，以 <code class=\"language-text\">jest --config jest.e2e.config.json</code> 的方式指定的。</p><p>未来可以考虑直接用 gallery.js 生成各种 state，然后用 jest 这里的框架直接声称图片的比较。优点是 jest 做了大量的工作，包括事先的编译工作都可以免去了。然而缺点也是比较明显的：为了保证 snapshot 的比较，需要将大量的截图上传到库里面，这个量非常大；另外，jest 比较出来，第一次可能有不同，需要人工比较后，确认没有问题了，再跑一次把内容覆盖掉，生成新的 snapshots，两次跑全量会非常耗费时间。</p><p>参考的代码大概如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> run <span class=\"token keyword\">from</span> <span class=\"token string\">'src/gallery'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> view <span class=\"token keyword\">from</span> <span class=\"token string\">'src/view'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'e2e demo'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// setups first ...</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> state <span class=\"token keyword\">of</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">it</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>description<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// take screenshot after running view(state) inside puppeteer</span>\n      <span class=\"token keyword\">const</span> img <span class=\"token operator\">=</span> <span class=\"token function\">takeScreenshot</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      img<span class=\"token punctuation\">.</span><span class=\"token function\">toMatchImageSnapshot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div></section><section><h2>.babelrc</h2><p>这个 babelrc 的配置可能在编译中没有实际使用，因为 rollup 中的配置，基本都设置了 <code class=\"language-text\">babelrc: false</code></p></section><section><h2>.editoconfig</h2><p>这里的配置主要是给 VSCode 增加一些默认的设置，同步不同工程师的开发环境。比如说默认的文件都以 lf 作为结尾（而不是 windows 默认的 crlf），文末需要插入一个额外的空行，保存的时候删除行尾多余的空格，tab 转化为 space，一个 tab 等于 2 个 space，默认的字符集使用 utf8。</p><p>这些配置在 ESlint 中都有相对应的 rule 检查。</p><p>另外，不太清楚的是现在版本的 VSCode 是否还会遵循这里的配置。</p></section><section><h2>.esdoc.json</h2><p>这里是给 esdoc 的配置。esdoc 用于根据 JavaScript 代码中的 jsdoc 注释来生成文档文件。基本上这个已经废弃了，没有实际使用的场景。</p><p>另外，在 JavaScript 项目中，使用 jsdoc 来注释函数等依然是有意义的。VSCode 会根据这些 jsdoc 的注释来做类型推断。因为访客段还没有开始使用 TypeScript，这里的 jsdoc 还是可以有所帮助的。至少，VSCode 在知道类型之后，可以给出更好的 intellisense。所以虽然 esdoc 废弃不用了，但是 jsdoc 注释的部分建议保留，并可以考虑多写写。</p></section><section><h2>.eslintignore</h2><p>有些文件不需要 eslint 检查，写在这里</p></section><section><h2>.eslintrc</h2><p>ESLint 相关的配置都写在这个文件里面。一些简单的说明：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">extends</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'airbnb'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 我们的 ESLint 配置是基于 Airbnb 的 ESLint 配置，官网见：https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb</span>\n                     <span class=\"token comment\">// 这里我们用的版本还是比较老的，14.1.0，文档写的时候最新版本已经是 17.1.0 了。可以考虑对这个进行升级，但是升级会带来大量的代码重新不符合规范，需要花时间修正。</span>\n                     <span class=\"token comment\">// 升级是可以带来实际好处的，比如会有新的 accessibility 相关的规则帮助产品更好的满足 WCAG 的要求。可以找一个时间进行升级。</span>\n                     <span class=\"token comment\">// 另外，一个 tip，如果升级中发现某些规则的加入导致了大量的 errors，可以考虑在这个配置文件里面先把这个对应的规则改成 warning，然后慢慢改完之后，再去掉 warning 的配置覆盖</span>\n  settings<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> react<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> pragma<span class=\"token punctuation\">:</span> <span class=\"token string\">'h'</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 这个就是为 preact 设置的，preact 不使用 react.createElement 而是使用 preact.h 函数来创建 virtual dom</span>\n  <span class=\"token string\">'import/resolver'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'eslint-import-resolver-custom-alias'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      alias<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'@'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'./src'</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 这里两个是和 rollup 中相同的配置。对于大型的项目来说，引用尽量应该使用绝对路径而不是相对路径（特别是引用的模块不是在子目录的时候——这往往意味着引用之间的关系至少是平级的）</span>\n        <span class=\"token string\">'css'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'./css'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 这里用 eslint-import-resolver-custom-alias 插件来同步 eslint 中的配置，这样 eslint 在看到 import 'src/xxx' 的时候，就知道去什么位置寻找文件</span>\n                        <span class=\"token comment\">// 从而可以更好的判断引用位置的文件是否存在了（如果不存在，eslint 会给出报错）</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  env<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> es6<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> jest<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> browser<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 我们的项目是基于浏览器的，同时会用到 jest 的单元测试，所以这里的环境这么配置（这样 ESLint 知道那些变量是默认的全局变量，而不是忘了引用）</span>\n  rules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'no-restricted-globals'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'top'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 这个规则和下面的 no-restricted-properties 是相互配套使用的，禁止了 window.top 的使用</span>\n    <span class=\"token string\">'no-restricted-properties'</span><span class=\"token punctuation\">:</span>  <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>     <span class=\"token comment\">// 如果需要使用宿主环境的 window （比如获取 window.Comm100API 值），可以使用 utils/env.js 中的 global</span>\n    <span class=\"token string\">'valid-jsdoc'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 合格的 jsdoc 往往要写很多内容，由于已经不需要用 esdoc 来生成文档了，写全 jsdoc 的意义并不大</span>\n                      <span class=\"token comment\">// 这里改成 warning，可以按需只写部分 jsdoc（比如只写参数的类型，不写返回值的类型，vice versa）</span>\n    <span class=\"token string\">'jsx-a11y/no-static-element-interactions'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token comment\">// 理论上来说，不应该在 div 等元素上面加 onClick 之类的事件，应该用 a 或者 button 之类的</span>\n                                                 <span class=\"token comment\">// 这些元素浏览器都会有默认的键盘行为支持，可以更好的服务于残障人士。（比如 focus 后按会车可以出发 onClick 之类的）</span>\n                                                 <span class=\"token comment\">// 但是由于历史的原因，这里改成 warning，暂不要求原有的部分都统一改对。</span>\n                                                 <span class=\"token comment\">// 另外，Firefox 对 button 元素里有 children 的支持好像是比较奇怪的，在使用的时候需要注意。</span>\n                                                 <span class=\"token comment\">// 如果对于需要 onClick 的情况都用 a 标签，也会不太符合语意，ESLint 也会有其他的报错。</span>\n                                                 <span class=\"token comment\">// 这里可能需要细致的测试和一定的工程上的取舍。建议暂时不去掉 warning。</span>\n                                                 <span class=\"token comment\">// 但是对于新加入的元素，应该保证都使用符合 WCAG 标准的设置方式。主要是要有键盘操作的支持。</span>\n    <span class=\"token string\">'react/no-unused-prop-types'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>， <span class=\"token comment\">// 这里主要是怕麻烦，有很多报错，所以 error 改 warning 了，可以考虑改回去</span>\n    <span class=\"token string\">'react-jsx-filename-extension'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 后缀使用问题都不大，这个规则就关闭了</span>\n    <span class=\"token string\">'react/prop-types'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 因为 preact 本身没有 propTypes 的支持，代码里有些地方有 propTypes 的检查，也是手写上去的，所以加上这个规则意义不大</span>\n                           <span class=\"token comment\">// 所谓手写的检查，可以参考 src/compoennts/HoC/validation.js 这个高阶函数，在 development 模式下，会对 props 进行手动检查。</span>\n                           <span class=\"token comment\">// 因为不是每个组建都套了 validation，所以这个规则开启的意义不大。</span>\n    <span class=\"token string\">'react/require-default-props'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 理由同上</span>\n    <span class=\"token string\">'import/no-extraneous-dependencies'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 在 src 下面，devDependencies 里的库不应该被引用，但是对于 test 或者 storybook 的部分，是可以允许的</span>\n    <span class=\"token string\">'id-blacklist'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 这里规定了一些不应该使用的单词，会以 warning 的形式给出。主要是一些已经被 marketing 团队弃用的说法，比如 codeplan 已经改成 campaign 了</span>\n                        <span class=\"token comment\">// visitor monitor 也改叫 agent console 了，operator 改成 agent 了。这些说法的改变，理应同时造成代码层面的改变，不然陈旧的代码不利于后期</span>\n                        <span class=\"token comment\">// 其他后加入工程师的理解（因为他们显然不会了解其中的发展历史）。但是受限于改动可能会涉及到很多的地方（特别是 codeplan 这个字段，在一些对象中作为属性</span>\n                        <span class=\"token comment\">// 存在，改不全容易出现问题），所以暂时只是 warning，而不是 error 级别的报错。</span>\n                        <span class=\"token comment\">// 另外，注意到这里没法区分大小写等不同的等价写法，所以对于一个词可能出现的多种写法，最好都加上，比如 codeplan，codeplans，codePlan，codePlans 等</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div></section><section><h2>.gitignore</h2><p>一些不需要 git 签入的内容。</p><p>原则上来说，编译生成的内容不应该签入到库里面（因为每个人都可以编译生成），临时文件/cache 等不应该签入到库里面。</p><p>注：gitignore 中写到的内容不代表一定不会在库里出现。如果一个文件已经在库里了，后来又加到了 gitignore 中，那么这个文件不会被删除的。如果需要删除，执行 <code class=\"language-text\">git rm xxx</code> 才行，执行完，签入后，这个文件不会再被加入到库里面。</p></section><section><h2>.eslintrc_old.js / .gitmodules / bitbucket-pipelines.yml / ci.bat / pack.bat / zip.bat / zip240.bat</h2><p>可以删掉的文件，其中，bitbucket-pipelines.yml 是代码还在 bitbucket 的时候，配置的 pipleline，现在已经没用了。</p><p>pack.bat 的部分，应该可以由 build/deploy.js 的代码取代了。</p><p>zip.bat 和 zip240.bat 应该是一些可以上传压缩包到指定 目录/ftp 的脚本。在内网开发环境中应该用不到了。另外，如果今后需要用到自动化的脚本，建议直接写 JavaScript 的脚本，然后用 node 运行，灵活性更大一些。也没有操作系统的限制，参考 deploy.js 的代码。</p></section><section><h2>.remarkrc</h2><p>remark 部分的 lint 配置。remark-cli 默认使用的是 <code class=\"language-text\">@laysent/remark-preset-lint</code> 这个包的配置定义，完整的定义可以查看<a href=\"https://github.com/laysent/remark-lint-plugins/tree/master/packages/remark-preset-lint\">这里</a>。</p><p>同时，考虑到文档样式，将最长允许的代码长度改为一行 100 个字节。</p></section><section><h2>.stylelint</h2><p>stylelint 的部分，扩展了 stylelint-config-standard</p></section><section><h2>branding.yml</h2><p>之前做 livechat100 项目的时候新加入的文件。这里配置了程序用到的，和品牌相关的一些内容，比如 logo 的样式，文字，链接地址等。虽然 livechat100 已经不再维护了，但是考虑到还有在使用的 partner 项目，建议保留 branding.yml 的配置数据，方便 partenr 项目根据这个文件生成新 partenr 的编译文件。</p><p>branding.yml 的顶层 property name 就是 branding 的名字。对应的 value 就是配置信息。具体的使用方式可以参考上面 build 部分的说明。</p><p>文件中有比较详细的属性用途说明，这里不赘述了。</p></section><section><h2>jest.e2e.config.json / jest.setup.js</h2><p>这两个文件是给 npm run e2e 使用的，说明见 test 目录下文件的说明部分。</p></section><section><h2>jest.global.js</h2><p>这里定义了全局变量，主要包含几个部分：</p><ul>\n<li>window.Comm100API 的定义，这个是贴代码的网站上都应该有的</li>\n<li>process.env.xxx 的定义，这个是编译环境里肯定会给的，所以测试环境里也要都提供</li>\n</ul></section><section><h2>jsconfig.json</h2><p>这个文件和一般 TypeScript 项目中的 tsconfig.json 文件比较类似，可以帮助 VSCode 了解当前 JavaScript 项目的一些配置信息。重点主要还是指定了 <code class=\"language-text\">baseUrl</code> 和 <code class=\"language-text\">paths</code> 这两个部分，这样 VSCode 也可以知道 rollup 里面配置的 alias 的路径了。（注意，<code class=\"language-text\">import &#39;css/xxx&#39;</code> 的部分不需要写到 paths 里面，因为 css 就是顶层下面的一个目录，所以 <code class=\"language-text\">baseUrl: &#39;.&#39;</code> 就已经保证了 <code class=\"language-text\">css/xxx</code> 可以被直接找到了）</p><p><code class=\"language-text\">baseUrl</code> 的意思是，当遇到非相对路径的时候，VSCode 会以 <code class=\"language-text\">&#39;.&#39;</code> 为其实位置，计算真实路径。</p></section><section><h2>ngrok.exe</h2><p>应该是一个客户让局域网的文件在广域网里被访问到的工具，具体可以文 Roy。考虑到公司的开发环境限制很多，这样直接暴露局域网的工具，不是非常建议直接使用。如果需要调试其他设备，建议用 Wi-Fi 链接到同一个局域网下面，然后就可以直接访问了。另外，https 也可以通过生成自签名证书的方式解决。</p></section><section><h2>package.json</h2><p>一些说明：</p><ul>\n<li>\n<p>version：这个值是会写到编译结果最上面的注释里面去的，每次发布之前应该都要修改</p>\n</li>\n<li>\n<p>scripts</p>\n<ul>\n<li>js：编译 js，<code class=\"language-text\">npm run js -- --watch</code> 可以开启 watch 模式</li>\n<li>js:cordova：编译 cordova 版本的 js</li>\n<li>js:prod：编译 prodction 版本的 js</li>\n<li>uglify:cordova：不太清楚</li>\n<li>css：编译 css（参考 build/less.config.js 中的说明）</li>\n<li>css:watch：带 watch 模式的编译 css</li>\n<li>build：编译 css 和 js</li>\n<li>build:iframe：编译 socialIframe（这个应该是给 Facebook / Google+ 登陆用的，其中 Google+ 因为已经停止运营，所以代码被删除了）Facebook 的登陆需要页面是在注册过的地址下面的（也就是 comm100.com 下面，所以需要一个额外的页面做交互沟通，同时满足 Facebook App 注册时候的信息规则）</li>\n<li>build:chatwindow：编译弹出式窗口的 html</li>\n<li>build:preview：编译 control panel 的 preview js</li>\n<li>build:botpreview：编译 bot 里面用到的 preview js</li>\n<li>build:view：编译 screenshot 命令中需要用到的 view.js，需要将生成的 dist/view.js 放到 dev/view.js 才能运行 screenshot 命令（见 screenshot.js 的说明）</li>\n<li>test：运行 jest 单元测试（用了 —runInBand，因为发现不安顺序一个个执行的话，有些单元测试可能会报错。这里最好是能在后续的版本中修复问题，去掉 —runInBand）</li>\n<li>test:watch：watch mode 打开，只跑修改了的文件的单元测试</li>\n<li>e2e：一个实验性质的 e2e 测试，见 test 目录下的说明</li>\n<li>story：运行 storybook 的服务器，目前基本不太能使用，重新开启需要修复一些问题，见 .storybook 下面的说明</li>\n<li>lint-staged：签入 git 文件时候需要做的 lint 检查，具体配置写在 package.json 里面</li>\n<li>lint：同时检查 js 和 css</li>\n<li>lint:js：检查 js 文件，用 eslint</li>\n<li>lint:css：检查 css 文件，用 stylelint</li>\n<li>build:font：编译字体</li>\n<li>server：开启一个开发调试用的服务器</li>\n<li>release：打包给测试的时候需要用的命令，所有用到的编译步骤这里都会走一遍</li>\n<li>release:livechat100：默认 release 只会编译 comm100 的内容，这个命令是编译 livechat100 的，可以删掉了</li>\n<li>zip：可以删掉了</li>\n<li>zip240：可以删掉了</li>\n<li>build:240：可以删掉了</li>\n<li>start：一个命令同时开启调试服务器和开启 js 的 watch 模式编译，理论上应该还要加上 css watch mode 编译，同时需要在 server 相关代码修改的时候重启 server，这部分改好了应该对开发体验有帮助（修改文件就重启 node 的部分，可以参考使用 <a href=\"https://github.com/remy/nodemon\">nodemon</a>）</li>\n<li>screenshots：用 puppeteer 做的 e2e 测试，见 screenshots.js 的说明</li>\n<li>customcss-full：这部分 mark 比较清楚</li>\n<li>customcss-classic：这部分 mark 比较清楚</li>\n<li>customcss-circle：这部分 mark 比较清楚</li>\n<li>build:pciform：这部分 mark 比较清楚</li>\n<li>build:pciformPreview：这部分 mark 比较清楚</li>\n</ul>\n</li>\n<li>\n<p>lint-staged 这里的配置主要规定了当有文件签入的时候，应该进行哪些检查（.js/.jsx 文件用 eslint 检查，.css 文件用 stylelint 检查），如果报错，理论上无法 git 签入成功（注意，这里的 lint-staged 只是一个君子协定，前端肯定是可以绕过去的，后续应该考虑在服务器端通过 CI 的配置，进行检查，如果不能通过 lint 应该要由服务器来拒绝签入）</p>\n</li>\n<li>\n<p>pre-commit: [‘lint-staged’] 这里定义了签入文件的时候应该执行 <code class=\"language-text\">npm run lint-staged</code></p>\n</li>\n<li>\n<p>pre-push 在 push 代码之前，应该执行 lint 和 test 代码。同样，这个也是君子协定，前台可以通过 <code class=\"language-text\">--no-verify</code> 绕过去。后续还是应该通过 CI 的配置来由服务器拒绝不合格的代码签入。</p>\n</li>\n<li>\n<p>jest：这里配置了 jest 用到的设置信息</p>\n<ul>\n<li>collectCoverageFrom 定义了哪些文件应该算到 code coverage 中</li>\n<li>coverageThreshold 定义了最顶的代码覆盖率要求，即使测试都通过了，如果覆盖率不够，依然会测试不通过。这了需要尽可能提高覆盖率的值，目前 50～60 的阈值太低了，可以把目标定到 80 左右，太高也没必要</li>\n<li>transform 定义了文件应该经过什么样的预处理，比如 js 文件需要 babel 处理，css 文件用 rawTrasnformer 直接转化成一个空字符串被引用</li>\n<li>testUrl 定义了在 jest 的环境里面，url 地址是多少，这个在某些地方代码可能会需要访问 location.href 之类的字段</li>\n<li>setupTestFrameworkScriptFile 这里定义了最先需要执行 jest.global.js 来加入必要的 global 字段设置</li>\n<li>moduleNameMapper 这里是 jest 部分的 alias 设置，保持了和 rollup 相同的配置，这样 jest 也可以找到引用文件的真实位置</li>\n</ul>\n</li>\n<li>\n<p>browserlist 应该可以删掉了，没有在使用，和 browserlist.js 的配置也不太相同</p>\n</li>\n<li>\n<p>server-version 这个字段只在 deploy 的时候会用到，把 js 放到 chatserver 目录下面的时候，需要一个 server 的版本号作为目录的名字，这个名字在这里定义</p>\n</li>\n</ul></section><section><h2>src</h2><section><h3>entry.xxx.js</h3><p>这里有四个 entry 入口，基本上都是差不多的，主要是针对环境稍有不同。.dev.js 是给调试用的。cordova 是给 cordova 特别用的。</p><p>注：entry 的内容应该尽可能的小。根据 <a href=\"https://stackoverflow.com/questions/2613734/maximum-packet-size-for-a-tcp-connection\">https://stackoverflow.com/questions/2613734/maximum-packet-size-for-a-tcp-connection</a> 这里的说法，虽然一个 TCP 包理论上的最大容量有 64kb，但是实际上一般只能由 1.4~1.5kb 左右。如果 entry 的大小可以小于这个值的话，不需要发送第二个 HTTP 的 TCP 包，对传输效率有一定的好处。</p><p>在 entry 的代码里面，主要是生成了一个 iframe，然后再 iframe 里面加载真正的 bundle.js。这里的 bundle.js 的内容是编译的时候写死的。见 rollup-plugin-hash.js</p></section><section><h3>index.js</h3><p>这个是主入口文件。</p></section><section><h3>polyfill.js</h3><p>这里手动维护了一些需要用到的 polyfill 文件。async 的部分被注释掉了，因为生成的代码比较大。访客端的结果力求小，不建议用。</p></section><section><h3>gallery.js</h3><p>这里的 window.run 暴露出的解耦是给 screenshots.js 用的。它会创建一个 iterator，然后循环创建各种类型的 state。</p><p>简单来说，会先通过创建一些简单的 generator 函数，来创建各种情况下的 state。以 textButton 这个函数举例，会生成两个情况，分别是文字是 Live Chat 的文字按钮和文字是 Another Text 的文字按钮。各种 genrator 函数通过 combineAll 或者 oneOf 进行合并，可以生成各种情况下的 state。combineAll 就是对各个 genrator 函数的结果做笛卡尔乘积；oneOf 则是将各个函数的结果现行拼接在一起，如果 state 的情况是相斥的，用 oneOf，否则用 combineAll。</p><p>比如说，button 和 chat window 不会同时出现，这里的 state 之间就可以用 oneOf；比如 chat window header 的情况会根据主题色，是否有 banner 图片等条件的不同而不同，所以这些情况应该用 combineAll 来合并。</p></section><section><h3>preview.js</h3><p>这个页面是给 control panel 用的入口函数。开放了一些接口，可以用于再指定位置生成 dom tree。思路是这样的，对于不同的情况，开放接口，control panel 的页面上提供具体的数据，然后再接口里面，生成相对应的 state，然后根据 state 生成对应的 ui，并插入到指定的位置。</p><p>在 control panel 上的 js 调用接口后，大致需要做这个几件事情：通过调用方给定的数据，生成一个 state（会包含一些默认的 state 数据，见 initial 函数），创建一个简单的 reducer 函数（只做一件事情，就是接收到 update action 的时候，把 action.payload 里面的数据拿出来，合并到 state 中），用 state 和 reducer 来创建 store，然后渲染 container（不同的接口渲染不同的 container）。</p><p>对于开放的接口来说，做两件事情：首先是初始化，需要提供默认的数据以及渲染到的位置；然后，接口会返回一个 update 函数，这个函数接受一个参数，提供 params 后刷新 dom。</p><p>以 button 这个接口为例，最开始接受的参数是 container（也就是需要渲染到的位置，dom），btn （button 相关的配置），ifOnline （布尔值，确认按钮显示 online 还是 offline 的效果）。initial 函数调用的时候，会将上面给的几个参数合并成一个初始化的 state，在 initial 函数的内部，则会将这些信息和其他一些默认的字段进行合并，生成 state；同时，initial 函数返回一个 update 函数，control panel 中可以存储这个返回的函数，在界面上用户做了其他改动之后，调用这个函数，提供新的 state 数据来刷新 dom。</p></section><section><h3>type.d.ts</h3><p>这里定义了 redux state 的结构，但是并没有长时间维护，实际结构可能和 type.d.ts 的内容有区别。</p><p>如果需要获取当前的 state 结构，最好的方法是找一个 preview 的页面，然后用 window.store 拿到 redux store 的实例，然后用 getState 来获取 state 数据。（因为访客端是运行在 iframe 环境下面的，所以在 console 中运行 window.store 的时候，需要注意将运行的环境选择成 <code class=\"language-text\">comm100-iframe(about:blank)</code>）</p></section><section><h3>view.js</h3><p>这个文件是给 <code class=\"language-text\">npm run screenshots</code> 使用的，具体的说明见 screenshot.js 的地方。总体上来说，这里的接口接受 state 作为参数，然后补上一些可能需要的数据（比如，在 puppeteer 将 state 数据从 node.js 的运行环境移动到 chrome 的过程中，date 的部分被 stringify 过了，所以需要在 view.js 里面再把 date 的部分重新转化为 date），创建一个 store（这里的 store 把 dispatch 功能删掉了，这样 UI 的部分不会因为 mount 之类的事件发生变化），最后通过原本的接口把 UI 渲染出来。</p></section><section><h3>safeStorage.js</h3><p>对于没有提供 localStorage/sessionStorage 的情况，safeStorage 函数会提供一个 mock。这里需要注意的一点是：private 模式下，会启用这个 mock。但是 memoryStorage 的实现会在 window 上增加一个对象。注意这里不能把对象名字取成 localStorage 或者 sessionStorage，浏览器不允许覆盖 window.localStorage 的值。改成用 local-storage 或者其他名字就可以了。有些版本依然存在这个问题。</p></section><section><h3>component.js</h3><p>这里主要放了一些 preact 项目中可能会用到的操作 virtual dom 渲染的函数。主要可能用到的两个：</p><p>renderToContainer：访客端项目有很多需求是需要将一段 dom tree 渲染到另外一个地方（比如把 button 的部分渲染到用户指定的 div 下面）。但是，从程序上，并不希望因为这样的渲染需求，而把完整的 virtual dom tree 给拆分成几段。renderToContainer 的作用是，在指定了 context 和 container 之后，调用返回结果里的 render 函数，可以把结果渲染到之前指定的 container 下面。实际的使用主要是 Iframe.jsx 和 migration.js 这两个地方在用，后续会介绍。</p><p>shouldComponentUpdateGen：这个是一个辅助函数，会根据指定的 propKeys 和 stateKeys 来判断是否需要重新 render；在 development 模式下面，还会提供一些额外的帮助信息：如果 props 或者 state 发生了变化，但是 shouldComponentUpdate 应该返回 false，那么会在 console 中输出相关的信息。这样比较容易帮助定位问题（主要是改了 state 但是 UI 没有变化的情况）。</p></section><section><h3>subscription/api.js</h3><p>这个文件主要是为 window.Comm100API 提供 api 接口的。主要是 do, get, set, on 四个接口。同时，老版本的接口也会依然提供，但是会加上 deprecateWarning，调用的时候 console 会给出 warning。另外，老版本有一个 setPrechatFields 的接口，这个新版本没加上，可以考虑后续加上。</p><p>api 的接口需要放到 subscription 里面，主要是因为：api 会获取/赋值 redux state，同时没有特定的 UI 相关，所以 subscription 的概念比较合适一些。</p><section><h4>api 设计上的缺陷</h4><p>目前的访客端 API 有些设计并不是非常的方便，主要集中在 form 上面。大概有这么几个问题：</p><ol>\n<li>field 只能完全替换，但是不能局部修改，这个导致很多修改只能写大量代码，比较麻烦。举例来说，客户希望输入框只能输入数字，或者根据 WCAG 2.1 的要求，在输入框上加上 auto-complete=“xxx” 的字段。建议在原来 API 的基础上，提供新的 property，比如 hAttribute 或者 hProp，类似于 jsx 的设计，可以在 hProp 中提供额外的 html property 值，前台可以直接把这些值渲染到页面上。比如说</li>\n</ol><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> fields <span class=\"token operator\">=</span> Comm100API<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'livechat.prechat.fields'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nComm100API<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'livechat.prechat.fields'</span><span class=\"token punctuation\">,</span> fields<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>field <span class=\"token operator\">=></span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> field<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  hProps<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    type<span class=\"token punctuation\">:</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><ol start=\"2\">\n<li>Validation 的部分没有简单的接口设置，只能替换。举例来说，客户希望输入框只能输入某些类型的字段（比如固定格式的日期）。按目前的做法，只能把原来的 field 替换掉，然后再加上 validation。太麻烦了。可以考虑加上一个 validate 的接口，如果客户提供了函数，就将输入的字段先在这里验证一下。比如说：</li>\n</ol><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> fields <span class=\"token operator\">=</span> Comm100API<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'livechat.prechat.fields'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nComm100API<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'livechat.prechat.fields'</span><span class=\"token punctuation\">,</span> fields<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>field <span class=\"token operator\">=></span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> field<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">validate</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token regex\">/\\D/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">'Only number is allowed'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div></section></section><section><h3>subscription/ui.js</h3><p>UI 的渲染，本质上也是一个 subscription，因为是需要根据 redux store 来变化 UI，所以这个部分也是放到了 subscription 的下面。</p></section><section><h3>store/batch.js</h3><p>这个 enhancer 的需求是这样的：每一次 store.dispatch 之后，都会同步触发一次 store.subscribe 中注册过的回掉函数。如果一次用户的操作/网络返回只触发一次 store.dispatch，那么是不会有问题的。但是，一次用户的操作可能会触发不止一个 store.dispatch（这里的出发点是希望将 action 尽量的原子化，一个 action 对应一种类型的 state 变化，所以一个用户操作可能设计多个 action）。当一个操作触发多次 action 操作的时候，就会导致一个操作触发了多次的 UI 渲染。对于 react 来说，渲染是异步的，所以实际上触发的渲染可能还是只有一次。但是要注意到的是，container 依然被触发了很多次，导致计算 props 的过程有不必要的冗余。batch 的作用是，确保多次发送 action，但是只触发一次 subscription 的回调。</p><p>这里最重要的 export 是 enhancer 函数，这个 enhancer 代理了原来 store 中的 subscribe 函数。新的代理函数会记录下所有的 subscription，但是当真正的 store 触发 subscription 之后，并不一定会马上触发 subscription 函数，enhancer 会确认没有新的 action pending 的时候，才会真正触发 subscription。</p><p>计算是否有 pending action 的代码在 middleare 里面。当接收到一个 batch action 之后，会先计算处 payload 里面的 action 的总数，然后每 dispatch 一个 action，就 pendingAction 减一。（见 actions.reduce 的函数）这样，当 pendingAction 是零的时候，就知道所有的都已经发送过了，subscription 可以被真正调用了。</p><p>由于不同的 middleware 都有可能发送这种 batch action，所以需要在每一个这样可能的 middleware 的后面，都跟上一个 batch middleware。这样，batch middleware 就可以将 batch action 拆分成一个个的子 action，对于后续的 middleware 和 reducer 来说，batch action 就是不存在的，接收到的依然是每一个个原子 action。</p></section><section><h3>store/messages.js</h3><p>这个 middleware 拦截了 message 相关的 action，然后判断是否需要触发一些额外的动作，比如 api 的调用。另外，agentTyping 的消息接收到之后，10s 后删除 agentTyping，也是在这个 middleware 里处理。</p></section><section><h3>store/cobrowsing.js</h3><p>这个 middleware 会根据 store.state 中 cobrowsing 相关的数据，来处理 cobrowsing 相关的动作，包括加载 script，开启 cobrowsing 等等。</p><p>getCSS 根据主题色生成 glance UI 相关的 CSS 代码 （主要是一些 modal 层的按钮颜色，样式等），在第一次开始 cobrowsing 的时候会往页面上插入这段 css。</p><p>加载 script 的时候，会做这么几件事情：如果当前 URL 带有 cobrowseDebug 参数，那么会加载本地的一个 glance script（不建议使用，建议去掉这部分代码），否则加载 glance 的代码。加载的时候，需要一些配置，其中 groupId 是服务器给的。glance 的服务是需要写入 cookie 来记内容的。getPossibleDomain 的部分做这样的操作，程序会尝试在当前域名下写入 cookie，如果失败的话，就会去父域名上写入 cookie，只要有可以写入 cookie 的域名，就给 data-cookiedomain，这样 glance 就会尝试在这个设置的 domain 下面写 cookie；如果全部都写入失败了，就会用 data-cookietype=‘ls’ 禁用 cookie，改用 localstorage 来写数据。这里这么设计，主要是有些客户可能会用 amazon 的云服务，直接把 cookie 写到根域名下面是不行的，只能尝试在当前的子域名下面写 cookie。如果都不能写 cookie（可能是有了某些设置），也要用 localstorage 保证大概率的使用没有问题。</p><p>在 initCobrowsing 的时候，会针对 differentDomain 的部分做一些 hack。默认情况下，glance 需要用户做一些额外的配置才可以跨域（用户需要在一个简单页面上加入 glance 的代码，glance 在跳转到另外一个域名的页面之前，会先 window.open 打开这个简单页面，然后调用方指示这个简单页面在当前的域名下先写好 cookie，然后再实行真正的跳转工作。到了新的域名之后，cookie 已经在了，就可以确保跨域了。）但是这样的方案，需要用户做设置，并不是非常好。这里的代码（ln210-224）主要就是为了规避这部分的设置，直接由我们的代码来完成 cookie 的写入。首先是判断当前 cobrowsing 是不是跨域的方法：通过聊天消息判断出来当前应该是在 cobrowsing 的过程中，但是无法读取到 glance 的 cookie，这个时候就需要手动插入 cookie 的。cookie 的结构如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  ssnid<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>groupId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>sessionCode<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>callId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// groupId 和 sessionCode 服务器都是知道的</span>\n  <span class=\"token comment\">// callId 是 glance 生成的，服务器不清楚，但是本地在开始 cobrowsing 的时候，可以从 cookie 里拿到</span>\n  <span class=\"token comment\">// 这里拿到 callId 后，会存放在消息里（startCobrowse 的消息），发送给服务器（见 onSessionStart 函数）</span>\n  <span class=\"token comment\">// 这样，在页面刷新重新拿消息之后，程序就可以从 startCobrowse 中读取到当前的 callId</span>\n  <span class=\"token comment\">// 从而拼接出完整的 ssnid</span>\n  <span class=\"token constant\">R</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不清楚含义</span>\n  yb<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不清楚含义</span>\n  Od<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不清楚含义</span>\n  Fa<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'domain'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 当前的 domain 字符串</span>\n  boxstate<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不清楚含义</span>\n  expanded<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不清楚含义</span>\n<span class=\"token punctuation\">}</span></code></pre></div></section><section><h3>components/HoC/heartbeat.js</h3><p>这个 High order Component 的作用，就是根据传入的参数（参考 Heartbeat.propTypes 的定义），来调用 hCallback 这个回调函数。</p><p>在 component 的层面做 heartbeat，而不是放到 subscription 等地方，主要也是考虑到了 heartbeat 的不同情况和 UI 的展示基本是对应的。（比如 chat button 情况和 chatting 情况的 heartbeat 是不同的）。根据 Component 是否 mount 来开启和关闭 heartbeat，这样逻辑只需要写一次就可以了（既负责展示 UI，也负责调整 heartbeat）。</p><p>但是，把 heartbeat 的代码真的写道 component 里面是不妥的。因为 UI 不应该去关心 heartbat 的部分，这个和 UI 本身无关。所以这里使用了 HoC 来包裹原先的 component，赋予 UI 可以 heartbeat 的功能。</p></section><section><h3>components/HoC/language.jsx</h3><p>给 UI 加上 language 相关的 context，这样子元素可以直接拿到语言了。这里，默认需要 props 一定带有 languageTag 的属性，程序会通过这个 tag 去 constants/languages.json 里面找对应的语言包，赋值给 context。</p><p>子元素可以通过 <code class=\"language-text\">utils/helper</code> 的 getLanguages 辅助函数，从 context 中拿到 languages</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> languages <span class=\"token operator\">=</span> <span class=\"token function\">getLanguages</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>languages<span class=\"token punctuation\">.</span>xxx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// constatns/languages.json 中，languageTag （比如 en）下面，xxx 字段的语言翻译</span></code></pre></div></section><section><h3>components/HoC/loading.js</h3><p>类似于 React.Suspense，在 loadFn 没有加载完成前，显示 loading 的组件，加载完成后显示原始组件。如果加载失败就什么都不显示。</p></section><section><h3>components/HoC/migration.js</h3><p>这个 HoC 的作用，是将指定的元素渲染到指定的 container 下面，而不是当前的 dom tree 下。这个主要是给 button 服务的。因为聊天按钮需要渲染到客户指定的元素下面。</p><p>注意，对于这种没有实际含义的组件，render 函数需要 <code class=\"language-text\">return &lt;div /&gt;</code> 而不是 <code class=\"language-text\">render null</code> 或者 <code class=\"language-text\">render true</code> 之类的。这个是为了解决在 IE 里的一个问题。preact 会默认把 component 的渲染信息放到当前渲染好的 dom 组件上。对于 null 或者 true 之类的来说，preact 会默认渲染一个 emptytextnode。IE 做了一个错误的优化，回把 emtpytextnode 上赋值的元素 gc 掉，这会导致一定时间之后，preact 重新渲染元素的时候，无法知道上一次渲染的信息，导致渲染错误。</p></section><section><h3>components/HoC/validation.js</h3><p>preact 本身不检查 proptypes。这个 HoC 可以在 render 的时候检查 props 的信息，给出 warning，然后正常的渲染出组件。</p></section><section><h3>components/HoC/render.js</h3><p>这里公开的 API 分成两个部分，一个是 RenderProvider 组件，用于在 context 中注册一个 getRender 的函数。getRender 函数是从 subscription/api 里面拿出来的（见 Root.jsx 的代码）。注册好了之后，子元素就可以直接从 context 里面拿到 getRender 函数，直接调用使用了。</p><p>第二个部分是 render 或者 renderWindow 的 API。这两个 High order Component 的功能是类似的。以 render 函数为例，name 和 key 两个参数，name 是对应的 api 的名字，key 是 props 对应的 key，传递给 api 调用。调用完成后，如果返回了 element（ln 16-20），就用 api 指定的元素，否则使用自己的元素（这里的行为可以参考 Comm100API.render api 的行为定义）。renderWindow 的 api 也是类似的，区别在于，renderWindow 需要根据 window tab 的不同，调用不同的 api。</p></section><section><h3>components/Window/WindowBase.jsx</h3><p>访客端有三种窗口类型，Bubble / Circle / Classic。这里的设计是这样的：大部分 window 相关的逻辑都是一致的，都写在了 WindowBase 里面。但是三种类型的窗口可能会有一些行为上的不同，比如窗口大小之类的。所以这个目录下面有三个文件，分别是 BubbleWindow.jsx / CircleWindow.jsx / ClassicWindow.jsx，三个文件都定义了各自的组件。和一般的组件不太一样，这三个组件是 extends Window 而不是一般的 extends Component。然后只覆盖基类上需要修改的几个函数，比如 setWinSize / getWinStyle / getSideWinStyle 等。以此实现不同窗口的行为不同。</p><p>但是从实践下来的效果看，感觉上这里的设计并不是非常的好。可能还不如直接使用 High Order Component 来的方便。另外，这里的几个文件都太大了，可以考虑做拆分。</p></section><section><h3>components/functionality</h3><p>这里下面的几个文件，都是一些功能性的 components，本身不渲染什么内容，但是会设定一些额外的 side effects，比如 flash title 是闪烁 tab 的 title 字段，googleanalytics 是触发 ga 事件，head 是用来在 head 标签中插入一些标签，style 则是在 head 中插入样式。</p><p>注意：render 一定要返回 <code class=\"language-text\">&lt;div /&gt;</code>，解释见 HoC/migration.js 的部分。</p></section></section></section>\n<section><h1>create new repo</h1><p>如果是需要创建大项目下面的小项目，比如 AgentConsole 下面创建一个 draft-js 的子项目：</p><ol>\n<li>访问 <a href=\"http://192.168.3.200:8080/tfs/DefaultCollection/_git/AgentConsole\">http://192.168.3.200:8080/tfs/DefaultCollection/_git/AgentConsole</a></li>\n<li>点击中间上部 AgentConsole 下拉菜单，选择 Manage repositories…</li>\n<li>点击左侧上部的 New repository…</li>\n<li>输入名字，比如 immutable</li>\n<li>访问 <a href=\"http://192.168.3.200:8080/tfs/DefaultCollection/AgentCosnole/_git/immutable\">http://192.168.3.200:8080/tfs/DefaultCollection/AgentCosnole/_git/immutable</a> 可以看到新的 repo 页面</li>\n<li>git 地址也是 <a href=\"http://192.168.3.200:8080/tfs/DefaultCollection/AgentConsole/_git/immutable\">http://192.168.3.200:8080/tfs/DefaultCollection/AgentConsole/_git/immutable</a></li>\n</ol><p>如果是需要创建一个大项目：</p><ol>\n<li>打开 Visual Studio</li>\n<li>找到 Team Explorer 的（右侧）栏</li>\n<li>在栏顶部的下拉菜单处，点击，选择 Projects and My Teams 的子菜单，选择 New Team Project…</li>\n<li>输入名字，下一步选择模板（随便选），下一步 version control 选择 git （或者默认的 tfs），完成创建</li>\n</ol></section>\n<section><h1>npm server</h1><p>服务器在 192.168.2.38 上，登陆可以使用 stanley/Aa000000。</p><p>服务器开放了四个端口，分别是 7001/7002，8001/8002。其中，8001/8002 对应的是一个 private npm server，上面存放了所有内部 npm 包；7001/7002 对应的是一个从外网环境同步来的 npm server，包含了所有需要用到的 public npm 包。</p><p>这里之所以需要同时设置 7001 和 8001 两个服务器，主要是出于以下考虑：因为需要从外网环境同步 npm 到内网，所以这个服务器的数据库经常需要被覆盖。如果 private npm package 也放在这个数据库下面的话，一旦做了一次外网同步，这些 private package 就被覆盖掉，消失了。同时，外网同步的数据库也没有办法自带内网的这些 private package（因为代码不能拷出来）。权衡之下，就做了这样分开的设计。8001 这个服务器只包含 private package，而且不会在同步的时候被覆盖；7001 随时可能被外网数据覆盖，但是覆盖了没有关系，不会有核心数据丢失。</p><p>内部开发环境同步 npm 数据的流程：</p><ol>\n<li>首先，如果是第一次做外网的同步，需要先有一份和内网同步的数据库。最简单的办法是从 192.168.2.38 上把数据库拷贝到外网环境（因为不涉及内部的代码，所以拷贝应该是可以被允许的）。数据库的位置在：C:\\registry.cnpmjs.org\\data.sqlite</li>\n<li>在外网安装好 cnpmjs.org 这个 npm 包，同时放置好数据库（假设数据库放在 D:\\work\\registry 下面）</li>\n<li>运行 <code class=\"language-text\">$env:HOME=&quot;D:\\work\\registry&quot;</code> 配置数据库地址</li>\n<li>运行 <code class=\"language-text\">cnpmjs.org.cmd start</code> 开启服务器</li>\n<li>服务起来之后，cnpmjs 会去查找有没有包要更新；如果还需要添加新的库，可以访问 localhost:7002 这个页面，搜索需要同步的包，如果搜索结果显示不再数据库里面，就点击 sync 开始同步。（因为除了库之外还会下载所有的 dependencies，所以大的库可能要比较长的时间）</li>\n<li>等到所有都同步完成后（如果是添加新包，页面会显示有没有下载完成；如果是同步，可以通过数据库文件的更新时间来简单判断，是否更新告一段落），将新的数据拷贝到内网环境，可以参考的命令行代码：</li>\n</ol><div class=\"gatsby-highlight\" data-language=\"powershell\"><pre class=\"language-powershell\"><code class=\"language-powershell\">robocopy <span class=\"token punctuation\">.</span>\\<span class=\"token punctuation\">.</span>cnpmjs<span class=\"token punctuation\">.</span>org\\ <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>new <span class=\"token operator\">*</span> <span class=\"token operator\">/</span>MAXAGE:20190412 <span class=\"token operator\">/</span>s <span class=\"token operator\">/</span>W:0<span class=\"token punctuation\">;</span> 7z a <span class=\"token operator\">-</span>tzip new<span class=\"token operator\">-</span>$<span class=\"token punctuation\">(</span><span class=\"token function\">get-date</span> <span class=\"token operator\">-</span>f yyyyMMdd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>zip new</code></pre></div><p>这里的 MAXAGE 设置了上一次同步的时间，这个时间点之后的所有新文件都会被打包</p><ol start=\"7\">\n<li>将打包好的内容通过 FTP 传输到内网，放到 192.168.2.38 上。（如果在 18 先解压缩，再复制到 38 上，data.sqlite 可能会复制失败，原因不清楚。但是放到 38 上再解压缩不会有问题）</li>\n</ol><p>7001 这个服务器，开启之后，数据库会一直增加（应该是 8001 这个服务器在一直同步或者什么的导致的）。这会导致一段时间之后，38 电脑的硬盘就满了。暂时是这么做处理的：</p><ol>\n<li>在覆盖新的 data.sqlite 之后，会多拷贝一份 data - Copy.sqlite 文件</li>\n<li>一旦发现硬盘不够了，就停掉 8001 的服务器，然后把 data.sqlite 彻底删除，用 data - Copy.sqlite 复制一份成为新的 data.sqlite</li>\n</ol><p>启动服务器的方法：</p><ol>\n<li>7001：<code class=\"language-text\">C:\\Users\\Stanley\\AppData\\Roaming\\npm\\cnpmjs.org.cmd start</code></li>\n<li>8001：<code class=\"language-text\">C:\\Users\\Stanley\\AppData\\Roaming\\npm\\cnpmjs.internal.org.cmd start --scopes comm100</code></li>\n</ol><p>这里其实都是 cnpmjs.org 这个包，但是复制了一份，修改了一些配置，形成了 cnpmjs.internal.org 这个包（C:\\Users\\Stanley\\AppData\\Roaming\\npm\\node_modules 里面可以看到）。主要就是修改了 config/index.js 里面的内容。可以大概比对一下查看区别。主要的修改点，包括 dataDir 的位置写死了 C:\\internal，服务器端口（registryHost / registryPort / webPort / bindingHost），上游服务器（sourceNpmRegistry，handleSyncRegistry，syncChangeStream），syncModel（不 sync，none）。</p><p>服务器数据的位置</p><ol>\n<li>7001：数据存放在 C:\\registry.cnpmjs.org 下面（第一次运行需要 <code class=\"language-text\">$env:HOME=&quot;C:\\registry&quot;</code>）</li>\n<li>8001：数据存放在 C:\\internal 下面（写死在 cnpmjs.internal.org/config/index.js 里面的）</li>\n</ol><p>目录的意义：</p><ol>\n<li>downloads：这个没特别用处，是外部同步的时候，存放正在下载的文件用的，可能有很多 0byte 的下载失败的文件在里面</li>\n<li>logs：日志存放处</li>\n<li>nfs：这里存放了所有的 npm package 的包</li>\n</ol><p>如果有人 yarn install 下载某个包失败了怎么办：</p><ol>\n<li>先看看 nfs 目录下面，能不能找到这个包，如果不能，需要外网同步</li>\n<li>如果可以找到，但是 yarn install 一直报错（比如 TIMEOUT 或者 RESET 或者 500 什么的），可以直接让开发人员手动下载这个包的压缩文件，比如 <a href=\"http://192.168.2.38:7001/find-with-regex/download/find-with-regex-1.1.3.tgz%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8A%8A%E8%BF%99%E4%B8%AA%E4%B8%8B%E8%BD%BD%E5%A5%BD%E7%9A%84%E5%8C%85%EF%BC%8C%E6%94%BE%E5%88%B0\">http://192.168.2.38:7001/find-with-regex/download/find-with-regex-1.1.3.tgz，然后把这个下载好的包，放到</a> C:\\npm-packages-offline-cache 下面，放好了之后，在安装一次应该就可以了。yarn 会优先从 offline cache 里面读取已经有的包，就不走服务器了。（不同开发环境，offline cache 的位置可能不一样）</li>\n</ol><p>如何发布一个内网包：</p><ol>\n<li>先在 tfs 里面保存一个 git 的库，备份</li>\n<li>修改 package.json 里面的内容：name 需要是 @comm100 开头，比如 <code class=\"language-text\">@comm100/draft-js</code>；version 记得更新</li>\n<li>如果是第一次，需要登陆：</li>\n</ol><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> login</code></pre></div><p>username: stanley\npassword: LaySent. （忘了怎么改密码了，暂时就先凑活着用了）\nemail: stanley@comm100.com</p><p>登陆后可以通过 <code class=\"language-text\">npm whoami</code> 查看是不是。另外，要看一下登陆后的结果，是不是连接到了 8001 这个服务器（而不是 7001）。</p><ol start=\"4\">\n<li>登陆完成后，<code class=\"language-text\">npm publish</code> 就可以发布了。</li>\n</ol><section><h2>Draft-js</h2><p>git 位置：<a href=\"http://192.168.3.200:8080/tfs/DefaultCollection/AgentConsole/_git/draft-js\">http://192.168.3.200:8080/tfs/DefaultCollection/AgentConsole/_git/draft-js</a></p><p>这个版本的 draft-js 大致是基于 <a href=\"https://github.com/facebook/draft-js/commit/800d6b5888ab3fe4a1fcdb9c12f1942bca6c3972\">800d6b5888ab3fe4a1fcdb9c12f1942bca6c3972</a> 这个 commit 创建的内部版本。</p><p>主要修复了两个问题：</p><ol>\n<li>客户报的 Drag-n-Drop 的问题</li>\n<li>IE 上 selection 的问题</li>\n</ol><p>第一个问题见 <a href=\"https://github.com/facebook/draft-js/pull/1725\">#1725</a></p><p>第二个问题可能出现在 IE 上，具体的原因暂时不清楚。在某些情况下，会出现 IndexSizeError。Andy 做了一个修复，对 index 做了检查。（见内部 repo 上的 a28545cfbddd7b86ef3c7c1452b37f17c3b2b377）</p><p>其中，第一个问题在线上的版本已经发布了；第二个问题 Social 会发布一个版本修复（这个问题最初发现是在 Social 的版本上），但是 Agent Console 的 Draft-js 由于测试范围的缘故暂时不做发布。下一次发布 agent console 版本的时候，需要将 draft-js 的版本号升级到 0.10.5-1，简单测试一下看基本的功能是否收到影响。</p><p>TODO：在下一个版本升级 agent console 的 draft-js</p></section><section><h2>Immutable-js</h2><p>这个版本是 3.7.6 版本的 Immutable-js。修改了 dist/immutable.d.ts 文件，把所有 map/each/filter 等回调的函数签名从 <code class=\"language-text\">(key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;)</code> 改成了 <code class=\"language-text\">(key: K, value: V, iter: Iterable.Keyed&lt;K, V&gt;)</code>。原来的签名将参数设置为 optional 的，在实际调用的时候就必须判断参数不是 undefined，否则 ESLint 会给出 error。实际上这里的参数应该不会是 undefined，所以就把签名的 optional 给去掉了。避免了不必要的 undefined 判断。</p><p>实际的功能并没有修改。</p><p>TODO：immutable-js 的版本之所以是 3.7.6，是因为 draft-js 的版本需要这个。注意到 draft-js 实际引用的是 immutable-js，而不是 @comm100/draft-js。所以在 agent console 安装的时候，可能会出现 immutable-js 和 @comm100/immutable-js 两个 package。因为 immutable-js 的存在，typescript 签名依然可能会是错误的（immutable-js 覆盖了 @comm100/immutable-js），需要手动删除 node_modules/immutable-js 的目录。应该把 @comm100/draft-js 中的依赖从 immutable-js 改成 @comm100/immutable-js。（agent console 里设置了 alias，所以引用是 immutable-js，但是实际使用的会是 @comm100/immutable-js）</p></section></section>\n<section><h1>编译桌面版壳</h1><p>由于 Mac 的安装包只能在 Mac 的电脑上进行编译，所以桌面版壳的安装只能在 Mac Mini 上进行。Mac Mini 需要用 build user 登陆（密码可以询问 Allon）</p><p>Mac 里有两个编译的文件夹，一个是 agent-console-win 一个是 agent-console-mac。两个的代码是一样的，但是在 app/node<em>modules 里面的代码有所不同。agent-console-win 的目录下面的内容是从 windows 电脑上直接拷贝过去的，主要是 idletime 和 spellchecker 这两个库，用的是 Windows 32 的编译结果。mac 文件夹下面的 app/node</em>modules 里面没有这两个的编译结果，mac 电脑上可以直接编译出二进制包。</p><p>在编译 win 版本的时候，需要用 npm run pack — -w 命令，来指明编译 windows 版本。这样程序会跳过二进制的重新编译；mac 文件加下面编译的时候，直接 npm run pack 就可以了。二进制包可以重新编译。如果 windows 版本编译忘了 -w，需要从 windows 电脑下重新拷贝一份 node<em>modules 放到 app 下面。（mac 电脑上好像有一个 node</em>modules.zip 放的就是这个备份，可以找一下）。</p><p>Windows 的版本，注意要编译 32 位的（编译配置里面应该已经加上了），不然电脑是 64 位的，编译出 64 的二进制，在 32 位上无法运行。</p><section><h2>app/business</h2><section><h3>app/business/AutoLaunchManager</h3><p>看上去已经废弃不用了</p></section><section><h3>app/business/ChannelCenter</h3><p>这里定义了和 render 层通信交互的代码。render 层监听和发送消息的代码分散在各个文件中，比如说 subscription/channelCenter.js</p></section><section><h3>app/business/configManager</h3><p>这个是处理 config.json 文件的模块。默认的配置 config.json 是打包在安装包里面的。但是实际使用的 config.json 是写在 userData/config.json 下面的（ln 12）。可以把 config.json 在安装包里的内容视为默认配置，写在 userData 下的 config.json 是用户可以修改的配置。</p><p>允许用户对配置进行修改，但是如果 isDedicated 的配置是不一样的，会强制使用默认配置（ln 29）。具体的原因参考注释说明。render 层中，使用 outsider.electron.js 里面的接口 call 和 on 来对应调用。</p><p>这里的设置不一定非常合理。可以考虑直接使用 remote.require(‘xxx’) 这样的方式直接在 render 层调用 main 线程上的内容。</p></section><section><h3>app/business/controller</h3><p>controller 里面，提供一个 register 的接口，可以注册模块。然后通过 apply 或者 on 两种消息来调用对应的接口或是注册事件的回调。</p></section><section><h3>app/business/idleManager</h3><p>封装了 @paulcbetts/system-idle-time 的模块</p></section><section><h3>app/business/NotifyManager</h3><p>andy 比较清楚，应该是桌面版弹出提醒的封装模块</p></section><section><h3>app/business/reloader</h3><p>桌面版实际加载的是 HTTPs 服务器上的页面，这就存在加载失败的可能性。reloader 这个模块的意义，是尝试加载可能的入口文件（主服务器上的 index.html 和副服务器上的 index.html），如果每一个加载都失败了（did-fail-load 事件），就会加载本地的 oops.html 文件（ln 46）</p></section><section><h3>app/business/storage</h3><p>看上去没有用了</p></section><section><h3>app/business/TrayManager</h3><p>桌面版的托盘功能，andy 比较清楚。</p></section></section><section><h2>app/dict</h2><p>这里存放了所有的字典数据，用于桌面版的 spellcheck。目录的格式是：语言缩写作为目录名，index.aff / index.dic / index.js 作为主要的数据。具体使用字典的位置在 src/subscriptions/contextMenu.js 里面（ln 245 设置字典路径）</p><p>桌面版的字典，使用了 spellchecker 这个 npm 库来处理，需要的字典是 hunspell 支持的字典。<a href=\"https://github.com/wooorm/dictionaries\">这里</a>可以找到一份完整的字典列表。目前在桌面版里面只打包了部分字典。没有打包所有上面列出的字典，主要是出于 license 的考虑，有些 license 是 gpl 的，使用的话需要我们的产品开源，这个暂时不被允许。</p></section><section><h2>app/enums</h2><p>一些用到的枚举值。</p><p>在 agent console 的渲染层或访客端项目里面，要求枚举值分散写在各个文件里面，然后每个枚举值通过 export 的方式逐一开放出来，而不是通过 export 一个对象，然后用里面的字段来作为枚举值。这样设置的意义，在于 es6 的 export 是静态的，拥有 tree shake 的编译器可以更好的处理这些数据，方便之后的压缩工具把变量名压缩掉。（压缩工具无法压缩对象中的字段名，因为 js 是一个动态语言，压缩字段名会造成引用地方的问题）</p><p>但是在桌面版的地方，其实不需要像现在这样写在几个文件里面。写在一个文件里面，然后公开出来对最终的结果影响不大。</p><div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  enum1<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    key1<span class=\"token punctuation\">:</span> <span class=\"token string\">'key1'</span><span class=\"token punctuation\">,</span>\n    key2<span class=\"token punctuation\">:</span> <span class=\"token string\">'key2'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  enum2<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    key1<span class=\"token punctuation\">:</span> <span class=\"token string\">'key1'</span><span class=\"token punctuation\">,</span>\n    key2<span class=\"token punctuation\">:</span> <span class=\"token string\">'key2'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div></section><section><h2>app/icons</h2><p>这里面存放了各种图标。前面的前缀表示具体用到的品牌名称，后面的 @2x @3x 表示图标的大小。</p><p>icon 使用的位置在 utils/helper.js 里的 getIconByType 函数里，调用这个函数的位置参考 business/TrayManager.js 里的 ln 31。其中，品牌名称的字段是从 config.json 里面读出来的，字段名称是 prefix。</p></section><section><h2>app/notificationUI</h2><p>这里存放的是桌面版通知用到的 UI，使用的位置在 helper/notifyProcess.js 里面。andy 比较清楚细节。</p></section><section><h2>app/react-dev-tools</h2><p>这里放的是一个老版本的 react dev tools，在 app/index.js ln 162 有注释掉的载入 devtool 的代码。去掉注释，electron 就可以加载这部分的内容，在调试的时候可以使用 react 的调试工具。</p></section><section><h2>app/utils</h2><p>helper.js 主要是获取图标数据用的。notifyProcess.js 主要是展示桌面版通知用的。</p></section><section><h2>app</h2><p>index.js 是入口文件，这个文件需要通过 build/webpack.electron.config.js 编译成 main.js 才能被使用。（index.js 不会被打包，main.js 会被打包到最终的安装文件里面去）</p><p>config-server.html 这个页面是给配置服务器地址时候展示用的。config-server.html 是调试用的页面，真正打包时候使用的是 comm100.config-server.html 或其他带有品牌前缀的对应文件。</p><p>config.json 里面记录了和当前桌面版行为相关的配置。这个文件是调试时候用的，真正的配置信息写在 branding/config.yaml 对应 branding 的 app 下面，具体可以参考那里的说明信息。</p><p>oops.html 这个页面会在入口文件无法正常载入的时候，显示。显示的逻辑在 business/reloader.js 里面。（当主入口和副入口都加载失败的时候，显示本地的 oops 文件）。同样，这个文件是给调试用的，真正打包的文件会带有 branding 的前缀。</p><p>package.json 主要是定义了入口文件和需要用到的 dependencies。electron 在打包的时候需要用到。</p></section></section>\n<section><h1>branding</h1><p>这里主要存放了一些静态文件，其中 icon 和 manifest.json 是给 service worker 使用的。其他一些文件是给桌面版安装包等途径使用的。这些文件是否是作为静态文件直接给渲染层使用，可以在 branding/config.yaml 里面的 assets 中定义。</p><p>config.yaml 这个文件存放了 branding 相关的所有配置，写法和访客端略有不同。比如，这里是存放了一个数组，通过 name 字段的不同来区分各个 branding 的配置。但总体上来说，和访客端的配置是基本类似的思路。有些注释略有偏差，比如 assets 这个数组里面的内容不一定需要有 branding 的前缀，没有的话就认为所有的品牌都需要，比如 jQuery 或者 tinymce。</p></section>\n<section><h1>build/font</h1><p>参考访客端关于 build/font 的说明即可，基本是一致的。</p><p>TODO：注意，这里在 version-x 的项目中，ln 5 folder 的值可能需要调整，因为存放字体的 svg 图标的位置变化了。另外，鉴于不需要支持 IE10 及以下的浏览器了，其实直接使用 svg 比用 font 的方案更加方便。这个可以在 version-x 中修改。</p></section>\n<section><h1>build/plugins/AssetsSyncPlugin</h1><p>webpack plugin，作用是在编译结束之后，将编译好的静态资源拷贝到指定的目录下。</p><p>TODO：这里需要看一下 webpack.dll.config.js 里面，dll 的编译是否还生成 map 文件，如果不生成的话，这个 plugin 里面拷贝 map 文件的代码需要删除。</p><p>这里，dll 从 manifest 文件找到具体生成文件的方法：先读取 react-manifest.min.json 文件（这个文件的名字是固定的），找到其中的 name 字段，把下划线改成点，就能找到对应的文件了（在 webpack.dll.config.js 里面，<code class=\"language-text\">[name]_[chunkhash:5]</code> 是 library 的名字，最终生成的 filename 是 <code class=\"language-text\">dll.[name].[chunkhash:5].min.js</code>。</p></section>\n<section><h1>build/plugins/babel-plugin-enrich-examples</h1><p>这个功能在 version-x 中应该已经被删除了。作用是，从 Component 上的 examples 内读取数据，然后生成 componnet 相关的 demo。</p><p>建议不再维护了，改成用 storybook 处理就好了。</p></section>\n<section><h1>build/plugins/babel-plugin-remove-examples</h1><p>这个 babel plugin 可以删除写在 component 上的 example 数据，类似于删除 propTypes 的内容。</p><div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// before</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Component</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\nComponent<span class=\"token punctuation\">.</span>examples <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div><div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// after</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Component</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span></code></pre></div></section>\n<section><h1>build/plugins/CssVariableInjectPlugin</h1><p>不同的 branding 对样式有不同的处理，这个 webpack plugin 的作用是，根据 branding 的值，给 css variable 赋值正确的数据。在编译的过程中，比如 Button.css 中的 <code class=\"language-text\">--dark-color</code> 等值是没有具体赋值的，所以 postcss 没有办法给这些值具体的数据，会保留 <code class=\"language-text\">var(---dark-color)</code> 这样的数据。这些值会在这个 plugin 里面，被再一次 postcss 处理，然后用和 branding 对应的值替换掉。</p></section>\n<section><h1>build/plugins/DynamicRequire</h1><p>这个 plugin 应该并没有在使用了，试验性质的 plugin。具体作用是根据指定的 option，修改原有的 require 行为。比如，根据 branding 信息，require 不同的文件。</p></section>\n<section><h1>build/plugins/gitStatusChecker</h1><p>这个 plugin 被 Damon 注释掉了代码，但是应该是需要继续使用的。</p><p>这个 plugin 的作用，是检查当前 git 有没有没有签入的内容，如果有的话，就报错。目的是，防止有人本地编译发布包，但是代码没有签入到库里。没有签入就编译发布包，会导致一旦出现问题，就无法找到实际编译的版本了。</p><p>TODO: 继续使用这里的检查</p></section>\n<section><h1>build/plugins/isStatelesComponent</h1><p>在 babel-plugin-remove 中用到的依赖</p></section>\n<section><h1>build/plugins/ShellExecutePlugin</h1><p>webpack plugin，作用是在编译开始前和结束后执行指定的命令行脚本。注意，在 cmd 和 powershell 或者 mac 中，命令行脚本的语法是不太一样的。</p><p>TODO：这个 plugin 已经不建议使用了，主要是不同的环境下，需要的语法不一样。建议至少改成用 node.js 的脚本处理，或者直接用类似 AssetsSyncPlugin 这样的方案。</p></section>\n<section><h1>build/plugins/ThemeReplacePlugin</h1><p>和 DynamicRequire 的思路差不多，也是一个修改 require 默认行为的 webpack plugin，可以为不同的情况提供不同的 css 样式文件。暂时没有在使用。</p></section>\n<section><h1>build/agent-console.ejs</h1><p>这里存放的是最终编译成 agentconsole.aspx 代码的模板文件，是给 web 版使用的。</p><p>因为 .aspx 不是最终的 HTML，所以编译出来的 aspx 文件，实际上也是另一个模板文件，会有部分 <code class=\"language-text\">&lt;%@ &gt;</code> 这样的代码。</p><p>.ejs 使用的模板语法是 ejs，如果需要最终编译出来的效果依然有 <code class=\"language-text\">&lt;%@ &gt;</code> 这样的语法，可以这么写：<code class=\"language-text\">&lt;%= &#39;&lt;%@&#39; %&gt;</code></p></section>\n<section><h1>build/branding.js</h1><p>npm run build:branding 背后的脚本。</p><p>主要做了这么几件事情：</p><ol>\n<li>把 branding/config.yaml 编译程 branding.json</li>\n<li>将一些图片资源直接编译成 base64 的字符串</li>\n<li>根据 branding 品牌名称，创建 app/config.json 和 app/package.json</li>\n</ol></section>\n<section><h1>build/clean.js</h1><p>编译版本之前，用这个脚本删除上一次编译产生的编译结果。</p><p>因为每次文件名的 hash 值可能不同，编译结果不会简单覆盖。上一次编译结果不删除，会导致很多多余的文件。</p></section>\n<section><h1>build/cobrowsing.ejs</h1><p>编译生成 cobrowsing.html 页面，在弹出 cobrowsing 的时候，会使用这个页面。（编译在 webpack.config.js 中使用 HTMLWebpackPlugin 完成）</p></section>\n<section><h1>build/config-server.ejs</h1><p>编译生成 config-server.html 页面，用在桌面版独立部署版本中，用于让客户填写服务器地址。编译在 webpack.electron.config.js 中使用 HTMLWebpackPlugin 完成。</p></section>\n<section><h1>build/deploy.js</h1><p>编译完成后的整理，打包过程在这个脚本中完成。编译结果最后放到哪个目标目录定义在 config.yaml 中，deploy.js 文件根据这个配置，将文件进行复制。同时，会根据文件的 branding 前缀来选择合适的文件复制（复制后去掉前缀）。</p><p>完成的结果放在 deploy 文件夹中。</p></section>\n<section><h1>build/dmg-background.png</h1><p>Mac 的安装包需要用到的图片。在 electron.build.js 中使用。</p><p>这个文件应该不是实际使用的。在 config.yaml 中，electron 下面定义了 dmg 使用的图片的位置，是 branding 下面，带 branding 前缀的具体图片。</p></section>\n<section><h1>build/electron.build.js</h1><p>根据 branding 的数据，一个一个的编译安装包。编译的过程中，会根据文件名的 branding 前缀，选择合适的文件，打包到安装包中。</p><p>buildConfig 中列举了大部分的 electron 安装包打包的配置：</p><ul>\n<li>asarUnpack：在打包 asar 的时候，dict 包不放到 asar 中。最终 dict 会出现在 app.asar.unpacked 目录下面。（这样，在 spellchecker 切换字典的时候，就可以直接引用到具体的字典文件了。使用的位置见 src/subscrpitons/contextMenu.js）</li>\n<li>dmg：这里定义了 mac 安装包的一些配置。在 mac 安装完成后，会显示 dmg-background.png，然后再 165x200 的位置显示安装后的文件，在 391x200 的位置显示 Applications 这个目录。背景 dmg-background.png 图片会提示用户，将安装后的文件拖动到 Applications 目录。这里其他还定义了整个窗口的大小（和图片大小匹配）</li>\n<li>files：这里定义了所有需要打包的文件</li>\n<li>extraFiles：会把目录下面的 credit.html 文件打包到 app 的安装的根目录下面（TODO：credits.html 这个页面在打包的过程中好像漏掉了，需要补上去）</li>\n<li>publish：因为是发布到自己的服务器上的，这里就用了 generic 就可以了</li>\n<li>compression：极值压缩</li>\n<li>forceCodeSigning：不需要强制签名。这样 windows 上也可以打包给测试。签名暂时只能在 mac 上进行（因为 mac 的安装包只能用 mac 打包）</li>\n<li>win：windows 安装包使用 nsis</li>\n<li>nsis：nsis 的安装包，点击就安装，不需要用户配置（oneClick: true）；同时，删除的时候会删除掉 require(‘electron’).app.getAppPath() 下面的内容（比如用户配置的 config.json 文件）；注意，因为使用了 oneClick，所以不会安装给所有用户，只会安装给当前用户，因而安装过程也不需要管理员权限。</li>\n<li>mac：主要是配置了安装结果的类型</li>\n</ul></section>\n<section><h1>build/icon.icns / icon.ico</h1><p>安装包需要用到的 icon，icns 是 mac 用的，ico 是 windows 用的。</p><p>但这些个文件应该不是实际使用的。在 config.yaml 中，electron 下面定义了具体使用的 icon 的位置，是 branding 下面，带 branding 前缀的具体 icon。</p></section>\n<section><h1>build/index.ejs</h1><p>这里存放的是最终编译成 index.html 代码的模板文件，是给桌面版渲染层使用的。</p><p>agent-console.ejs 和 index.ejs 主要有这么几点不同：</p><ol>\n<li>agent-console.ejs 增加了 browserVersionNote 的部分，这部分是给不支持的浏览器访问时候显示用的。桌面版是基于固定版本 Chromium 的，没有这个问题。检查浏览器版本用到了 livechat/js/agentconsole.js 这个文件，不在 agentconsole 的项目里面</li>\n<li>mainRouteServerUrl / backupRouteServerUrl / portalLivechatUrl / forgotPassword 这几个值在 web 版本里是通过服务器指定的；在桌面版是编译 index.html 的时候直接写死的</li>\n<li>getForceLogin / getSiteId / getAgentId / getToken / getAgentEmail 这几个函数，在 web 版会返回服务器指定的数据；在桌面版返回空的数据。</li>\n<li>index.ejs 中加入了判断最低版本桌面版的功能（ln 33-40）。这里目前写的是，要求最低桌面版版本是 8.0.0，如果低于这个版本，就会自动跳转到本地的 upgrade.html 页面要求强制升级。这里的桌面版版本是 app/package.json 中的版本，也就是桌面版二进制包的版本，而不是渲染层的版本。</li>\n</ol><p>TODO 考虑把 js/agentconsole.js 这个文件也包含到 agent-console 的项目中去</p></section>\n<section><h1>build/license.ejs</h1><p>生成 credit.html 页面需要用到的模板文件。配合 licenses-generator.js 可以生成 credit.html 页面。</p></section>\n<section><h1>build/licenses-generator.js</h1><p>根据安装的包，去创建 credit.html 文件。因为需要用到网络，所以内网环境可能无法正确生成全部内容。</p><p>TODO 水星项目升级了很多的包，这个 credit.html 需要更新一下\nTODO 把这个加入到 release 的流程中去，保证 credit.html 可以同步</p></section>\n<section><h1>build/oops.ejs</h1><p>当桌面版无法连接上入口文件的时候，显示 oops.html 页面，模板文件是这个。编译在 webpack.electron.config.js 中使用 HTMLWebpackPlugin 完成。 </p></section>\n<section><h1>build/portAssigner.js</h1><p>由于开发机只有一台，多人需要共用开发端口。这个文件主要作用是根据用户的名称分配不一样的端口号区段。</p></section>\n<section><h1>build/render.js</h1><p>这个文件会以 src/render.js 为入口文件，编译一个渲染的代码。编译的结果代码会公开一个 <code class=\"language-text\">var html</code> 的变量，值是渲染后的字符串。编译完成后，<code class=\"language-text\">eval(js)</code> 就可以得到这个 html 变量（<code class=\"language-text\">html.default</code>，见 ln 89）</p><p>最终生成的 html 和 css 部分，会存放在 output.json 文件中，在编译桌面版或 web 版渲染层的时候，会读取这里的结果，填充 .aspx 或 .html 的内容。有了这部分的 html 和 css，即使 js 和 css 都还没有下载完成，页面依然可以大致正确的显示（inline css 的资源文件引用路径不正确，所以有些内容不能完全显示）</p><p>这个方案有几个问题：</p><ol>\n<li>资源文件的引用地址需要修改，css 是放在 agent-console 目录下面的，而 inline css 是在页面上的，两者的位置不同，所以引用资源文件的路径也需要不同，很容易错</li>\n<li>render.js 中的 jsx 结构和 root.jsx 中的结构是不太一样的，react 在动态生成结果之后，只能替换掉原来的内容</li>\n<li>因为需要替换掉内容，所以如果在 css/js 下载完成之前，用户就填写了内容，那么 react 开始工作后，会把这部分内容删掉</li>\n</ol><p>总体上来说，这不是一个非常好的方案。更合适的做法是，起始屏使用一个和真实内容不相关的 UI（比如一个 comm100 logo 作为起始屏）。这样，不涉及可以交互的元素，react 运行后直接替换也没有关系；同时，这部分 UI 不需要借助 ssr 就可以直接得到，编译时间也可以压缩。计划在 version-x 中加入。</p><p>TODO：这里的 CSS，引用资源文件（字体/图片）的位置是不正确的。在真正的 CSS 加载完成前，页面的字体/图片显示不正确。（因为 css 是放在 agent-console 文件夹下面的，但是在页面上的 inline css 是在 agentconsole.aspx 下面的，两者的相对位置不一样）\nTODO：src/render.js 中的 UI 和实际是不太一样的，最终 react 会需要用动态生成的 html 去替换掉 ssr 的内容。可以想办法把 ssr 的内容和 react 动态生成的内容搞成一样的。（同步 render.js 和 Root.jsx 中的设置，App 内可能需要处理一下）\nTODO：以上两个改进可以考虑不做，新的 version-x 会重新设计开始屏幕，做成一个 logo 的简单样式，就不需要 ssr 了。html 和 css 代码可以写在别的地方，直接作为字符串引入到编译好的 agentconsole.aspx 和 index.html 里面就可以了。react 在动态生成真实代码的时候，把起始屏上的 ui 直接删掉就可以了。</p></section>\n<section><h1>build/server.demo.js</h1><p>这个应该不在用了，主要是以前的 demo 代码，建议改成用 storybook 使用。</p></section>\n<section><h1>build/server.dev.js</h1><p>webpack dev server 配置。和普通的 webpack 配置基本一样，主要有几个不同：</p><ol>\n<li>入口文件用的是桌面版的 index.html，主要是因为 web 版的 agentconsole.aspx 涉及到 asp.net 的渲染，直接无法使用</li>\n<li>加入了 hot-load 的功能</li>\n<li>会启一个 web dev server 的服务器</li>\n</ol></section>\n<section><h1>build/upgrade.ejs</h1><p>这个是 upgrade.html 页面的模板文件。在 index.html 里面，会判断当前的桌面版渲染层的版本号以及当前桌面版壳的版本号，如果发现渲染层需要的最低版本号高于当前壳的版本号，就会跳转到这个本地的页面，要求用户手动升级完成后再使用。</p><p>编译在 webpack.electron.config.js 中使用 HTMLWebpackPlugin 完成。 </p></section>\n<section><h1>build/webpack.base.config.js</h1><p>这里存放了 webpack 编译时候用到的主要的一些配置。这里单独放一个 base 的 config 文件，主要也是出于以下几个方面的考量：</p><ol>\n<li>eslint 需要用 webpack 的配置来同步 alias 的设置，这样才可以准确的判断 import 的对象是不是真实存在的</li>\n<li>一些基础的 webpack 配置在正式打包以及在开发使用的 dev server 中都是一样的，独立一个 base 文件就可以共享这些内容</li>\n</ol><p>最终会通过 webpack-merge 这个库来合并</p></section>\n<section><h1>build/webpack.config.js</h1><p>这个是打包用到的 webpack 配置，对应的命令是 npm run build:web 或者 npm run build:electron。</p><p>一些配置上的说明：</p><ol>\n<li>colorize 这个函数利用了一些特殊字符，使得在命令行的输出可以带上颜色</li>\n<li>monitor 模块的选取是根据文件的创建时间来找的，选取的是最新创建的 monitor 文件</li>\n<li>nowToString 是当前的时间，特意隐去了时区的概念，隐藏中国开发团队的信息</li>\n<li>transform-react-constant-elements 这个 babel 包可以把一些静态的 react 组建放到全局的位置，这样不用每次 render 的时候都重新创建一边 VNode</li>\n<li>transform-react-inline-elements 会用 babel 的函数（而不是 React.createElement 来创建 VNode），性能上会快一些</li>\n<li>transform-string-join 可以把 <code class=\"language-text\">[&quot;a&quot;, &quot;b&quot;].join(&#39;&#39;)</code> 这样的代码转化成 <code class=\"language-text\">&quot;ab&quot;</code> 这样的代码。在书写代码的时候可以把长字符串分段书写，编译的时候会把这些计算的部分优化掉，不用担心性能问题</li>\n<li>strip-module 可以把一些模块的引用直接从代码里面删除。如果只是单纯的通过 <code class=\"language-text\">if(process.env.NODE_ENV !== &#39;production&#39;) { }</code> 这样的代码来处理，模块依然有可能被引用（只是 runtime 中没被使用）。出于编译结果大小方面的考虑，这里用这个包直接把代码删掉，避免不必要的额外大小增加。（TODO：在新版本的 Webpack 中，可以再试试，看看 tree shake 是不是有更好的效果了；也许不需要这个包了）</li>\n<li>lodash 这个也是为了最后的包大小优化，会把 lodash 的引用做细致的优化，只把需要的部分引用进来，最终 webpack 不会把不需要的部分打包到结果中（需要配合 LodashModuleReplacementPlugin 一同使用）</li>\n<li>PreloadWebpackPlugin 需要在有 HtmlWebpackPlugin 的基础上使用。会把一些之后一定会用到的模块，通过 prefetch 的方式在页面上直接引用。浏览器会在合适的时候先行下载，当用户登陆之后，这些模块很可能已经下载完成了，这样最终的显示会快一些。（目前配置的是 prefetch，但是也可以考虑 preload）。另外，webpack 的动态 import 功能也提供了 prefetch/preload 的功能，这里的这个 plugin 不一定是必须的）。注：webpack 中给动态家在的模块增加 preload/prefetch 支持，可以这么写：<code class=\"language-text\">import(&#39;module-path-here&#39; /* webpackPrefetch: true */)</code></li>\n<li>BundleAnalyzerPlugin 是一个平时不需要使用的库。但是在有模块增加的时候，可以取消注释，让这个 plugin 分析一个包大小的报告出来。通过报告，可以比较清楚的看到每一个编译出来的文件，具体包含了那些模块的内容。这些模块可大可小，也可能会有重复。如果发现了不合适的引用，可以通过代码中的调整达到最终包大小优化的效果。（比如说，也许会发现一个库在不同的文件中都被引用了，这时候就可以看一下具体是什么原因造成的，然后尽量让大的库的代码只出现一次。例如，现在 agent console 使用的 immutable 的版本号是 <code class=\"language-text\">~3.7.6</code>，原因就是为了和 draft-js 中使用的 immutable 版本号匹配，这样就不会在最终的结果中出现两个版本号不同的 immutable，造成不必要的大小增加）。</li>\n<li>桌面版和 Web 版本用的压缩工具是不一样的。web 用的是 uglily，因为 web 需要兼容老的浏览器，不支持 es6 语法；桌面版用 babili 是因为可以直接压缩成 es6 语法的 javascript。TODO 从实际使用结果上看，babili 的压缩工具需要升级，另外压缩完成后注释的部分没有保留，看上去配置也是对的，这个不知道升级版本之后能不能解决。注释的部分是需要保留的，一方面是有写版权信息不能删掉，另外编译加上去的 banner 也没有了，给后续维护增加了点麻烦。得改好。TODO 另外，babili 是不是最好的 es6 压缩工具还需要再看一下，也许现在已经有更好的压缩工具了。</li>\n</ol></section>\n<section><h1>build/webpack.dll.config.js</h1><p>编译 DLL 的目的主要是为了加速 webpack 的编译。大部分情况下，react，redux 之类的库是不会随意变动版本号的。这时候，用 dll 的形式将这些内容提前编译下来，可以在编译正式 agent console 代码的时候，节省一部分的工作量。同时，对用户来说，这部分的代码在更新 agent console 版本的时候，大概率也是不会发生变化的，可以直接让浏览器使用缓存的版本，下载速度会更快一些。</p><p>目前主要使用了两个 dll 文件，react.dll.js 和 redux.dll.js。这两个文件的名称和实际的内容并不完全相符。两个部分加入的内容，更多的是希望两个包的大小不会差别太大。未来可以考虑对包的分配做一些优化，比如 react + redux + react-redux 放一起，immutable + draft 之类的放一起，redux-form + react-modal + react-tooltip 之类的放一起等等。（todo redux-form 可以考虑删除了，这个实际用下来功能大多用不到，还平添了不少包的大小）</p></section>\n<section><h1>build/webpack.doctor.config.js</h1></section>\n<section><h1>build/webpack.electron.config.js</h1><p>这个主要是为了编译 app/main.js 的配置。</p><p>编译的结果使用了 babili 进行压缩（因为 electron 支持更好的 es6），主要也是防止代码层面的数据泄漏出去。electron 打包的结果，app.asar 文件是很容易解压缩的，得到的结果就是 javascript 文件，如果这里不进行代码的压缩，很多注释/变量名等信息就会很容易的被泄漏出去，可能造成不必要的麻烦。在这里，压缩不是为了减少包大小（electron 的安装包也不在乎这点大小上的变化）</p></section>\n<section><h1>build/webpack.monitor.config.js</h1><p>是为了编译出 monior.js 这个文件的配置。</p></section>\n<section><h1>build/webpack.sdk.config.js</h1></section>\n<section><h1>build/webpack.store.config.js</h1><p>会把 store.perf.js 这个文件进行编译。最终生成的结果是给 node.js 跑用的，参考 <code class=\"language-text\">npm run perf</code> 这个命令。最终生成出来的结果用 <a href=\"https://mrale.ph/irhydra/1/\">irhydra</a> 工具来查看可能的性能问题。这个已经不再使用了，主要是 irhydra 工具已经不在维护了。</p><p>但是，这个思路还是可以借鉴的，如果还有其他的分析工具可以处理 node-js v8 引擎跑出来的结果，在性能优化的时候，还是可以拿来做参考的。</p></section>\n<section><h1>build/webpack.sw.config.js</h1><p>这个是 service worker 的编译部分。这部分的代码也暂时不再使用了，水星项目中，相关的部分已经从 service worker 中改到 web worker 里去处理了。</p><p>service worker 处理网络层数据转化的功能，存在的主要问题是：service worker 是一个共用的模块，如果一个用户开了两个 tab，那么只刷新一个页面不会更新 service worker，这可能导致最终的网络层数据转化不正常。web worker 不是 tab 共享的，所以不存在这个问题。两者都是另外开线程的，不会影响主线程的功能，耗性能的计算给用户的影响更少。 </p><p>但是，并不是说 service worker 就没有应用场景了。service worker 的强缓存和 server push notification 还是可以考虑给 agent console 加上的。其中总，强缓存这个意义不算特别大，毕竟 agent console 在离线状态下是没有使用意义的。但是 push notification 的应用场景应该是有的。具体可以和 UX 部门商量，适时加上。</p><p>另外，有了 service worker 之后，Chrome 会在合适的时候建议用户将 agent console 添加为桌面应用。这个应该也是一种用户体验的提升。</p><p>TODO 具体需要和 ux 团队沟通，看具体怎么使用这些 pwa 的功能。</p><p>另外，务必需要注意的一点：在开启 service workder 的时候，一定要在服务器上放一个文件，用于告知 agent console 是否使用 service worker。比如，之前一直是使用 sw.json 这个文件中的 useSW 字段来判断是否需要开启 service worker 的。程序需要先读取 sw.json 这个文件（而且需要保证没有缓存），再决定是否继续使用 service worker 功能。这是因为，service worker 是一个强缓存的 web proxy，如果不提供一个可以手动下线 service worker 的功能，一旦 service worker 出现问题，除了改 agent console 的 URL，可能用户就没有能使用的办法了。（可以通过 chrome devtool 中的 by pass servcie worker 来禁用 servcie worker 的代理，但是这种操作对用户来说太麻烦了）</p></section>\n<section><h1>server</h1><p>这里原来是写了一个 mock server，用于 e2e 的测试用过的。但是这个维护起来非常麻烦，最终的效果也不是非常好，暂时已经弃用了。不建议继续维护。</p></section>\n<section><h1>src/assets</h1><p>这里的部分是非常重要的，最终编译出来的结果里一定要有这两个部分，是 pwa 非常重要的组成部分。如果这些数据不完整的话，最终 Chrome 是不会建议用户把 agent console 添加到桌面的。具体这里的配置，可以和 UX 团队确认。</p></section>\n<section><h1>src/components/LazilyLoad</h1><p>这个是一个比较老的实现了。水星项目已经升级了 react 到 16，建议改用 React.lazy 以及 React.Suspense 来做相同的工作。</p><p>TODO 改用 React.Suspense</p><p>同理，containers/SplitterChat.jsx 或者类似的 Splitter 文件都可以考虑去掉了。</p></section>\n<section><h1>src/store/web</h1><p>这里 export 了一个 middleware，用于拦截 dispatch 的 action，然后转化为网络请求；再根据网络请求的结果，dispatch 一些新的 action。</p><p>总体上来看，这里原来的设计是不太好的，逻辑写的比较乱，建议有时间的时候进行重构。主要考虑以下几个方面：</p><ol>\n<li>index.js 里，最后 return 的部分是不对的，应该 return action 而不是 return state</li>\n<li>这里 middleare 的数据流向大概是：action => input => queue => client => output => dipatch action，其中 input 用于判断 aciton 是否要被拦截处理，拦截的部分放入到 queue 中，queue 的内容会打包给 client 去发送，发送的结果在 output 里处理成新的 action 发送出去。但是从代码的书写上，上述逻辑不是体现的很明显，急需改进。</li>\n</ol></section>\n<section><h1>src/store/actionStashLogger</h1><p>这个 middleware 的作用是记录当前最近的 20 个 action，在 dumpfile 生成的时候会用到。</p></section>\n<section><h1>src/store/chatFilter.js</h1><p>这个文件用于处理可能和聊天相关的 action。在 agent console 里，服务器返回的数据都是和访客相关的，聊天只是访客的一个附属部分。但是从前端的角度看，更愿意把聊天当作一个更加独立的部分来看（因为一个访客对应的当前聊天只有一个，但是前端有时候会需要保留之前该访客的其他聊天），所以前台的处理方式和服务器的方式是略有不同的。chatFilter 在这里的作用，是把服务器返回的基于访客的 action，转化成前端更好理解的和 chat 相关的新 action。比如，哪些聊天结束了，哪些聊天开始了，等等。如果发现聊天生成的结果有不符的地方（比如聊天在 visitor list 中有，但是在 chat list 中没有），这个文件很可能是问题的源头。</p></section>\n<section><h1>src/store/cobrowsing.js</h1><p>这个 middleware 处理是否需要开启/关闭 cobrowsing。在刚开始的时候，cobrowsing 是以 iframe 的形式展示在 agent console 里面的。但是用户可以选择 popout 的方式，将 cobrowsing 弹出来。弹出来的页面，是 cobrowsing.html，需要的数据会通过 agent console 的 postMessage 传递。</p><p>另外，因为 glance cobrowsing 的页面不能刷新，所以在弹出来之后，原来 agent console 页面上的 iframe 不是删掉了，只是隐藏了，没有被删除。（见 Cobrowsing.jsx 的代码）</p></section>\n<section><h1>src/services/memoryStore</h1><p>这是一个非常不好的设计。程序现在在很多地方都有对 memorystore 的直接使用。在 reducer 中使用肯定是有问题的，这个破坏了最开始 reducer 是纯函数的设计理念（同样的输入，因为 memorystore 的不同，很可能造成不一样的结果）。在其他地方当作全局变量存储也是有问题的，一个是性能方面的问题（在水星项目里有改过一些类似的问题），一个是依赖这样一个全局的 general 存储工具容易造成 bug。另外，有些情况下，localStorage/sessionStorage 等长效存储机制可能才是更好的选择。</p><p>TODO 建议删除所有对 memoryStore 的依赖。每一个具体的使用，应该都可以找到更好的处理方案。如果确实需要依赖一些全局的存储/读取，根据专门的需求创建专门的 Singleton 可能是更合理的做法。</p></section>\n<section><h1>typings.json</h1><p>这个是几年前流行的类型方案了，现在基本不再使用了。如果使用了一个新的库，希望 VSCode 或者 typescript 对类型能够有很好的支持，可以去 npm 上找 @types 下面有没有对应的库的类型说明文件。有的话，直接 yarn install —dev @types/xxx 就可以了。</p></section>","frontmatter":{"title":"交接","date":"2019-04-09","modified":"2019-04-09","description":""}}},"pageContext":{"slug":"/handover1/","previous":{"fields":{"slug":"/ledger/","type":"draft"},"frontmatter":{"title":"ledger","category":"Tools","tags":"Tools"}},"next":{"fields":{"slug":"/handover/","type":"draft"},"frontmatter":{"title":"交接","category":"","tags":""}}}}