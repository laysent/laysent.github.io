{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/post/write-code-to-rewrite-your-code/","webpackCompilationHash":"","result":{"data":{"site":{"siteMetadata":{"blogTitle":"LaySent's Blog","author":"LaySent"}},"markdownRemark":{"id":"bd66a741-4329-5dea-b1f3-24a8ea921099","html":"<p>有多少次，你在目录下用搜索替换的方式来更改 JavaScript 源文件？更高阶一点的，你会用上正则表达式的 capture group。如果你的代码量足够大（sizable），这样的操作是值得的。然而，正则表达式是非常局限的。对于非常规（non-trivial）的改动，工程师必须清楚代码的上下文，并且愿意花时间在这一冗长，tedious 且容易出错的事情上。</p>\n<p>这这种时候，就需要 codemods 登场了。</p>\n<p>Codemods 是一种改写脚本的脚本。可以把它们看作一种能理解和产出代码的搜索替换功能。使用这类脚本，你可以根据团队的代码规范来更新源代码，也可以在 API 改变的时候进行大范围的更新，甚至在公共库产生 breaking change 的时候自动修复现有代码。</p>\n<p>在这篇文章里，将用一款为 codemods 打造的工具，jscodeshift，来创建三个难度系数逐级递增的 codemods。读完本文，你将拥有 broad exposure to the important aspects of jscodeshift，并且可以开始编写自己的 codemods。我们将通过三个练习来理解 codemods 基本的用法。虽然基础，但是这些应用都很酷。你可以在我的 <a href=\"https://github.com/reergymerej/jscodeshift-article\">GitHub</a> 上看到这些练习完整的源代码。</p>\n<section><h2>什么是 jscodeshift</h2><p>使用 jscodeshift 工具，你可以将一堆原始代码进行转化，并用转化后的结果替代原始的内容。在转化的过程中，程序将首先将代码转化成抽象语法树（AST），poke around to maek your changes，最后再从修改后的抽象语法树中生成的代码。</p><p>jscodeshift 提供的接口是基于 <code class=\"language-text\">recast</code> 和 <code class=\"language-text\">ast-types</code> 的封装。其中，<code class=\"language-text\">recast</code> 处理源代码和抽象语法树之间的相互转化，而 <code class=\"language-text\">ast-types</code> 则负责在底层和抽象语法树交互。</p></section>\n<section><h2>Setup</h2><p>首先，全局安装 jscodeshift：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> i -g jscodeshift</code></pre></div><p>There are runner options you can use，jscodeshift 还提供了 opinionated 测试组件来简化基于 Jest（一个开源的 JavaScript 单元测试框架）的测试。不过我们先不看这些，免得把事情搞复杂：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">jscodeshift -t some-transform.js input-file.js -d -p</code></pre></div><p>上述代码，将 <code class=\"language-text\">input-file.js</code> 通过 <code class=\"language-text\">some-transform.js</code> 转化并打印出最终的代码，但不会真正改变原始的文件内容。</p><p>在深入之前，有必要先来了解三个 jscodeshift API 中一直打交道的对象类型：nodes，node-paths 和 collections。</p><section><h3>Nodes</h3><p>节点（Nodes）是抽象语法树中最基本的单位，也被称为“抽象语法树节点”（AST nodes）。当你在 AST Explorer 上查看你的代码的时候，你看到的就是这类节点。节点本身只是简单的对象，并不提供任何函数功能。</p></section><section><h3>Node-paths</h3><p>Node-paths 是 <code class=\"language-text\">ast-types</code> 对抽象语法树节点的封装，提供了遍历抽象语法树的功能。单独来看，节点本身并没有提供其父元素或作用域（scope）的任何信息，这些都将有 node-paths 来提供。你可以通过 <code class=\"language-text\">node</code> 这个属性来访问到封装中的节点。node-paths 另外提供了一些方法来修改节点。很多时候，node-paths 被简单地称作 paths。</p></section><section><h3>Collections</h3><p>当使用 jscodeshift 的 API 来查询抽象语法树的时候，返回的就是一个 Collection，其中包含零个或多个 node-paths。同时，Collection 也包含了很多非常游泳池的方法，一些我们将在后面进行介绍。</p><p>Collections 包含 node-paths，node-paths 包含 nodes，而 nodes 就是抽象语法树的组成单位。记住这一关系，它将帮助你更好的理解 jscodeshift 查询 API。</p><p>要 keep track 这些对象的不同以及不同对象所带的方法是比较麻烦的，这里有一个 nifty 工具，jscodeshift-helper 可以输出这些对象的类型以及其他又用的信息。</p><p><a href=\"https://www.toptal.com/javascript/write-code-to-rewrite-your-code\">Source</a></p></section></section>","frontmatter":{"title":"Write Code to Rewrite Your Code","date":"2019-07-01","modified":"2019-07-01","description":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/write-code-to-rewrite-your-code/","previous":{"fields":{"slug":"/cicada-principle/","type":"blog"},"frontmatter":{"title":"蝉原则（Cicada Principle）","category":"Web","tags":"Web, CSS"}},"next":null}}}