{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/post/subresource-integrity-and-error-handling/","webpackCompilationHash":"ab0113c04094e3e47d77","result":{"data":{"site":{"siteMetadata":{"blogTitle":"LaySent's Blog","author":"LaySent"}},"markdownRemark":{"id":"fe61af40-32e6-57bf-b2bb-6a04ae4b918f","html":"<blockquote>\n<p><a href=\"https://laysent.github.io/subresource-integrity-demo/service-worker/integrity-with-service-worker-and-inserted-resource.html\">在线演示</a></p>\n</blockquote>\n<p>本文主要介绍，当含有 <code class=\"language-text\">integrity</code> 的文件加载失败时，可行的处理方案。</p>\n<section><h2>Subresource Integrity 的问题</h2><p>SRI 的目的是为了校验第三方资源文件。当第三方资源文件被篡改的时候，浏览器会拒绝有风险文件的加载，从而保护用户不会受到来自不明代码的安全威胁。</p><p>然而，当浏览器拒绝加载有风险的文件时，不仅风险被隔绝了，原有的功能也被隔绝了。这意味着部分、甚至全部的功能丧失（因为放在第三方的资源文件一般是底层的依赖库）。这显然不是一个良好的用户体验。为此，有两个问题亟待解决：</p><ol>\n<li>如何及时发现这个问题</li>\n<li>如何保证客户的功能使用不受到影响</li>\n</ol></section>\n<section><h2>如何及时发现问题</h2><p>有几个可行的思路。</p><p>首先，可以考虑使用 JavaScript 来加载资源文件。这样加载的同时可以附加一个 <code class=\"language-text\">onerror</code> 的事件，当加载失败的时候，就可以得到回调。这样做的好处是，方案是不依赖于具体资源文件的通用方案；但是缺点是，动态加载的资源文件使得浏览器无法在加载 HTML 的时候静态分析，加载效率会受到影响。示例代码：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> script <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nscript<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> <span class=\"token string\">'src here'</span><span class=\"token punctuation\">;</span>\nscript<span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> <span class=\"token string\">'text/javascript'</span><span class=\"token punctuation\">;</span>\nscript<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onerror</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* 资源加载失败了 */</span> <span class=\"token punctuation\">}</span>\ndocument<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>script<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>其次，也可以通过 JavaScript 去检查某些功能点，以确保资源被正确加载了。举例来说，如果要检查 <code class=\"language-text\">jQuery</code> 是否被正确加载了，可以这样做：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> isJQueryLoaded <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> window<span class=\"token punctuation\">.</span>jQuery <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">;</span></code></pre></div><p>这样做的好处是，不需要使用动态加载的方案，可以尽享浏览器能提供的加速服务；然而缺点是，不同的资源文件，检查点是不同的，无法提供一个通用的解决方案。同时，如果资源文件是使用 <code class=\"language-text\">defer</code> 或 <code class=\"language-text\">async</code> 加载的，那么检查的时间点也不好控制。对于 <code class=\"language-text\">defer</code> 的文件，尚且可以在 <code class=\"language-text\">DOMContentLoaded</code> 事件后做检查；而 <code class=\"language-text\">async</code> 类型的资源加载完成点更加不可控，需要在 JavaScript 文件 <code class=\"language-text\">load</code> 事件之后检查才行。</p></section>\n<section><h2>如何保证功能</h2><p>在检查到问题之后，为了不影响功能的使用，可以考虑立即加载一个备用资源。一般来说，这个备用资源是存放在自有服务器，而不是 CDN 服务器上的。这是因为，自有服务器是可自控的，可信赖度会比第三方的要高。如果自有服务器上的文件受到了污染，那么其实前端无论做什么都于事无补了。</p><p>示例代码如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> window<span class=\"token punctuation\">.</span>jQuery <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> script <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  script<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> <span class=\"token string\">'jQuery located on own server'</span><span class=\"token punctuation\">;</span>\n  script<span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> <span class=\"token string\">'text/javascript'</span><span class=\"token punctuation\">;</span>\n  document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>script<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div></section>\n<section><h2>Service Worker 的解决方案</h2><p>Service Worker 提供了对网络请求的代理，这使得一个统一的通用解决方案有望成为可能。</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/**\n * 这里定义了需要检查对资源文件\n * 以及当资源文件加载出现问题之后，替代文件的位置\n */</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">REPLACEMENT_MAPPING</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">'resource on cdn'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'backup resource on own server'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">RESOURCES</span> <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token constant\">REPLACEMENT_MAPPING</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetch'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> request <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> pathname <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">URL</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">/**\n   * 对于不存在备用方案的资源文件，不作处理\n   */</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">RESOURCES</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>pathname<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    event<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span>\n    <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">/**\n       * 网络资源请求失败的时候，使用备用资源再请求一次，并将结果返回给前端\n       * 对于前端代码来说，这部分逻辑是隐藏的\n       * 即是说，前端无法知晓具体使用的是 CDN 还是自有服务器的资源文件，也不需要关心这个\n       */</span>\n      <span class=\"token keyword\">const</span> linkFromOwnServer <span class=\"token operator\">=</span> <span class=\"token constant\">REPLACEMENT_MAPPING</span><span class=\"token punctuation\">[</span>pathname<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> req <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Request</span><span class=\"token punctuation\">(</span>linkFromOwnServer<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">/**\n       * 这里可以将问题汇报给服务器预警程序\n       */</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Should notify server here...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>使用 Service Worker 的解决方案，可以将处理的逻辑从原有的业务逻辑中独立出来。前端的业务逻辑不需要知道具体使用的是哪个服务器上的代码，也不需要关心。</p><p>然而，从实际的测试上来看，不同的浏览器对这里 Subresource Integrity 的行为略有不同。（可以用不同的浏览器在<a href=\"https://laysent.github.io/subresource-integrity-demo/service-worker/integrity-with-service-worker-and-inserted-resource.html\">这里</a> 进行测试）</p><p>具体来说，在 Chrome 里，如果资源文件是通过 HTML 直接引用的，Service Worker 无法捕捉到 <code class=\"language-text\">fetch</code> 的异常，<code class=\"language-text\">fetch</code> 请求中也没有 integrity 属性。但是对于使用 JavaScript 动态插入的资源引用，Chrome 的 Service Worker 可以正确处理，<code class=\"language-text\">fetch</code> 中也可以查看到 <code class=\"language-text\">integrity</code> 的属性。</p><p>对 Firefox 来说，无论资源文件是通过 HTML 直接引用的，还是通过 JavaScript 动态加载的，Service Worker 都可以正确捕获到异常并处理。</p><p>Safari 的情况比较怪异，对于 HTML 直接引用的资源文件，Service Worker 可以正确处理其中的样式资源文件，但是无法处理脚本文件；对于使用 JavaScript 动态插入的资源引用，Safari 的 Service Worker 都可以正确处理。</p></section>","frontmatter":{"title":"Subresource Integrity 出错时的处理方案","date":"2019-03-27","modified":"2019-03-27","description":"Subresource Integirty (SRI) 会在资源文件不匹配的情况下加载失败，从而影响用户正常使用。本文介绍当出现这种情况时，如何将问题记录并汇报给预警服务器，并启用备用资源文件保证用户的正常使用。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/subresource-integrity-and-error-handling/","previous":{"fields":{"slug":"/git-commit-message/","type":"blog"},"frontmatter":{"title":"Git Commit Message","category":"Tools","tags":"Tools"}},"next":{"fields":{"slug":"/alias-for-web-project/","type":"blog"},"frontmatter":{"title":"Web 应用的 Alias 配置","category":"Tools","tags":"Tools, JavaScript"}}}}}