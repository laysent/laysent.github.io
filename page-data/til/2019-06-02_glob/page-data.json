{"componentChunkName":"component---src-templates-til-js","path":"/til/2019-06-02_glob","result":{"data":{"markdownRemark":{"id":"3bf8fb2c-bc26-5383-b33e-a3b271ad750e","html":"<p>Glob 类似于 Regular Expression，主要的使用场景是用于批量的文件匹配，在 bash 或是配置文件中常常被使用。下面列举了一些常见的语法规则：</p>\n<ul>\n<li><code class=\"language-text\">*</code> 匹配任意多个字符（包括匹配零个）</li>\n<li><code class=\"language-text\">?</code> 匹配任意一个字符</li>\n<li><code class=\"language-text\">[abc]</code> 匹配方括号中的任意一个字符</li>\n<li><code class=\"language-text\">[!abc]</code> 或 <code class=\"language-text\">[^abc]</code> 匹配除了方括号中定义的三个字符外的任意字符</li>\n<li><code class=\"language-text\">[a-z]</code> 匹配方括号定义范围内的任意一个字符</li>\n<li><code class=\"language-text\">[!a-z]</code> 或 <code class=\"language-text\">[^a-z]</code> 匹配除了方括号定义范围内的任意一个字符</li>\n<li><code class=\"language-text\">{ab,cd,ef}</code> 匹配花括号中定义的三个字符串中的任意一个</li>\n</ul>\n<p>举个例子，如果 Jest 的单元测试文件命名规范的正则表达式是：<code class=\"language-text\">.+\\.(?:test|spec)\\.[tj]sx?$</code>，也就是匹配下面的这些文件：</p>\n<ul>\n<li>a.test.js</li>\n<li>b.test.jsx</li>\n<li>c.test.ts</li>\n<li>d.test.tsx</li>\n<li>e.spec.js</li>\n<li>f.spec.jsx</li>\n<li>g.spec.ts</li>\n<li>h.spec.tsx</li>\n</ul>\n<p>那么，相应的 Glob 可以写：<code class=\"language-text\">*.{test,spec}.{js,jsx,ts,tsx}</code>。</p>\n<p>如果不涉及到 React 的代码（没有 jsx），可以写成：<code class=\"language-text\">*.{test,spec}.[tj]s</code>。</p>\n<p>参考文档：</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Glob_(programming)\">Wikipedia</a></li>\n<li><a href=\"http://www.jedit.org/users-guide/globs.html\">Glob Patterns</a></li>\n<li><a href=\"http://www.globtester.com/\">globtester</a></li>\n</ul>","frontmatter":{"title":"glob","category":"Bash","date":"2019-06-02"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"time":"2019-06-02","title":"glob","previous":{"time":"2019-05-31","title":"Placeholder Images"},"next":{"time":"2019-06-03","title":"global Provider for storybook"}}}}