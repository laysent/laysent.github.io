{"componentChunkName":"component---src-pages-til-js","path":"/til/","webpackCompilationHash":"687e338135c47159cd63","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"5493d287-9fbc-54bc-ac13-cfaca63332c9","html":"<p>安装 <code class=\"language-text\">etherwake</code> 用于 WOL (wake on LAN) 操作</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> etherwake</code></pre></div>\n<p>接下来，可以通过命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> etherwake -i eth0 AA:BB:CC:DD:EE:FF</code></pre></div>\n<p>来唤醒 AA:BB:CC:DD:EE:FF 这个 MAC 地址的设备。几点注意：</p>\n<ol>\n<li><code class=\"language-text\">etherwake</code> 需要 <code class=\"language-text\">sudo</code> 运行，否则会报错：<code class=\"language-text\">etherwake: This program must be run as root.</code></li>\n<li><code class=\"language-text\">-i eth0</code> 不是必须的。如果同时有有线和无线网卡，<code class=\"language-text\">-i</code> 可以强制要求 <code class=\"language-text\">etherwake</code> 走有线的路径</li>\n</ol>\n<p><a href=\"https://notenoughtech.com/featured/use-raspberry-pi-wol/\">参考文献</a></p>","frontmatter":{"date":"2019-08-06","title":"Raspberry Pi as WOL","category":"Bash"}}},{"node":{"id":"f6b6d594-d2fb-5935-874c-7f6b24cea873","html":"<p>相比于 <code class=\"language-text\">scp</code>，<code class=\"language-text\">rsync</code> 命令可以在 SSH 拷贝的时候提供更多的灵活性，比如只拷贝新修改的或未存在的文件。</p>\n<p>一个简单的拷贝命令如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rsync</span> -auv /local/folder host:/remote/folder</code></pre></div>\n<p>这里，<code class=\"language-text\">-a</code> 表示拷贝所有的文件（包括子文件夹中的），<code class=\"language-text\">-u</code> 表示只拷贝修改时间更新的部分，<code class=\"language-text\">-v</code> 则会将结果输出到 stdin 中方便查看。类似的，还可以使用 <code class=\"language-text\">--ignore-existing</code> 来要求 <code class=\"language-text\">rsync</code> 只拷贝新的文件，忽略已经存在的部分。</p>\n<p>然而在实际使用的过程中，<code class=\"language-text\">rsync</code> 有如下报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Permission denied, please try again.\nrsync: connection unexpectedly closed (0 bytes received so far) [sender]\nrsync error: error in rsync protocol data stream (code 12) at io.c(235) [sender=3.1.2]</code></pre></div>\n<p>如果换同样的 SSH 配置，使用 <code class=\"language-text\">scp</code> 就不会有类似的报错，可见本身并不是 SSH 登陆账户权限的问题。这里的 Permission denied 报错非常的具有误导性。实际上，更可能的情况是 <code class=\"language-text\">rsync</code> 无法在远程主机上找到，需要通过 <code class=\"language-text\">--rsync-path</code> 参数手动指定。</p>\n<p>首先，可以先 SSH 到远程主机上，确认 <code class=\"language-text\">rsync</code> 本身是存在的：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rsync</span> --help</code></pre></div>\n<p>接着，可以通过 <code class=\"language-text\">type</code> 命令确认 <code class=\"language-text\">rsync</code> 的实际位置：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">type</span> -a <span class=\"token function\">rsync</span></code></pre></div>\n<p>这里，假设输出的结果是 <code class=\"language-text\">/bin/rsync</code>，那么，可以将原先的 <code class=\"language-text\">rsync</code> 命令改写为：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rsync</span> -auv /local/folder host:/remote/folder --rsync-path<span class=\"token operator\">=</span>/bin/rsync</code></pre></div>\n<p>再次运行就不会报错了。</p>\n<p><a href=\"https://superuser.com/questions/1017697/how-can-rsync-fail-due-to-missing-permissions-if-remote-login-occurs-with-root\">参考文档</a></p>","frontmatter":{"date":"2019-08-05","title":"Permission Denied for Rsync","category":"Bash"}}},{"node":{"id":"bb00bd56-438b-5e03-926d-cb9348da2b4d","html":"<p>在 C 编程中，经常会用到 <code class=\"language-text\">Makefile</code> 来对源代码进行编译。一个简单的 <code class=\"language-text\">Makefile</code> 如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"makefile\"><pre class=\"language-makefile\"><code class=\"language-makefile\"><span class=\"token symbol\">out</span><span class=\"token punctuation\">:</span> input.c\n  <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> input.c -o out -Wall -Wextra -std<span class=\"token operator\">=</span>c99</code></pre></div>\n<p>这里，第一行的 <code class=\"language-text\">out: input.c</code> 表示 <code class=\"language-text\">make</code> 应该根据输入 <code class=\"language-text\">input.c</code> 来产出 <code class=\"language-text\">out</code> 这个文件。</p>\n<p>第二行的 <code class=\"language-text\">$(CC)</code> 会由 <code class=\"language-text\">make</code> 替换成本机的 cc 程序（即 <strong>c</strong> <strong>c</strong>ompiler）；后面跟着的是 <code class=\"language-text\">cc</code> 编译会用到的参数，包括输入源文件 <code class=\"language-text\">input.c</code>，输出文件 <code class=\"language-text\">out</code>，编译输出所有的 Warning（<code class=\"language-text\">-Wall</code> 即 <strong>W</strong>arning <strong>all</strong>，<code class=\"language-text\">-Wextra</code> 即 <strong>W</strong>arning <strong>extra</strong>），同时指定使用 <a href=\"https://en.wikipedia.org/wiki/C99\">C99</a> 标准来编译 C 代码（和 <a href=\"https://en.wikipedia.org/wiki/ANSI_C\">ANSI C</a> 相比，C99 允许在函数的任意位置定义变量，而不是必须在顶部）。</p>\n<p>运行 <code class=\"language-text\">make</code> 命令，程序会查找当前目录下的 <code class=\"language-text\">Makefile</code> 函数，读取其中的配置，根据输入输出的要求，查找文件，然后再选择编译。</p>\n<p>第一次编译，程序会用 <code class=\"language-text\">input.c</code> 编译出一个 <code class=\"language-text\">out</code> 文件来。</p>\n<p>在 <code class=\"language-text\">input.c</code> 没有修改的情况下，如果再运行一次 <code class=\"language-text\">make</code> 命令，会得到如下的输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">make: `out` is update to date.</code></pre></div>\n<p>这里，<code class=\"language-text\">make</code> 程序并没有通过任何外部文件的方式记录编译的情况。判断是否需要编译完全依赖于系统默认的文件功能，即简单的比较 <code class=\"language-text\">input.c</code> 和 <code class=\"language-text\">out</code> 两个文件的最后修改时间。如果 <code class=\"language-text\">out</code> 的最后修改时间比 <code class=\"language-text\">input.c</code> 要晚，就认为 <code class=\"language-text\">out</code> 是最新的，不再重复编译；如果 <code class=\"language-text\">input.c</code> 的最后修改时间晚于 <code class=\"language-text\">out</code> 的时间，或是 <code class=\"language-text\">out</code> 压根就不存在，那么 <code class=\"language-text\">make</code> 就会执行 <code class=\"language-text\">Makefile</code> 中配置的编译命令。</p>\n<p>可以通过以下方式欺骗 <code class=\"language-text\">Makefile</code> 来检查这一行为：</p>\n<ol>\n<li>修改一下 <code class=\"language-text\">input.c</code> 并保存</li>\n<li>删除 <code class=\"language-text\">out</code> 文件，然后用 <code class=\"language-text\">touch</code> 命令创建一个空的 <code class=\"language-text\">out</code> 文件。因为是先修改，再创建，所以 <code class=\"language-text\">out</code> 的创建时间会晚于 <code class=\"language-text\">input.c</code></li>\n<li>尝试执行 <code class=\"language-text\">make</code> 命令，会发现提示 <code class=\"language-text\">out</code> 已经是最新的，并没有执行真正的编译命令（尽管这里 <code class=\"language-text\">out</code> 并不是通过 <code class=\"language-text\">make</code> 编译出来的）</li>\n</ol>","frontmatter":{"date":"2019-08-04","title":"How Makefile works","category":"Bash"}}},{"node":{"id":"5017cac8-c3ff-523d-bee3-2831eaad1c50","html":"<p>在命令行中，一个命令会有一个返回数值，<code class=\"language-text\">0</code> 代表正确运行；如果命令返回了非 <code class=\"language-text\">0</code> 数据，则代表命令运行出现了错误。</p>\n<p>比如，如果 <code class=\"language-text\">Jest</code> 命令跑单元测试出现了错误，那么就会返回一个非 <code class=\"language-text\">0</code> 的值。运用 <code class=\"language-text\">set -e</code> 可以让 Bash 在遇到非零返回的命令行之后即停止，不再运行接下去的命令。</p>\n<p>那么，该如何确定之前的命令是否返回了 <code class=\"language-text\">0</code> 呢？</p>\n<p>可以简单的使用如下的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token variable\">$?</span></code></pre></div>\n<p>这里的 <code class=\"language-text\">$?</code> 就是上一个命令返回的数值。如果上一条命令执行成功，那么这里应该输出 <code class=\"language-text\">0</code>。</p>","frontmatter":{"date":"2019-08-02","title":"Check Exit Code of Command","category":"Bash"}}},{"node":{"id":"cd1eb582-4609-5413-b31d-1454b20b7d96","html":"<p>在写 CI 脚本的时候，希望可以在脚本执行失败之后终止后续的所有操作。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token string\">\"start\"</span>\n<span class=\"token function\">yarn</span> <span class=\"token function\">test</span>\n<span class=\"token keyword\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>如果 <code class=\"language-text\">yarn test</code> 这个命令失败了，希望不执行 <code class=\"language-text\">echo &quot;end&quot;</code> 语句。然而通过执行上面的代码，会发现默认是执行的。如果希望不执行这个操作，有几种思路：</p>\n<p>第一种，是用 <code class=\"language-text\">&amp;&amp;</code> 将语句串联起来，比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token string\">\"start\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">yarn</span> <span class=\"token function\">test</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>这样的方案，缺点是比较的麻烦。一旦东西比较多，就很难保证代码的可读性了。</p>\n<p>第二种方案，是使用 <code class=\"language-text\">set -e</code>，脚本改为：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">set</span> -e\n<span class=\"token keyword\">echo</span> <span class=\"token string\">\"start\"</span>\n<span class=\"token function\">yarn</span> <span class=\"token function\">test</span>\n<span class=\"token keyword\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>如此一来，脚本在语句执行失败（Exit Code 不是 0）之后就会退出，不会执行接下去的脚本。</p>\n<p><a href=\"http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#The-Set-Builtin\">参考文档</a></p>","frontmatter":{"date":"2019-08-01","title":"Exit when Command Fail","category":"Bash"}}},{"node":{"id":"95e9a909-b17d-5d27-a0f1-f9ae9e02b984","html":"<p>在进行网络请求的时候，有可能会遇上服务器指定链接跳转的情况。此时，无论是 301（永久转移）还是 302（暂时转移），在请求页面的时候都需要根据服务器的指示，去访问下一个链接。当然，这里下一个链接依然有可能是跳转链接，需要继续执行跳转操作。</p>\n<p>一段可用的 Node.js 代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> https <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">link</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> link<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> https <span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>link<span class=\"token punctuation\">,</span> <span class=\"token parameter\">response</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>statusCode <span class=\"token operator\">>=</span> <span class=\"token number\">300</span> <span class=\"token operator\">&amp;&amp;</span> response<span class=\"token punctuation\">.</span>statusCode <span class=\"token operator\">&lt;</span> <span class=\"token number\">400</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> location <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">[</span><span class=\"token string\">'set-cookie'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里，Node.js 处理 HTTP 和 HTTPs 请求使用的模块是不相同的，因而需要根据链接地址的 protocol 进行按需索取。同时，如果是 3xx 的 HTTP 结果，则需要进行链接跳转。可以直接读取 headers 中的 <code class=\"language-text\">location</code> 数据，找到下一步需要跳转到的位置。</p>","frontmatter":{"date":"2019-07-31","title":"Follow Redirection","category":"Node.js"}}},{"node":{"id":"bce782dd-1013-548b-a42e-8b7020a9a3c2","html":"<p>在 Docker 中使用 SSH 的功能时，发现 SSH 报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Bad owner or permissions on ~/.ssh/config</code></pre></div>\n<p>通过 <code class=\"language-text\">ls -l</code> 查看 <code class=\"language-text\">~/.ssh/config</code>，得到如下结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-rw------- 1 1000  1000   557 Jul 29 20:32 config</code></pre></div>\n<p>注意到给出的 User 和 Group 的值不是一个名字（如 <code class=\"language-text\">root</code>），而是一个数字。这说明，文件所属的 User / Group 无法找到。</p>\n<p>可以通过如下的命令查看当前 <code class=\"language-text\">root</code> 用户的 ID：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">id</span> -u root <span class=\"token comment\"># output => 0</span></code></pre></div>\n<p>可以看到和 <code class=\"language-text\">ls</code> 列出的 ID 是不匹配的。这说明，导致 SSH 无法正常工作的主要原因，是 <code class=\"language-text\">~/.ssh/config</code> 文件权限的设置有问题。可以通过如下的命令将权限分配给当前的 <code class=\"language-text\">root</code> 用户：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">chown</span> -R root:root /root/.ssh</code></pre></div>\n<p>再次运行 SSH 就可以正常工作了。</p>","frontmatter":{"date":"2019-07-30","title":"Bad owner or permissions","category":"Bash"}}},{"node":{"id":"6c27cfd3-d03c-5034-a29f-9ac99e7f51bf","html":"<p>当 Ant Design 和 Jest 一起使用的时候，在某些情况下（开启 coverage 的时候）会导致单元测试运行失败。一个可能造成问题的 Ant Design 代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Input <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'antd'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> TextArea <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> Input<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Jest 会报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ReferenceError: Input is not defined\n\n  1 | import { Input } from &#39;ant-design&#39;;\n  2 |\n&gt; 3 | const { TextArea } = Input;</code></pre></div>\n<p>报错的直接原因，是使用了 Ant Design 推荐的 <code class=\"language-text\">babel-plugin-import</code> 和 Jest 计算 coverage 使用的 <code class=\"language-text\">babel-plugin-istanbul</code> 造成的。在<a href=\"https://github.com/ant-design/babel-plugin-import/issues/172\">这里</a>、<a href=\"https://github.com/ant-design/babel-plugin-import/issues/189#issuecomment-445139343\">这里</a>等 GitHub Issue 中都有相应的讨论。</p>\n<p>要修复这个问题，只需要在 Jest 或者单元测试环境中，不使用 <code class=\"language-text\">babel-plugin-import</code> 这个转换插件就可以了。参考代码如下，在 <code class=\"language-text\">.babelrc</code> 中：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"env\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"development\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">[</span>\n          <span class=\"token string\">\"import\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">{</span>\n            <span class=\"token property\">\"libraryName\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"antd\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"style\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"production\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// same as above</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token comment\">// rest of plugins...</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如此一来，只有在 <code class=\"language-text\">NODE_ENV</code> 为 <code class=\"language-text\">production</code> 或 <code class=\"language-text\">development</code> 的情况下，Babel 才会启用 <code class=\"language-text\">babel-plugin-import</code> 这个转换插件。对于 Jest 来说，因为默认设置了环境变量 <code class=\"language-text\">NODE_ENV</code> 为 <code class=\"language-text\">test</code>，所以 Plugin 不会起效。</p>\n<p>这样造成的问题是 Jest 的运行速度会有所降低。</p>","frontmatter":{"date":"2019-07-29","title":"Jest with Ant Design","category":"JavaScript"}}},{"node":{"id":"111b032a-a1fc-57f1-8eed-7a908e9ee7e3","html":"<p>如果手上有多台设备在管理，SSH 的时候需要记住各个设备的 IP 地址、输入，总是很麻烦的。SSH 提供了配置文件的功能，可以为不同的 IP 设置别名，同时配置登陆需要用到的用户名和 RSA 私钥等。</p>\n<section><h2>配置方法</h2><p>修改 <code class=\"language-text\">~/.ssh/config</code> 文件，增加每个设备对应的配置数据。举例如下：</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Host pi\n    Hostname 192.168.xx.xx\n    User pi\n    IdentityFile ~/.ssh/id_pi_rsa</code></pre></div><p>这样就配置好了一个 Raspberry Pi 的别名。接下来，可以直接使用如下的命令来访问设备：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ssh</span> pi</code></pre></div><p>除了 SSH 之外，SCP 也可以使用同样的配置。比如：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">scp</span> -r /local/path pi:/remote/path</code></pre></div></section>","frontmatter":{"date":"2019-07-28","title":"SSH Host Config","category":"Bash"}}},{"node":{"id":"4aa86de8-f5ef-545f-82b2-a0200ca867de","html":"<p>默认情况下，Webapck 会用 Chunk ID 为 <code class=\"language-text\">import()</code> 产生的独立文件命名，最终的结果就是类似于 <code class=\"language-text\">0.bundle.js</code> 这样的文件。这样的文件并不方便理解和管理，所以一般会使用 <code class=\"language-text\">webpackChunkName</code> 这个注释来让 Webapck 使用更加有意义的命名。例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* webpackChunkName: \"module-name\" */</span> <span class=\"token string\">'path-to-bundle'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>最终产生的文件为 <code class=\"language-text\">module-name.bundle.js</code>（这里假设在 Webpack 中配置了 <code class=\"language-text\">output.filename</code> 为 <code class=\"language-text\">[name].bundle.js</code>）。</p>\n<p>然而，每次要手写这样的注释有些麻烦。如果动态加载的模块本身存放位置有规律可循（比如是在 pages 目录下，每个目录有一个入口文件），那么也可以考虑使用 Babel 插件的方式，自动为每个 <code class=\"language-text\">import()</code> 增加合适的 bundle name。</p>\n<p>参考代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">addComments</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arg<span class=\"token punctuation\">,</span> name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// only add leading comment when not found</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">.</span>leadingComments<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  arg<span class=\"token punctuation\">.</span>leadingComments <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n    type<span class=\"token punctuation\">:</span> <span class=\"token string\">'CommentBlock'</span><span class=\"token punctuation\">,</span>\n    value<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">` webpackChunkName: '</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">' `</span></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getChunkNameFromImportPath</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">importPath</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// find a way to transform from import path to chunk name</span>\n  <span class=\"token comment\">// example: from 'path/to/file' to 'path.to.file' as chunk name</span>\n  <span class=\"token keyword\">return</span> importPath<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/\\//g</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nmodule<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">exports</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">babel</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> types<span class=\"token punctuation\">:</span> t <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> babel<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">'add-bundle-name'</span><span class=\"token punctuation\">,</span>\n    visitor<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function-variable function\">CallExpression</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">path</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> node <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> path<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">isImport</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>callee<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>firstArg<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>arguments<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> importPath <span class=\"token operator\">=</span> firstArg<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">addComments</span><span class=\"token punctuation\">(</span>firstArg<span class=\"token punctuation\">,</span> <span class=\"token function\">getChunkNameFromImportPath</span><span class=\"token punctuation\">(</span>importPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"date":"2019-07-26","title":"Import Chunkname with Babel Plugin","category":"JavaScript"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}