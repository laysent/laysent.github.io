{"componentChunkName":"component---src-pages-til-js","path":"/til/","webpackCompilationHash":"d0c1c456129354e33ddb","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"448f8053-cdef-5e30-bca1-6db31d71d267","html":"<p>在 HTTP 协议中，301 Moved Permanently 和 308 Permanent Redirect 在语意上是一致的，都表示一个资源已经被永久性地转移到了一个新的地址（这一点和 302 / 307 对应，后者只是资源的地址被临时修改了）。在这种情况下，浏览器会跳转到新的资源地址，SEO 也会更新资源对应的数据信息。</p>\n<p>虽然 301 和 308 的语意是一致的，但是在实际的浏览器行为上，会有少许差别。根据 <a href=\"https://tools.ietf.org/html/rfc7231#section-6.4.2\">RFC7231</a> 中的表述，因为一些历史原因，客户端有可能会将 301 重定向的请求方法从 POST 修改为 GET。而根据 <a href=\"https://tools.ietf.org/html/rfc7538#section-3\">RFC7238</a> 中的定义，308 重定向是不允许客户端对请求方法进行修改的。</p>\n<p>这里 302 和 307 的区别也是同理。整体的区别见下表：</p>\n<table>\n<thead>\n<tr>\n<th>是否允许改变请求方法</th>\n<th>永久重定向</th>\n<th>临时重定向</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>允许</td>\n<td>301</td>\n<td>302</td>\n</tr>\n<tr>\n<td>不允许</td>\n<td>308</td>\n<td>307</td>\n</tr>\n</tbody>\n</table>","frontmatter":{"date":"2019-10-09","title":"HTTP Status 301 & 308","category":"HTTP"}}},{"node":{"id":"dd5f1e33-ac72-5dc8-a677-eabec28b82f9","html":"<p>在 JavaScript 中，对模块的引用声明一般写在文件的顶部，而实际引用的 API，可能在运行时的非常晚才会被真正的使用到。看上去，这些 <code class=\"language-text\">import</code> 语句并没有什么问题。但实际上，由于引用模块自身的初始化工作以及可能的副作用，<code class=\"language-text\">import</code> 带来的性能损耗有时候也是不容忽视的。</p>\n<p>首先来看下面这个 JavaScript 文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> defaults <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'lodash'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">defaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// → { 'a': 1, 'b': 2 }</span></code></pre></div>\n<p>看上去是一段非常简单的 JavaScript 代码，只是执行了一个很简单的操作。基本等价于下面这段代码（Lodash 的 API 可以参考<a href=\"https://lodash.com/docs/4.17.15#defaults\">文档</a>）：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>然而两者有一个很重要的区别，就是前者引用了 Lodash 的 API。这个看上去是一个非常简单的操作，但实际上也有不小的消耗。在程序执行 <code class=\"language-text\">import</code> 语句的时候，会加载 Lodash 完整的初始化代码，并给 <code class=\"language-text\">defaults</code> 变量赋值 Lodash 的 defaults API。其中，Lodash 的初始化代码完整执行完成，需要大概 15ms 左右的时间。实际上，如果改成只引用 <code class=\"language-text\">defaults</code> 这一个 API，最终的效果就会好很多：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> defaults <span class=\"token keyword\">from</span> <span class=\"token string\">'lodash/defaults'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">defaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果累计了很多这样小的初始化成本，最终就会导致在应用实际启动的过程中，产生几百毫秒的延迟。这一点在 Web 应用中相对还好，毕竟体积和初始化速度多少存在着一些关系，而 Web 应用对体积非常的敏感；但是同样的问题，到了 Electron 项目中，就有可能变得不容小觑起来。作为 PC 级别的应用，Electron 的打包往往对体积没有那么严苛的要求。很多时候多一个库，少一个库，都没有太大的差别。然而，各个库初始化的速度累计起来，却有可能拖累本就不快的 App 启动速度。</p>\n<p>再举一个小例子。下面的这段代码看上去似乎没有什么问题：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> crypto <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'crypto'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">md5</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> crypto<span class=\"token punctuation\">.</span><span class=\"token function\">createHash</span><span class=\"token punctuation\">(</span><span class=\"token string\">'md5'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">digest</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hex'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>然而，实际加载 crypto 模块可能需要 5ms 的时间。这个时间在初始化的时候就用掉了，但实际用到 crypto 模块的时间却可能还早（或者压根最终没触发）。考虑到 require 本身就有缓存的机制，将这一步骤放到第一次执行的时候再做，就可以省下这 5ms 的加载时间：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">md5</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'crypto'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">createHash</span><span class=\"token punctuation\">(</span><span class=\"token string\">'md5'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">digest</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hex'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当然，上面只是一些例子。真正在实际的项目中需要解决这一问题，第一步，就是知道有哪些代码在初始阶段被加载了，分别花了多长的时间。这看上去是一个挺麻烦的工作，但如果应用是使用 Webpack 进行打包的，那么问题就变得不那么麻烦了。</p>\n<p>Webpack 由于需要支持 HMR 以及 Dynamic Import，在编译的时候需要打包一个运行时进去，用于管理各个 Chunk 之间的引用（正因如此，Webpack 的打包体积往往会大于用 Rollup 打包的体积）。而正因为有了这个统一的运行时，使得模块间引用的耗时变得非常容易统计了。只需要在下面这行代码的前和后，分别用 Performance 进行一次打点计时，就可以很容易的知道每一个模块实际的加载耗时了。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">modules<span class=\"token punctuation\">[</span>moduleId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>\n  module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">,</span>\n  module<span class=\"token punctuation\">,</span>\n  module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">,</span>\n  __webpack_require__\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>修改后的代码大概如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> performance <span class=\"token operator\">!==</span> <span class=\"token string\">\"undefined\"</span><span class=\"token punctuation\">)</span> performance<span class=\"token punctuation\">.</span><span class=\"token function\">mark</span><span class=\"token punctuation\">(</span>moduleId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmodules<span class=\"token punctuation\">[</span>moduleId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>\n  module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">,</span>\n  module<span class=\"token punctuation\">,</span>\n  module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">,</span>\n  __webpack_require__\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> performance <span class=\"token operator\">!==</span> <span class=\"token string\">\"undefined\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">measure</span><span class=\"token punctuation\">(</span>moduleId<span class=\"token punctuation\">,</span> moduleId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">clearMarks</span><span class=\"token punctuation\">(</span>moduleId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">clearMeasures</span><span class=\"token punctuation\">(</span>moduleId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里需要加上 <code class=\"language-text\">typeof performance !== &#39;undefined&#39;</code> 的主要原因是，一些 loader（如 css-loader）可能会在 Node 环境执行运行时的代码，这种情况下不可以直接调用 Performance 相关的 API，会报错。</p>\n<p>由于 Webpack 基于 Tapable 架构的关系，要编写一个插件来修改 Webpack 原本的运行时代码也非常的容易。观察 Webpack 的<a href=\"https://github.com/webpack/webpack/blob/758269e81456c946a96b521ee936dbec99d07132/lib/MainTemplate.js#L196\">源码</a> 不难发现，只需要针对 <code class=\"language-text\">mainTemplate</code> 的 <code class=\"language-text\">require</code> 进行一些改动就可以了。同时，从 Webpack 的代码历史来看，上面这句代码前后的 Comment 一直都没有变过。于是，只需要找到模块引用前后的注释，用字符串替换的方式，插入这些新的性能打点语句就可以了。</p>\n<p>最终的代码可以参考 NPM 的库 <a href=\"http://npmjs.com/package/webpack-require-performance-plugin\">webpack-require-performance-plugin</a>，源码在<a href=\"https://github.com/laysent/webpack-require-performance-plugin\">这里</a>。</p>","frontmatter":{"date":"2019-10-08","title":"Webpack Require Performance","category":"Build"}}},{"node":{"id":"d2c713ba-83c1-5c25-8d75-4bb1aece6f6b","html":"<p>浏览器提供了 <code class=\"language-text\">performance</code> 用于测量 JavaScript 的一些运行效率，并在浏览器的对应位置（如 Chrome 的 Performance Tab）生成火焰图，可以方便的查看程序调用栈的执行效率。简单的操作如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getMarkName</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token string\">`mark: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">beginMark</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">mark</span><span class=\"token punctuation\">(</span><span class=\"token function\">getMarkName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">endMark</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> markName <span class=\"token operator\">=</span> <span class=\"token function\">getMarkName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    performance<span class=\"token punctuation\">.</span><span class=\"token function\">measure</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> markName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果 markName 无法被找到（也就是 beginMark 函数没有被调用）</span>\n    <span class=\"token comment\">// 那么程序在 performance.measure 的时候会报错</span>\n    <span class=\"token comment\">// 这里无需将报错抛出，直接吞掉就可以了</span>\n  <span class=\"token punctuation\">}</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">clearMarks</span><span class=\"token punctuation\">(</span>markName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">clearMeasure</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">beginMark</span><span class=\"token punctuation\">(</span><span class=\"token string\">'label name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 需要进行的操作</span>\n  <span class=\"token function\">endMark</span><span class=\"token punctuation\">(</span><span class=\"token string\">'label name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>具体来说，通过 <code class=\"language-text\">performance.mark</code> 函数标记一个点，然后在需要测量的程序执行完成之后，通过 <code class=\"language-text\">performance.measure</code> 来计算当前和最初 mark 的点之间的运行时间。最终，这一段结果会在 Chrome 的 Performance Timings 中形成对应的火焰图数据。</p>\n<p><code class=\"language-text\">performance.measure</code> 也支持三个参数的调用，三个参数分别是 label 的名称，起始 mark 的名称以及终止 mark 的名称。如果省略最后一个参数，那么终止的时间点就是当前 <code class=\"language-text\">performance.measure</code> 调用的时间点。</p>\n<p>最后，通过 <code class=\"language-text\">performance.clearMarks</code> 及 <code class=\"language-text\">performance.clearMeasure</code> 删除标记，清理不必要的内存使用。</p>\n<p>更多的介绍，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance\">MDN</a> 的文档。React 中也使用了类似的技术用于在 Performance 中生成每个 Component 渲染花费的时间，相关的代码可以参考 <a href=\"https://github.com/facebook/react/blob/50addf4c0e411e351de7290c8c60ec775c25c8c4/packages/react-reconciler/src/ReactDebugFiberPerf.js#L80\">ReactDebugFiberPerf.js</a>。</p>","frontmatter":{"date":"2019-09-30","title":"Performance Measure","category":"JavaScript"}}},{"node":{"id":"27ff91be-e0ae-5169-a594-b6e813c36527","html":"<p>JavaScript 中提供了 <code class=\"language-text\">devicemotion</code> 事件，可以用于监听设备各个方向上受到的力（加速度）。有了这个事件，就可以用于判断当前用户是否在进行类似“摇一摇”之类的操作，方便开发基于特定交互的一些功能。</p>\n<p>具体来说，<code class=\"language-text\">devicemotion</code> 事件会提供 <code class=\"language-text\">accelerationIncludingGravity</code> 数据，作为一个对象分别提供 <code class=\"language-text\">x</code>，<code class=\"language-text\">y</code> 和 <code class=\"language-text\">z</code> 三个方向上的加速度。通过不同时间点上加速度值的不同，就可以判断当前用户是否在进行摇晃手机的操作了。</p>\n<p>使用 <code class=\"language-text\">devicemotion</code> 的示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>accelerationIncludingGravity<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// do stuff here</span>\n<span class=\"token punctuation\">}</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'devicemotion'</span><span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>判断是否在摇晃手机，简单来说，只需要判断当前的各方向加速度之差，是否有至少两个超过了给定的阈值。<a href=\"https://github.com/alexgibson/shake.js\">shake.js</a> 中就使用了这样的方法来判断当前用户是否在摇晃手机，具体的代码可以参考<a href=\"https://github.com/alexgibson/shake.js/blob/d232eee7a5f31e9fd37aa79aa83f1f206035ccc9/shake.js#L104\">源码</a>。</p>\n<p><code class=\"language-text\">devicemotion</code> 更多的信息，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/devicemotion_event\">MDN</a>。</p>","frontmatter":{"date":"2019-09-29","title":"Mobile Shake","category":"JavaScript"}}},{"node":{"id":"c2ac584c-7986-51ff-af03-f2ebb8edf03d","html":"<p>在 Webpack 的编译过程中，可以通过 <code class=\"language-text\">devtool</code> 的配置选项选择以什么样的形式输出 SourceMap。Webpack 提供了非常多的选择方案，不同的选项可以达到的效果是不一样的，也会极大的影响最终编译的时间。Webpack 的官方<a href=\"https://webpack.js.org/configuration/devtool/\">文档</a>，从编译时间、重编译时间（针对 Watch 下的修改重编译）以及最终的使用效果三个纬度，给出了各个配置选项的实际效果。（中文版文档在<a href=\"https://webpack.docschina.org/configuration/devtool/\">这里</a>）</p>\n<p>一般情况下：生产环境最终的打包，建议使用 <code class=\"language-text\">source-map</code> 作为配置。这种配置会将 SourceMap 文件打包到另外一个独立的文件中，线上代码不会暴露源文件，同时提供了最精细的代码映射关系，方便线上代码的调试和问题定位。当然，这种配置的缺点也非常明显，就是构建过程比较花费时间，因此一般只建议在最终要上线的版本中使用这种配置。</p>\n<p>对于开发环境 Watch 模式下打包 Hot Reload 的版本，建议使用 <code class=\"language-text\">eval-source-map</code> 或者 <code class=\"language-text\">cheap-module-eval-source-map</code>。这两种模式，都会将代码用 <code class=\"language-text\">eval</code> 函数包裹起来，重编译的速度比较快，区别主要在于 SourceMap 的生成方案。前者会生成高品质的 SourceMap，因而初次构建的速度会比较慢，但是提供了行和列的映射；后者只提供了行层面的代码映射，因此会更加快一些，但是断点的效果会略打折扣（无法提供到列的映射关系）。</p>\n<p>更多的类型以及各种情况的说明，可以参考官方文档（链接在上面给出）。</p>","frontmatter":{"date":"2019-09-27","title":"SourceMap in Webpack","category":"Build"}}},{"node":{"id":"57f77e04-3b60-51bb-8fbf-1b73e3c87fb7","html":"<p>优化的第一步，是知道瓶颈在哪里。</p>\n<p>在针对 Webpack 编译速度优化的过程中，知道哪些 loader / plugin 运行耗费了很多时间就显得非常重要了。</p>\n<p>Speed Measure Plugin 是一款针对 Webpack 的插件，只需要一些非常简单的操作，插件就可以在已有配置的基础上，给 Webpack 的打包过程增加必要的计时功能，同时清晰的列举出各个 loader / plugin 在本次编译中的耗时情况。Plugin 的文档在<a href=\"https://github.com/stephencookdev/speed-measure-webpack-plugin#readme\">这里</a>。</p>\n<p>简单来说，只需要在原有的配置基础上，这么额外包一层 Speed Measure Plugin 就可以了：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> SpeedMeasurePlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"speed-measure-webpack-plugin\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> smp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SpeedMeasurePlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> disable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> smp<span class=\"token punctuation\">.</span><span class=\"token function\">wrap</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，<code class=\"language-text\">disable: false</code> 表示需要 Speed Measure Plugin 记录时间，这也是默认的值，可以不传。如果赋值是 <code class=\"language-text\">true</code>，那么就会告知 Speed Measure Plugin 不要做任何处理，结果等同于没有使用 Speed Measure Plugin。如果需要经常对 Webpack 的打包进行优化，可以将 Speed Measure Plugin 的代码写入到库中，并通过环境变量等方法在打包的时候开启或关闭这个记录的功能。</p>","frontmatter":{"date":"2019-09-26","title":"Webpack Speed Measure","category":"Build"}}},{"node":{"id":"783fc4da-adbf-5fd4-93e3-a9f67e54aa99","html":"<p><code class=\"language-text\">mochawesome</code> 是为 Mocha 提供的一个 Report 库，可以用于生成不错的 HTML 报告（见 <a href=\"https://www.npmjs.com/package/mochawesome\">npm</a>）。库本身提供了一个 <code class=\"language-text\">addContext</code> 的 API，可以用于在运行 Test 的时候，存入额外的信息到 Context 中，最终在生成 HTML 报告的时候，将这部分 Context 信息写入对应的测试用例内。</p>\n<p>参考代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> addContext <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mochawesome/addContext'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test suite'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'unit test'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addContext</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'content'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// or</span>\n    <span class=\"token function\">addContext</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      title<span class=\"token punctuation\">:</span> <span class=\"token string\">'title'</span><span class=\"token punctuation\">,</span>\n      value<span class=\"token punctuation\">:</span> <span class=\"token string\">'value or object'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>几点说明：</p>\n<ol>\n<li>在 <code class=\"language-text\">beforeEach</code> 或 <code class=\"language-text\">afterEach</code> 的钩子内调用 <code class=\"language-text\">addContext</code> 也是允许的；</li>\n<li>如果给定的第二个参数是 URL 或是一个图片的话，<code class=\"language-text\">mochawesome</code> 可以有相对应的展示；</li>\n<li>记得 <code class=\"language-text\">it</code> 函数的第二个参数不要使用箭头函数，否则 <code class=\"language-text\">this</code> 的指向会有问题</li>\n</ol>\n<p>然而，在 Cypress 中如果试图直接使用上述方法运行代码，会发现并不能成功。最终生成的报告内并没有对应的 context 信息。其原因在于，Cypress 在运行的过程中，原本被赋值的 <code class=\"language-text\">context</code> 属性被覆盖掉了，导致虽然进行了 <code class=\"language-text\">addContext</code> 的赋值，但是最终的结果中并没有保留这部分数据。</p>\n<p>一个可行的解决方案是，在 <code class=\"language-text\">test:after:run</code> 事件中再进行赋值，保证结果生效。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> addContext <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mochawesome/addContext'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nCypress<span class=\"token punctuation\">.</span>Commands<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'addContext'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">content</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  cy<span class=\"token punctuation\">.</span><span class=\"token function\">once</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test:after:run'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">test</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> test <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>几点说明：</p>\n<ol>\n<li>因为 <code class=\"language-text\">addContext</code> API 本质上就是往 <code class=\"language-text\">test</code> 对象上写 context 数据，而 Cypress 的 API 正好提供了 test 对象，因而第一个参数不需要传 <code class=\"language-text\">this</code>，直接将 test 以合适的方法传入就可以了；</li>\n<li>上面的代码定义了一个 Cypress 的命令方便各个地方调用，类似的代码改成一个普通的函数也是可以的；</li>\n<li>需要用 <code class=\"language-text\">cy.once</code> 保证这个代码只会被调用一次，这样其他的测试用例中不会有类似的数据被写入</li>\n</ol>","frontmatter":{"date":"2019-09-25","title":"Add Context in Mochawesome Report","category":"Cypress"}}},{"node":{"id":"1b9a898d-4d6f-5201-8c9a-05733edf90ee","html":"<p>在用 React 处理业务的过程中，经常会遇到这样的场景：某一个 UI 需要等待网络请求来展示，在等待的过程中，需要显示 Loading 界面，并在请求完成后，显示真正的 UI。这种情况，和按需加载模块的行为非常类似。既然 React.Suspense + React.lazy 可以组合用于按需加载模块时候的 UI 展示，那么是否可以使用同样的组合来完成类似等待网络请求的 UI 显示呢？答案是肯定的。下面给出一个示例代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">time</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fakeFetch</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">\"finished!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> Component <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">fakeFetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">text</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">default</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>text<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"App\"</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>React<span class=\"token punctuation\">.</span>Suspense fallback<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>loading<span class=\"token operator\">...</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello World<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>Component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>React<span class=\"token punctuation\">.</span>Suspense<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如此一来，在 Promise 没有返回的时候，组件会显示 <code class=\"language-text\">&lt;div&gt;loading...&lt;/div&gt;</code>。而等到 Promise resolve 之后，就会显示真正的 UI。</p>\n<p>几点说明：</p>\n<ol>\n<li><code class=\"language-text\">React.lazy</code> 本身是为 <code class=\"language-text\">import()</code> 设计的，所以在 Promise 返回的时候，需要将组件放到 <code class=\"language-text\">default</code> 属性下面，保持和 <code class=\"language-text\">import()</code> 的行为一致；</li>\n<li><code class=\"language-text\">React.Suspense</code> 和 <code class=\"language-text\">React.lazy</code> 的组合，本质上内部是使用了 <code class=\"language-text\">throw</code> + <code class=\"language-text\">componentDidCatch</code> 的方式进行实现的，因而如果不使用 <code class=\"language-text\">React.lazy</code>，直接在组件内 <code class=\"language-text\">throw Promise</code>，也可以达到类似的效果：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fakeFetch</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">fn</span> <span class=\"token operator\">=></span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"finished!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> data <span class=\"token operator\">=</span> <span class=\"token string\">\"before\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Component</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data <span class=\"token operator\">===</span> <span class=\"token string\">\"before\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token function\">fakeFetch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newData</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      data <span class=\"token operator\">=</span> newData<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"App\"</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>React<span class=\"token punctuation\">.</span>Suspense fallback<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>loading<span class=\"token operator\">...</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello World<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>Component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>React<span class=\"token punctuation\">.</span>Suspense<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-09-24","title":"Suspense & Lazy in React","category":"JavaScript"}}},{"node":{"id":"6e987333-0e0f-57fb-8f42-eaa464ad5564","html":"<p>一般情况下，只有当用户有操作的情况下，在一个 tick 里，JavaScript 通过 <code class=\"language-text\">window.open</code> 或是 <code class=\"language-text\">&lt;a target=&quot;_blank&quot;&gt;</code> HTML 元素直接 <code class=\"language-text\">click</code> 打开新的窗口才能正常弹出。如果一旦涉及到异步的操作，弹框就会默认被浏览器阻止，无法正常显示。</p>\n<p>这样设计的初衷，是为了防止前端随意弹框，影响到用户正常的体验。然而，在某些情况下，用户操作后需要经过网络请求，返回结果后才知道应该如何展示弹框。这种情况下，简单的 <code class=\"language-text\">fetch().then(() =&gt; window.open())</code> 肯定是不行的。需要一些 Hack 的方案，如下。</p>\n<p>在用户进行了操作之后，首先先打开一个新的窗口，等到异步操作返回之后，再通过 JavaScript 修改这个窗口的地址，从而达到异步打开窗口的目的。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">element<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onclick</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> win <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 模拟异步操作</span>\n  <span class=\"token keyword\">await</span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  win<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> <span class=\"token string\">'actual location'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这样操作可能的问题及解决方法：</p>\n<ol>\n<li>如果在异步的过程中本窗口被关闭了，就会留下一个空白的新窗口。因而，需要监听 <code class=\"language-text\">beforeunload</code> 事件，以保证必要时候可以关闭新打开的窗口；</li>\n<li>如果异步的时间比较长，打开一个空白的窗口用户体验较差（打开后默认会获得焦点）。这种情况下，可以打开一个静态的页面，展示一个 loading 的 UI 以告诉用户当前正在进行的操作。待异步操作完成，再通过 postMessage 等方式通知窗口进行页面的跳转。</li>\n</ol>","frontmatter":{"date":"2019-09-23","title":"Open Window Async","category":"JavaScript"}}},{"node":{"id":"f512f692-4d3c-5bbc-9056-f9b0b5e9a702","html":"<p>在实际的开发过程中，经常有多分支并发操作的情况，比如：</p>\n<ol>\n<li>PC 软件需要维护多个版本，在新的版本分支上开发新功能，同时维护旧的版本以修复问题；</li>\n<li>针对 Gerrit 这类只允许单 commit 迁入的工具，一个版本开发多个功能，可能需要分成多个分支同时进行</li>\n</ol>\n<p>这种情况下，在版本间切换往往有两个常见的方式：</p>\n<ol>\n<li>将当前的代码 stash 后，切换分支，进行对应的处理，处理完了再回到原来的分支 <code class=\"language-text\">git stash pop</code> 继续原先的开发工作；</li>\n<li>直接 <code class=\"language-text\">git clone</code> 一个新的仓库，在上面完成必要的工作</li>\n</ol>\n<p>第一种方案的问题主要是，切换多次的话，很容易搞不清楚当前分支下还有哪些是 stash 的，管理起来有点麻烦。有时候方便起见，也会直接将当前的内容 commit 到分支上，再进行切换。考虑到 git hook 的存在，commit 可能还需要加上 <code class=\"language-text\">--no-verify</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> <span class=\"token function\">add</span> -A <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> commit -m <span class=\"token string\">\"wip\"</span> --no-verify</code></pre></div>\n<p>第二种方案的问题主要是，多个文件仓库重复下载了多次 <code class=\"language-text\">.git</code> 目录，在一些大型项目中，这里会导致大量的硬盘空间被浪费。</p>\n<p>Git 在 2.5 版本中提供了 worktree 的功能，用于解决这一痛点。在一个 Git 项目中，只需要执行如下的命令，就可以新创建一个文件仓库：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree <span class=\"token function\">add</span> -b new-branch-name /path/to/folder origin/branch/name</code></pre></div>\n<p>新创建的文件仓库被放在 <code class=\"language-text\">/path/to/folder</code> 中，使用的仓库名称是 <code class=\"language-text\">new-branch-name</code>，基于 <code class=\"language-text\">origin</code> 上的 <code class=\"language-text\">branch/name</code>。如果只需要使用一个已经存在的分支，可以简化成：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree <span class=\"token function\">add</span> /path/to/folder local/branch/name</code></pre></div>\n<p>之后，在 <code class=\"language-text\">/path/to/folder</code> 中就可以进行常规的开发了。值得一提的是，原 Git 目录下的 Hook 文件也会一并同步到新的工作目录下，可以直接使用。通过查看目录下的文件，不难发现 Git 的同步方式。事实上，在 WorkTree 目录下，并没有一个 <code class=\"language-text\">.git</code> 目录，取而代之的，只有一个 <code class=\"language-text\">.git</code> 文件，里面标注了真正的 <code class=\"language-text\">.git</code> 目录应该去那里查找。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">gitdir: /path/to/actual/.git/worktrees/name</code></pre></div>\n<p>也正因为如此，WorkTree 下所有的 Git 配置都是同步的。</p>\n<p>如果需要查看当前的 Git 中到底有多少个 WorkTree，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree list</code></pre></div>\n<p>命令会列出所有 WorkTree 的目录以及当前使用的分支名称。</p>\n<p>在开发完成后，如果希望删除 WorkTree，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree remove /path/to/folder</code></pre></div>\n<p>删除完成后，可以通过 <code class=\"language-text\">git worktree list</code> 来检查是否真的被删除了。</p>\n<p>延伸阅读：</p>\n<ul>\n<li><a href=\"https://git-scm.com/docs/git-worktree\">官方文档</a></li>\n<li><a href=\"https://spin.atomicobject.com/2016/06/26/parallelize-development-git-worktrees/\">Parallelize Development Using Git Worktrees</a></li>\n<li><a href=\"https://www.saltycrane.com/blog/2017/05/git-worktree-notes/\">git worktree notes</a></li>\n</ul>","frontmatter":{"date":"2019-09-22","title":"Git Worktree","category":"Git"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}