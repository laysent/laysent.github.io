{"componentChunkName":"component---src-pages-til-js","path":"/til/","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"202b1c1f-e486-5449-863c-b7cad49cf68a","html":"<p>在使用 TypeScript + Webpack 的项目中，可能会遇到如下类似的报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in ./src/xxx.tsx 346:0-62\n&quot;export &#39;xxx&#39; was not found in &#39;./xxxx&#39;</code></pre></div>\n<p>这类报错出现的情况是，在 <code class=\"language-text\">./scr/xxx.tsx</code> 文件中，先 <code class=\"language-text\">import</code> 了一个类型定义，然后又将这个类型定义重新 <code class=\"language-text\">export</code> 出去了。产生报错的原因在于，TypeScript 的文件需要通过 loader（无论是 babel-loader 还是 ts-loader）转化成 Webpack 可识别的 JavaScript 文件。在转化之后，TypeScript 中定义的纯类型（如 interface）都丢失了。正因为这些类型丢失了，在试图重新 <code class=\"language-text\">export</code> 的时候，Webpack 就无法找到对应的定义，只能报错（Warning）了。</p>\n<p>可以考虑通过以下的方案避免警告：</p>\n<ol>\n<li>将所有的类型定义放到单独的文件（比如 <code class=\"language-text\">types.ts</code> 中），然后通过 <code class=\"language-text\">export * from &#39;types.ts&#39;</code> 一次性将所有内容 export 出去（这样可以避免具体声明需要 export 的内容）；</li>\n<li>重新在当前文件中定义一个类型，然后将这个类型 export 出去：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Type <span class=\"token keyword\">as</span> _Type <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./type'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> Type <span class=\"token operator\">=</span> _Type<span class=\"token punctuation\">;</span></code></pre></div>\n<p>在 TypeScript 3.7 之前，上面的代码可以简写为：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Type <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./type'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> Type <span class=\"token operator\">=</span> Type<span class=\"token punctuation\">;</span></code></pre></div>\n<p>在 3.7 及之后的版本中，必须保证新定义的类型名称和原来的类型名称不同。这是因为在 TypeScript 3.7 中对类型定义做了调整，在提供更强大的递归引用类型功能的同时，不再允许定义同名的类型。相关的介绍，可以查看官方的<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#more-recursive-type-aliases\">发布文档</a>。</p>","frontmatter":{"date":"2019-12-05","title":"Export was Not Found","category":"TypeScript"}}},{"node":{"id":"6f7bce64-d072-5ef5-abd7-98cd4c6118b3","html":"<p>要知道一个网页中的文本，具体是使用什么字体渲染出来的，并不是非常简单的事情，可以有以下一些方案进行尝试。</p>\n<section><h2>getComputedStyle</h2><p>使用 <code class=\"language-text\">window.getComputedStyle</code> 属性获取对应元素的 <code class=\"language-text\">font-family</code> 字段。因为字体的设置一般是通过顶层配置，子元素继承的方式完成的，因此在大多数的元素上，并没有 <code class=\"language-text\">font-family</code> 设置。即使有，大概率也是通过 CSS 完成的，因此从 <code class=\"language-text\">.style</code> 或者 <code class=\"language-text\">.attributeStyleMap</code> 无法拿到需要的数据。<code class=\"language-text\">getComputedStyle</code> 可以获取当前元素上样式的最终计算值，因此即使字体实际来自于继承或者系统默认字体，都可以通过该 API 获取到。比如，在一个没有 CSS 设置的页面上，可以通过下面的代码知道具体使用的系统默认字体是什么：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">window<span class=\"token punctuation\">.</span><span class=\"token function\">getComputedStyle</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>fontFamily<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// MacOS (Chrome): Times</span>\n<span class=\"token comment\">// Windows (Chrome): Microsoft YaHei</span></code></pre></div><p>非编程的方案，可以在 Chrome DevTools 中直接找到 Elements 下的 Computed 部分，查看实际使用的 CSS 属性值。注：如果 <code class=\"language-text\">font-family</code> 并没有被定义过，可以勾选 All 来查看系统默认的属性值。</p><p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2f6b9b41cfadb16613696e96a940262e/cb0d3/2019-12-04-computed-style.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 130.95975232198143%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAABYlAAAWJQFJUiTwAAAD40lEQVRIx5WVi2/aVhjF+Uv336ybFjKSNMnWbR1dq6pb1ocqVVMndWuabqFZIh62IZSHedoY24BtwOAXZ9+9EAYk1VpLB/va3OPfvd/1uTHXddFut1EsFlEqlTAYDKB1VOQlAYW8CLlawXg0Qr3egCSJME0ThmHw84juO47Dxfr1ej3EuIGmodPpoKt1oOs6qi0TUrmNS7mDgtyF0u1B73b5i9lz1rHf73MT27ZhWRZvM8UajQYymQw3VDUDFxkRZ2kJqQsBTdVEvalAlPKQ5Srevy8in5egKHNjBjIcDrnplWKe52E6nXIZtgfN8qDbPp199IYBgsCH7/vwvIX8FVHfTcVw0xF59BMAMx9R4GEW+iRvTez+TUdsNpthKboRei5aJ0mkn+9C/uM79M9+gn6ahJFKwkzdo/M99E7vwkw/5f9f609aErIGh/MnUI73UX71JaTfvoB5tgcnvY/B+W3YF/v82kxtQ0vdX/a76ssJNw1DbwLt7SE0cR9/v72FdOoWikIc8mWC9DUqhV30hD0yfPDxhuqbA7TEBB78voOthwfYe3yA5Mvvcfflj3iR2oOajn+aoXJMhsI2Hh0nkXj2DIknjxA/eoivjh7j+V930ElvoXP6CYbaySEU6TZSmS2c57bwTy6Oc4GJXW+jm91F991HGrKitGnIjkTKf0vnb2CJh1w2XQ8LdzDI7KLzoSGvlnxOOIZGVe4eJ6C/2eHSXieovbNoE92fcRjv7vNlg81ls/mGKAzg6jI8s/afDGrr1YUqXK5Rx2xldNfWYRRFcy3MZ/+jqz7XvhSWGCalx9KQFBIlF33HIZsGpYrw9RHCFz8g/HUX0eefIfplGz49sxZptUwbhxKiT9kW0MceBswoXBd7wdRFaCgI60WEpTSCVz/Dz57AJ1SWlSwfWaTxtDFbLYwokgYUYXa5jAklhjuZzEXhyzWZwvVpbsMILBKafQdCpU5G5iKJVtKmryoY5/MYCgJ8wmeUAZkt6VZpA5ZAEQ9bQZCIyOGFCFZGFtObDViZNCwhB7t4yc+WKGA86GNCGTkhwgm9YLIgZkTliox6o8mJ3JXnTLGBqmIsinzYbqOOMe0rXr/Hq705n0EY8krKtL+0FXW+bjf+E9Mbc8JBLgunViNCAQ7FPadbefMVISteqVzlhIz2ZkJJwpCG6ZIhI+TV3pw/RsjmkA5m1mi2rq8IRmjQTuaQoV0uwcpmiE5em7dNQjZvakdDJieiVKEvx5tuENJuxwgZ3Yh2NZeK9CFCJvbtdnUDWapyrd7kVV4jNInQpqI4NXk5H8v1d4PY7qjTQs4XiqjKNd5eff4vE5Ka/A6hyHoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Screenshot of Chrome DevTools > Elements > Computed\"\n        title=\"\"\n        src=\"/static/2f6b9b41cfadb16613696e96a940262e/b9e4f/2019-12-04-computed-style.png\"\n        srcset=\"/static/2f6b9b41cfadb16613696e96a940262e/cf440/2019-12-04-computed-style.png 148w,\n/static/2f6b9b41cfadb16613696e96a940262e/d2d38/2019-12-04-computed-style.png 295w,\n/static/2f6b9b41cfadb16613696e96a940262e/b9e4f/2019-12-04-computed-style.png 590w,\n/static/2f6b9b41cfadb16613696e96a940262e/cb0d3/2019-12-04-computed-style.png 646w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p></section>\n<section><h2>Rendered Fonts</h2><p>使用 <code class=\"language-text\">getComputedStyle</code> 只能得到实际使用的 CSS 属性值，有时候并不能准确表达实际真实使用的具体字体类型。</p><p>举例来说，一个 <code class=\"language-text\">font-family</code> 定义可能是：</p><div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">body</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span>\n    <span class=\"token string\">'Rubik'</span><span class=\"token punctuation\">,</span>\n    -apple-system<span class=\"token punctuation\">,</span> <span class=\"token string\">'system-ui'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'BlinkMacSystemFont'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'PingFang SC'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Segoe UI'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Roboto'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Oxygen'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Ubuntu'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Cantarell'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Fira Sans'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Droid Sans'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Helvetica Neue'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Helvetica'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Arial'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Hiragino Sans GB'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Microsoft Yahei'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'WenQuanYi Micro Hei'</span><span class=\"token punctuation\">,</span> sans-serif；\n<span class=\"token punctuation\">}</span></code></pre></div><p>在如此众多的定义中，具体浏览器使用了哪一款字体，并不容易知道。这其中涉及到了大量的变量。用户使用的系统环境、字体下载情况、正在阅读的文字是中文还是英文等，这些都有可能影响到最终浏览器所选用的字体。甚至在不复杂的 <code class=\"language-text\">font-family</code> 设置下，最终的选用字体依然可能并不直观。举例来说，如果设置 CSS 为：<code class=\"language-text\">font-family: system-ui</code>，具体使用的字体并没有从设置的字段中直观的反馈出来。</p><p>Chrome DevTools 提供了一个 Rendered Fonts 功能，可以帮助开发者了解当前真实使用的字体。示意图如下：</p><p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dc6b98d142218bfc4e588ffbe34ab2d0/26dcc/2019-12-04-rendered-fonts.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 538px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 187.36059479553904%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAlCAYAAABCr8kFAAAACXBIWXMAABYlAAAWJQFJUiTwAAAFB0lEQVRIx51WyW4bRxCdjw5yygfkB5KD7zkFCAIYQbwFgeEttixS3HeJ5HAdchbOvvLlVZMjUbJkC27goXt6ZqpreVXVWhAE2Gw26PV6GI1GGA6H0HUdnh9gZjj4XO/hvN5HpdHHYLyC4/pYr1YIwxDyr+d52O12sCxLydGWyyUGgwEmk4l6sd0YuLocot/voUohnaGO+cZFpTnEh/M2qvUWut0uqtUqarUarq6ulKDFYqGEa9vtVmk36PdhmhauZgZqrQEq9S7RRrM7xMa00e92UK9dUFgHrVZLCRSMx2Ol3Ypa+74PLc9zlCPNcpgB4EQH7GLAljks8NAoigJZll3Pmmzu93tCrbAvMs65Whd5gjyLOadI0+QWkkSQqn9Ph3YQdtiUE1zXw2K1wehqBj/kT+keYZwjIuK0QJwckGYFgxJSeIobpfY3GsoQ813XRaf+Bp/fP8V08B/MRQ3bWRXm/AIW1/JsLWswZnX4DEKaZTiVcUug+MG2LTjT59Dbf6BX+R3R6iUK818k65dIN6+QGv8g5+zpTxlEg0oUDwvMRaBlwtFfIfaXGF1ekgFdzGa68qP4MxP/RQ682QtY5gbZ1wQWxZ4UOAiMfAMrw8RkqqM/GMFxdjBJDz+IKNA7CvyGhiJwu93AHL9A6K4YkAxbc0vyjrE2eMB6Ta4FCDybbnnGJFg9wmT60J6+Qp44KsLCzYwRTdJyZoSTEO7s5eNNdvVn2NtvkFsfUNgfkJrvkJnvkXOtYL1FMP/r2yYfaLODMT2DM38He0ZwtvS3CuqZkHfG5D1z36HW+W2Bd4kdhpEyL4i4FsQZCZ4iIGQdHvfjhGSPoq8TW+YojhETScI5KdfJzd7JHFKgcPcLDcsNeVme9BjcNzQpkpZpImLBFB+K2QK1Vs/59b7MYqJAtJYia9ukkOOolBVoATcnrNA+1T+q+mCpuquVPM/nM2bSTNVDg1zVRGrIhT+dIuBJEUuSaCsOP4VYIi5pt9t4/fo1ib7BJQlv2w7Jb1LgmpSzoRlkv91swm2werD6xqy6ydGkU0gQZEi1/vvZc3S6fZWWko4GW4BkkgjXXPYRj/0jYAvwW01E1DSnQIFoJH4rISa6no/Fco2pPlN7KsongdWkg1ntFmz2ix2ri/nxI6xKBTtqGx5NLRHHkTKt0WxTwx5anS4Lx1AV5fIbRZuc2ZFRdcGpw++jSRwnLBKG4ut932oBfebQ0Q59s2P3c6Wdsk0GrMaioVCj7MHiS302R6PVVi2z3C+/EWgZfeV3OtidfYLXaChfevUaYgYr54klL7NjqZ/Pl8rkIs9v8baEllB1f0Q/NBvwhwNWkTmCxRwhfZsKkZPkmsgSgDUPavaGvFn41yQ/hSacC8ijgA0/pBkxT4n4QuGEj2J+HAbYRTHmrRqW0wn34i/4eqg2pXPvOPh2Rz9eCFYT4O2fN1l1ty/jUeP4U+gBv/0MRMGDX2oWk1vYLrMwXa2ZQnJxKqMoDT0MfGS//ICw9g4iLjhG+S60erOFT2fn+Fyp4rxygWa7g8pFDbV6U1Vvhwfs2EeSX39E/OQn2BTmsHE5PFCqjKUUuIEmoV6S/XNexwTS2URbOU0iqa541NhsVeCy38heeSf074m0un1VLuoqjc7Oq7igZv3hSHFMTB9djjEYXmKoL7DZmtiwCMxJLYFJdnzhw/1X6t+jwnUnPbXvLf8PtQHte4Q8BFHqf1USFQCODxGiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Screenshot of Chrome DevTools > Elements > Computed > Rendered Fonts\"\n        title=\"\"\n        src=\"/static/dc6b98d142218bfc4e588ffbe34ab2d0/26dcc/2019-12-04-rendered-fonts.png\"\n        srcset=\"/static/dc6b98d142218bfc4e588ffbe34ab2d0/cf440/2019-12-04-rendered-fonts.png 148w,\n/static/dc6b98d142218bfc4e588ffbe34ab2d0/d2d38/2019-12-04-rendered-fonts.png 295w,\n/static/dc6b98d142218bfc4e588ffbe34ab2d0/26dcc/2019-12-04-rendered-fonts.png 538w\"\n        sizes=\"(max-width: 538px) 100vw, 538px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p><p>Chrome 会将当前选中元素真实使用的所有字体都列出来。需要注意两点：</p><ol>\n<li>需要选中一个有文字内容的元素，不然这里并不会显示；</li>\n<li>\n<p>选中的文字内容可能需要多种字体类型共同配合渲染，Chrome 会讲所有用到的元素都列举出来。</p>\n<p>比如，<code class=\"language-text\">笑，😊，smile</code> 这样一段文字，在 MacOS Chrome 下，默认就需要以下三种字体来进行渲染：</p>\n<ul>\n<li>Times（渲染英文）</li>\n<li>Songti SC（渲染中文）</li>\n<li>Apple Color Emoji（渲染 emoji）</li>\n</ul>\n<p>以上三种字体在 Rendered Fonts 中都会被列举出来。</p>\n</li>\n</ol><p>Chrome 的 Blog 介绍可以查看<a href=\"https://developers.google.com/web/updates/2013/09/DevTools-answers-What-font-is-that\">这里</a>。</p><p>这一方案暂时没有 JavaScript API 可以直接调用，无法在程序运行时进行自动的判断。</p></section>","frontmatter":{"date":"2019-12-04","title":"Rendered Fonts","category":"Chrome"}}},{"node":{"id":"ddf203aa-1bf8-5e71-9ad4-a9dbe9bd9530","html":"<p>在 JavaScript 中，直接定义一个对象（Object），性能上远不如定义一个 <code class=\"language-text\">JSON.parse()</code> 的表达式。具体来说，下面的两行，<code class=\"language-text\">JSON.parse</code> 的表达式会有更好的性能表现：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> slow <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> foo<span class=\"token punctuation\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> bar<span class=\"token punctuation\">:</span> <span class=\"token number\">1337</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fast <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token string\">'{\"foo\":42,\"bar\":1337}'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>同样的效果，但是在 JavaScript 引擎中的表现却差别很大。根据<a href=\"https://github.com/GoogleChromeLabs/json-parse-benchmark\">这里</a>给出的测试数据，<code class=\"language-text\">JSON.parse</code> 的速度是直接写对象速度的 1.7 倍。而且这不仅仅只是 V8 表现上的不同，在各类 JavaScript 引擎上都有类似的表现，性能差异均非常明显（<a href=\"https://developer.apple.com/documentation/javascriptcore\">JavaScriptCore</a> 的性能差异可以到两倍）。</p>\n<p>这里差异的主要原因在于，引擎在解析时候算法复杂度有着巨大的差异。简单来说，JSON 的数据结构是非常简单且固定的，因而在解析的时候可以有更好的表现。这种简单体现在以下几个方面：</p>\n<ol>\n<li>JSON 的数据支持类型不多，只有字符串，数组，数字，NULL，对象这几种；相比之下，JavaScript 中一个对象的支持类型非常的复杂，情况更多；</li>\n<li>从抽象语法树（AST）的角度看，<code class=\"language-text\">JSON.parse</code> 的情况比单纯写一个 JavaScript 对象要简单的多。对于前者来说，就是一个 CallExpression 和一个 StringLiteral；而对于一个 JavaScript 对象来说，涉及到大量的 ObjectExpression，当中可能还包含 StringLiteral，NumericLiteral，Identifier 等等；</li>\n<li>JSON 的解析是上下文无关的；而 JavaScript 对象的解析却需要结合当前的上下文（context）来确定；</li>\n</ol>\n<p>举一个例子来说明：假设有这样一个 JavaScript 代码片段：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> y <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> x <span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里的 <code class=\"language-text\">x</code> 代表什么含义，其实有非常多的可能性，比如：</p>\n<ul>\n<li><code class=\"language-text\">const y = ({ x })</code>，此时 <code class=\"language-text\">x</code> 的值和上下文中的 <code class=\"language-text\">x</code> 变量是相关的，定义是一个 JavaScript 对象；</li>\n<li><code class=\"language-text\">const y = ({ x } = { x: 2 })</code>，此时 <code class=\"language-text\">x</code> 和上下文是相关的，但定义的是一个赋值语句，而不是对象（根据语法，对 <code class=\"language-text\">const</code> 二次赋值导致语法错误）；</li>\n<li><code class=\"language-text\">const y = ({ x }) =&gt; x;</code>，此时 <code class=\"language-text\">x</code> 的值和上面的 <code class=\"language-text\">x</code> 无关，是一个函数的参数；</li>\n</ul>\n<p>换句话说，当 JavaScript 引擎在解析一个 JavaScript 对象的时候，需要考虑很多的可能性，在解析的过程中很可能无法确定当前的类型，甚至连语法是否正确也不能确定。但反观 JSON，定义就简单的多，在解析的当下，引擎就可以很清楚的知道当前的内容是一个数组，还是一个对象，亦或是有语法错误。</p>\n<p>除了上述提到的性能比较数据之外，<a href=\"https://joreteg.com/blog/improving-redux-state-transfer-performance\">这里</a>还有一份针对 Redux 应用的优化分析。数据显示，使用 <code class=\"language-text\">JSON.parse</code> 调用之后 TTI (Time To Interactive) 时间缩短了 0.74s (18%)。考虑到整个改动是非常“简单”的，这一性能提升显得非常客观。</p>\n<p>这里之所以说改动是非常“简单”的，是因为整个优化思路非常的明确，完全可以通过对应的工具在编译时完成。目前开源社区已经提供了各类相关的工具，可以直接使用，列举一些如下：</p>\n<ul>\n<li>Webpack（<a href=\"https://github.com/webpack/webpack/releases/tag/v4.35.3\">v4.35.3</a> 或以上）默认会将 JSON 打包成 <code class=\"language-text\">JSON.parse()</code>；使用 <code class=\"language-text\">json-loader</code> 可以去掉这一优化（具体见这个 <a href=\"https://github.com/webpack/webpack/pull/9349\">Pull Request</a>）；</li>\n<li>一些 Babel Plugin 支持将满足要求的 JavaScript 对象转化成 <code class=\"language-text\">JSON.parse</code> 语法，比如 <a href=\"https://github.com/nd-02110114/babel-plugin-object-to-json-parse\">babel-plugin-object-to-json-parse</a> 或 <a href=\"https://github.com/keyz/babel-plugin-transform-optimize-object-literal\">babel-plugin-transform-optimize-object-literal</a>。</li>\n</ul>","frontmatter":{"date":"2019-12-03","title":"Cost of parsing JSON","category":"JavaScript"}}},{"node":{"id":"1f47e54e-3226-5831-b830-c394c36ddda6","html":"<p>Node.js 的 Docker 有基于 Alpine 的版本。在这个 Docker 中使用 <a href=\"https://github.com/develar/7zip-bin\">7zip-bin</a> 库的时候遇到了错误，无法正常启动。</p>\n<p>一个简单的重现 <code class=\"language-text\">Dockerfile</code> 可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>10<span class=\"token punctuation\">-</span>alpine\n\n<span class=\"token keyword\">RUN</span> mkdir <span class=\"token punctuation\">-</span>p example &amp;&amp; \\\n  cd example &amp;&amp; \\\n  yarn init <span class=\"token punctuation\">-</span>y &amp;&amp; \\\n  yarn add 7zip<span class=\"token punctuation\">-</span>bin &amp;&amp; \\\n  mkdir /lib64 &amp;&amp; \\\n  ln <span class=\"token punctuation\">-</span>s /lib/libc.musl<span class=\"token punctuation\">-</span>x86_64.so.1 /lib64/ld<span class=\"token punctuation\">-</span>linux<span class=\"token punctuation\">-</span>x86<span class=\"token punctuation\">-</span>64.so.2\n\n<span class=\"token keyword\">ADD</span> run.sh /run.sh\n\n<span class=\"token keyword\">RUN</span> chmod +x /run.sh\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"/run.sh\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>其中，<code class=\"language-text\">run.sh</code> 可以写：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> example\n<span class=\"token variable\"><span class=\"token variable\">$(</span>node -e \"console.log<span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">(</span><span class=\"token string\">'7zip-bin'</span><span class=\"token punctuation\">)</span>.path7za<span class=\"token variable\">)</span></span>\"<span class=\"token punctuation\">)</span></code></pre></div>\n<p>报错的内容是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/run.sh: line 2: /example/node_modules/7zip-bin/linux/x64/7za: not found</code></pre></div>\n<p>通过进入 Docker 内部观察不难发现，<code class=\"language-text\">/example/node_modules/7zip-bin/linux/x64/7za</code> 这个文件实际是真实存在的，但是在使用的时候系统却报错 <code class=\"language-text\">not found</code>。造成这一问题的原因，可能是动态库缺失。</p>\n<p>通过 <code class=\"language-text\">ldd</code> 命令可以列出动态库依赖关系（<a href=\"https://linux.die.net/man/1/ldd\">文档</a>）：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">ldd /example/node_modules/7zip-bin/linux/x64/7za</code></pre></div>\n<p>输出结果是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibpthread.so.0 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibstdc++.so.6 =&gt; /usr/lib/libstdc++.so.6 (0x7febe52b9000)\nlibm.so.6 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibgcc_s.so.1 =&gt; /usr/lib/libgcc_s.so.1 (0x7febe52a5000)\nlibc.so.6 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)</code></pre></div>\n<p>注意到缺少了 <code class=\"language-text\">/lib64/ld-linux-x86-64.so.2</code> 这个动态库，因此导致了 <code class=\"language-text\">7zip-bin</code> 这个库无法正常使用。造成这个的原因是，Alpine 使用的是 <a href=\"https://www.musl-libc.org/\">musl</a>，而 <code class=\"language-text\">7zip-bin</code> 使用的二进制文件是基于 glibc 编译出来的。要解决这个问题，有两种思路：</p>\n<ol>\n<li>在 Alpine 中安装 libc 的兼容库：<code class=\"language-text\">RUN apk add --no-cache libc6-compat</code>；</li>\n<li>或者，<code class=\"language-text\">ln -s /lib/libc.musl-x86_64.so.1 /lib/ld-linux-x86-64.so.2</code> 将 musl 的版本软连过去，直接让 <code class=\"language-text\">7zip-bin</code> 的二进制使用</li>\n</ol>\n<p>当然，最佳的方案是不使用 <code class=\"language-text\">7zip-bin</code> 中的 pre-build 版本，而改用 Alpine 的 <a href=\"https://pkgs.alpinelinux.org/package/edge/main/x86/p7zip\">p7zip</a> 版本。用 Alpine 的包管理器安装好 <code class=\"language-text\">pz7ip</code> 之后（<code class=\"language-text\">apk add p7zip</code>），使用类似下面的代码直接替换脚本就好了：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cp</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">type</span> -p 7za<span class=\"token variable\">)</span></span> <span class=\"token variable\"><span class=\"token variable\">$(</span>node -p <span class=\"token string\">\"require('7zip-bin').path7za\"</span><span class=\"token variable\">)</span></span></code></pre></div>\n<section><h2>参考链接</h2><ul>\n<li>在 7zip-bin issue 中的<a href=\"https://github.com/develar/7zip-bin/issues/8\">相关讨论</a></li>\n<li>重现的配置代码 <a href=\"https://gist.github.com/laysent/b12faceac4bcf10bee04aabfa505c244\">gist</a></li>\n<li>node-gyp 在 Alpine 中也可能会遇到类似的问题，在<a href=\"https://medium.com/devgorilla/node-gyp-support-in-alpine-linux-9374c6191140\">这里</a>可以找到相关的讨论</li>\n</ul></section>","frontmatter":{"date":"2019-12-02","title":"7zip-bin in Alpine Docker","category":"Docker"}}},{"node":{"id":"fd022b7a-07a5-588c-83eb-4dc5e5ec807c","html":"<p><code class=\"language-text\">arguments.callee</code> 是一个不应该被使用的 API，在严格模式下使用会直接报错。这里仅仅是作为了解，记录一下该 API 的作用。</p>\n<p>在早期的 JavaScript 版本中，不允许写带名字的函数表达式，在这种情况下，如果需要做递归调用，就无法显式得指明需要调用的函数名称。<code class=\"language-text\">arguments.callee</code> 这个值，指向了当前被调用的函数本身，因此可以在匿名函数递归调用中被使用。举例来说，在早期的 JavaScript 中，<code class=\"language-text\">Array.prototype.map</code> 函数给定的回调函数只能是匿名的，如果要实现一个阶乘函数，只能这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">num</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> arguments<span class=\"token punctuation\">.</span><span class=\"token function\">callee</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> num<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>然而，<code class=\"language-text\">arguments.callee</code> 的调用会导致 <code class=\"language-text\">this</code> 的指向出现问题（具体见 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee\">MDN</a>），使用起来比较危险。</p>\n<p>在 ECMAScript 3 中已经支持了带函数名的表达式，因此上面的代码可以简单的改写为一下这种正常的写法：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> num<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>换句话说，只需要给函数指定名称，就可以规避绝大多数的 <code class=\"language-text\">arguments.callee</code> 使用了（注：匿名函数/箭头函数无法指定名称，但同时规范也明确了匿名函数中没有 <code class=\"language-text\">arguments</code>）。</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee\">MDN</a> 给出了一个 <code class=\"language-text\">arguments.callee</code> 无法替换的场景：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">sIdentity</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> oPerson <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">'alert(arguments.callee.identity);'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  oPerson<span class=\"token punctuation\">.</span>identity <span class=\"token operator\">=</span> sIdentity<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> oPerson<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> john <span class=\"token operator\">=</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token string\">'John Smith'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">john</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里的函数 <code class=\"language-text\">oPerson</code> 是通过 <code class=\"language-text\">new Function</code> 创建的。在字符串内无法“得知”函数会被赋值的名称，因此只能通过 <code class=\"language-text\">arguments.callee</code> 去获取。在某些非常特殊的业务场景中，可能会有需求将某些表达式通过字符串进行存储，并通过 <code class=\"language-text\">new Function</code> 构建执行。这种时候，使用 <code class=\"language-text\">arguments.callee</code> 获取数据类似于传参。当然，如果只是传参的需求，其实可以写成：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> script <span class=\"token operator\">=</span> <span class=\"token string\">'alert(arg.identity)'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">identity</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> closure <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'const arg = arguments[0];'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">return function () { </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>script<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> }</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">closure</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> identity <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> john <span class=\"token operator\">=</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token string\">'John Smith'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">john</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-12-01","title":"arguments.callee","category":"JavaScript"}}},{"node":{"id":"c366bb01-a2f9-54c4-ac76-8013cd32b800","html":"<p>在使用了 <a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin\">mini-css-extract-plugin</a> 的项目中，有时会遇到如下的 Warning 输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in chunk styles [mini-css-extract-plugin]\nConflicting order between:\n* css xxx/css-loader/dist/cjs.js!./e1.css\n* css xxx/css-loader/dist/cjs.js!./e2.css\n* css xxx/css-loader/dist/cjs.js!./e3.css</code></pre></div>\n<section><h2>tl;dr</h2><p>上面这段 Warning 的实际含义是：</p><blockquote>\n<p>由于没法找到最合适的解，plugin 被迫使用了相对最优的解，将 <code class=\"language-text\">e1.css</code> 放到了编译产物中。在某些 chunk group 中，<code class=\"language-text\">e2.css</code> 或 <code class=\"language-text\">e3.css</code> 这两个文件引用位置在 <code class=\"language-text\">e1.css</code> 之前；而在 plugin 将 <code class=\"language-text\">e1.css</code> 加入编译产物的时候，<code class=\"language-text\">e2.css</code> 和 <code class=\"language-text\">e3.css</code> 还没有被添加。</p>\n</blockquote><p>换句话说，如果 <code class=\"language-text\">e1.css</code> 本来的用途是覆盖 <code class=\"language-text\">e2.css</code> 的内容，且覆盖依靠的是同优先级下 CSS 定义出现的先后顺序，那么在 plugin 编译完成之后，这个覆盖就会失效。</p></section>\n<section><h2>造成 Warning 的例子</h2><p>以下通过一个直观的例子来说明 plugin 在何时可能会输出上述 Warning：</p><p>假设有两个文件 <code class=\"language-text\">entry1.js</code>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token string\">'./e1.css'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'./e2.css'</span><span class=\"token punctuation\">;</span></code></pre></div><p><code class=\"language-text\">entry2.js</code>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token string\">'./e2.css'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'./e1.css'</span><span class=\"token punctuation\">;</span></code></pre></div><p>且 Webpack 配置了需要将 <code class=\"language-text\">e1.css</code> 和 <code class=\"language-text\">e2.css</code> 打包到同一个文件中。如果 plugin 选择将 <code class=\"language-text\">e1.css</code> 放在 <code class=\"language-text\">e2.css</code> 的前面，那么就不满足 <code class=\"language-text\">entry2.js</code> 的使用顺序；反之则不满足 <code class=\"language-text\">entry1.js</code> 的。正是在这样的“矛盾”情况下，plugin 输出了一个 Warning，并选择了一个相对最优的解。</p></section>\n<section><h2>更好的 Warning</h2><p>上面提到的 mini-css-extract-plugin Warning 并不是非常直观，也很难知道具体是哪一个 chunk group 出现了问题。新提交的 PR <a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/pull/465\">#465</a> 以及 <a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/pull/468\">#468</a> 对此做了优化。优化后的输出类似：</p><div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in chunk styles [mini-css-extract-plugin]\nConflicting order. Following module has been added:\n * css xxx!./e1.css\ndespite it was not able to fulfill desired ordering with these modules:\n * css xxx!./e2.css\n   - couldn&#39;t fulfill desired order of chunk group(s) entry2\n   - while fulfilling desired order of chunk group(s) entry1</code></pre></div><p>根据 Warning 的提示，只需要观察 entry2 中对应的代码，就可以找到不满足的引入顺序了。</p></section>\n<section><h2>是否需要关心</h2><p>这个 Warning 是否需要关注，取决于 CSS 在项目中是如何被使用的：只要在项目的使用过程中，没有 CSS 是通过加载的顺序进行优先级覆盖的，那么就可以忽略 plugin 给出的 Warning；反之，如果有这样的情况，则一定需要根据 Warning 修正输出，防止编译导致的意外。</p><p>当然，最保险的做法是启用 CSS Module，从源头上保证各个模块间的 CSS 是不会相互覆盖的。</p></section>\n<section><h2>代码分析</h2><p>以下从这个 Warning 入手，分析 plugin 是如何从 modules 生成最终的打包产物的。</p><p>观察 mini-css-extract-plugin 的源代码，不难找到这个 Warning 的具体输出<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L494\">代码</a>。接下来，将针对这段代码所在的 <code class=\"language-text\">renderContentAsset</code> 进行分析，了解 plugin 生成打包产物的算法。</p><p>首先观察 <code class=\"language-text\">renderContentAsset</code> 函数最开始的<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L416\">比较语句</a>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> chunkGroup<span class=\"token punctuation\">.</span>getModuleIndex2 <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>这里，<code class=\"language-text\">chunkGroup.getModuleIndex2</code> 是 Webpack 4 中的 API，在之前的版本中不存在（Webpack 3 及之前使用的是 <a href=\"https://github.com/webpack-contrib/extract-text-webpack-plugin\">extract-text-webpack-plugin</a>）。接下来，重点关心 Webpack 4 对应的代码段。</p><p>首先看 <code class=\"language-text\">moduleDependencies</code> 变量的初始化（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L418\">源码</a>）：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> moduleDependencies <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span>modules<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p><code class=\"language-text\">moduleDependencies</code> 为每一个 module 都定义了一个对应的空 Set（具体 Set 内的值会在后续填充）。</p><p>接下来看 <code class=\"language-text\">modulesByChunkGroup</code> 变量的定义（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L423\">源码</a>）：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> modulesByChunkGroup <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>chunk<span class=\"token punctuation\">.</span>groupsIterable<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">cg</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">return</span> sortedModules<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>可以看到，<code class=\"language-text\">modulesByChunkGroup</code> 本质上，是将所有的 chunk group（<code class=\"language-text\">chunk.groupsIterable</code>）转化成了对应的 <code class=\"language-text\">sortedModules</code>。这里 <code class=\"language-text\">sortedModules</code> 变量的定义为（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L424-L434\">源码</a>）：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> sortedModules <span class=\"token operator\">=</span> modules\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      module<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">,</span>\n      index<span class=\"token punctuation\">:</span> cg<span class=\"token punctuation\">.</span><span class=\"token function\">getModuleIndex2</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// eslint-disable-next-line no-undefined</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>index <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> b<span class=\"token punctuation\">.</span>index <span class=\"token operator\">-</span> a<span class=\"token punctuation\">.</span>index<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>简单来说，做了几件事情：</p><ol>\n<li>将 <code class=\"language-text\">modules</code> 中不属于当前 chunk group（<code class=\"language-text\">cg</code>）的部分剔除，对应的是 <code class=\"language-text\">.filter((item) =&gt; item.index !== undefined)</code>；</li>\n<li>根据 module 在 chunk group 中实际出现的位置，按从后往前进行排序，对应的是 <code class=\"language-text\">.sort((a, b) =&gt; b.index - a.index)</code></li>\n</ol><p>这里，越是先出现的 module 在最终的 <code class=\"language-text\">sortedModules</code> 数组中排的越靠后。换句话说，出现在数组最后的一个 module，没有任何前置的依赖（在该 chunk group 中，这个 module 是第一个被引入的）；而理论上来说，数组的第一个 module 依赖了数组后面的所有 modules（从 CSS 的角度来说，这个模块出现在最后。在所有选择器优先级一样的前提下，这个 module 理论上可以对之前所有的 module 进行覆盖）。这里采用倒叙的方式组织数组，是为了后续可以方便的使用 <code class=\"language-text\">Array.prototype.pop</code> 函数去获取当前没有依赖的 module。</p><p>接下来，<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L436-L442\">代码</a>对 <code class=\"language-text\">sortedModules</code> 变量值进行了填充：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> sortedModules<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> moduleDependencies<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>sortedModules<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> sortedModules<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>sortedModules<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>如上所述，<code class=\"language-text\">sortedModules</code> 中后出现的 module 是先出现 module 的依赖。这里的 <code class=\"language-text\">moduleDependencies</code> 变量记录了各个 module 的所有依赖（不仅仅是当前 chunk group 的依赖，所有 chunk group 的依赖最终都会被写入到这个 Set 中），其中 key 是各个 module，而对应的 value 则是一个 Set，Set 中的每个元素都是当前这个 module 的依赖。</p><p>之后定义了 <code class=\"language-text\">usedModules</code> 和 <code class=\"language-text\">unusedModulesFilter</code> 函数（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L448-L450\">源码</a>），目的是为了判断某一个 module 是否已经被当前的 plugin 使用了。</p><p>接下来的<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L452-L455\">代码</a>需要确保所有的 modules 都会根据某个具体的算法在最终的编译产物中被使用到。这里判断的方法就是 <code class=\"language-text\">usedModules</code> 是否包含了 <code class=\"language-text\">modules</code> 中所有的内容。</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>usedModules<span class=\"token punctuation\">.</span>size <span class=\"token operator\">&lt;</span> modules<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> success <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> bestMatch<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> bestMatchDeps<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>至此，准备工作都做完了。接下来就是核心的部分：如何在各个 chunk group 中选取合适的 module，依次放到最终生成的 CSS 文件中。<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L458-L484\">代码</a>如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> list <span class=\"token keyword\">of</span> modulesByChunkGroup<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// skip and remove already added modules</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> usedModules<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">[</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    list<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// skip empty lists</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> module <span class=\"token operator\">=</span> list<span class=\"token punctuation\">[</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> deps <span class=\"token operator\">=</span> moduleDependencies<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// determine dependencies that are not yet included</span>\n    <span class=\"token keyword\">const</span> failedDeps <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>unusedModulesFilter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// store best match for fallback behavior</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>bestMatchDeps <span class=\"token operator\">||</span> bestMatchDeps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> failedDeps<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      bestMatch <span class=\"token operator\">=</span> list<span class=\"token punctuation\">;</span>\n      bestMatchDeps <span class=\"token operator\">=</span> failedDeps<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>failedDeps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// use this module and remove it from list</span>\n      usedModules<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      success <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>理想情况下，两个 CSS module 在最终编译产物中的先后顺序，应该和这两个 CSS module 在某一个 chunk group 中的先后顺序是一致的。如果顺序上无法保证一致，那么应该尽可能将不一致的情况降到最低。mini-css-extract-plugin 就是遵循这一个原则来对 module 进行排序的。在每一次的选取步骤中，算法都会依次遍历每一个 chunk group，做下面几个事情：</p><ol>\n<li>拿到当前该 chunk group 中没有依赖的那个 CSS module（<code class=\"language-text\">const module = list[list.length - 1];</code>）；</li>\n<li>判断这个拿到的 CSS module 是否有前置的依赖还没有被放到最终产物中去（<code class=\"language-text\">const failedDeps = Array.from(deps).filter(unusedModulesFilter)</code>）;</li>\n<li>如果没有前置依赖了，那么这个 CSS module 就可以被“安全”的放到当前的编译产物中去（<code class=\"language-text\">if (failedDeps.length === 0) {</code> 对应的部分）；</li>\n<li>如果有不满足的前置依赖，那么就去寻找不满足情况最少的一个（<code class=\"language-text\">bestMatchDeps.length &gt; failedDeps.length</code>），然后记下来（<code class=\"language-text\">bestMatchDeps = failedDeps;</code>）</li>\n</ol><p>如果找到了没有前置依赖的 module，代码就直接 break，跳到下一次 while 循环中去了；如果没有找到完美匹配的情况，就会进入接下来的<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L486-L507\">代码</a>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no module found => there is a conflict</span>\n  <span class=\"token comment\">// use list with fewest failed deps</span>\n  <span class=\"token comment\">// and emit a warning</span>\n  <span class=\"token keyword\">const</span> fallbackModule <span class=\"token operator\">=</span> bestMatch<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>ignoreOrder<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    compilation<span class=\"token punctuation\">.</span>warnings<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>\n        <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">chunk </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>chunk<span class=\"token punctuation\">.</span>name <span class=\"token operator\">||</span> chunk<span class=\"token punctuation\">.</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> [</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>pluginName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">]\\n</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token operator\">+</span>\n          <span class=\"token string\">'Conflicting order between:\\n'</span> <span class=\"token operator\">+</span>\n          <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"> * </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>fallbackModule<span class=\"token punctuation\">.</span><span class=\"token function\">readableIdentifier</span><span class=\"token punctuation\">(</span>\n            requestShortener\n          <span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\\n</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token operator\">+</span>\n          <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>bestMatchDeps\n            <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"> * </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">readableIdentifier</span><span class=\"token punctuation\">(</span>requestShortener<span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  usedModules<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>fallbackModule<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>上面代码中的 <code class=\"language-text\">bestMatch</code> 就是对应了最佳情况时候 modules 排序的数组，这里 <code class=\"language-text\">fallbackModule = bestMatch.pop()</code> 就可以拿到当前这个最佳情况的 chunk group 中，没有依赖的那个 CSS module。和之前代码中 <code class=\"language-text\">module = list[list.length - 1]</code> 拿到的数据是一样的。</p><p>同时，<code class=\"language-text\">bestMatchDeps</code> 对应的就是上面代码里的 <code class=\"language-text\">failedDeps</code> 数组，表示的是当前这个 <code class=\"language-text\">fallbackModule</code> 被选中时，有哪些该 module 的前置依赖并没有被事先放到编译产物中去。</p><p>接下来就是向 Webpack 输出 Warning 的代码了。再来看下面这段 Warning：</p><div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in chunk styles [mini-css-extract-plugin]\nConflicting order between:\n* css xxx/css-loader/dist/cjs.js!./e1.css\n* css xxx/css-loader/dist/cjs.js!./e2.css\n* css xxx/css-loader/dist/cjs.js!./e3.css</code></pre></div><p>可知道，具体的含义是：由于没法找到最合适的解，plugin 被迫使用了相对最优的解，将 <code class=\"language-text\">e1.css</code> 放到了编译产物中。在某些 chunk group 中，<code class=\"language-text\">e2.css</code> 或 <code class=\"language-text\">e3.css</code> 这两个文件引用位置在 <code class=\"language-text\">e1.css</code> 之前；而在 plugin 将 <code class=\"language-text\">e1.css</code> 加入编译产物的时候，<code class=\"language-text\">e2.css</code> 和 <code class=\"language-text\">e3.css</code> 还没有被添加。</p></section>","frontmatter":{"date":"2019-11-28","title":"Conflicting order in mini-css-extract-plugin","category":"Build"}}},{"node":{"id":"4932e15d-274d-516f-988d-6f70cc3496f0","html":"<p>Chunk Group 是 Webpack 4 中新产生的一个概念。</p>\n<p>在 Webpack 中，一个文件/资源在打包时就是一个 module，一些 module 被打包到一起，生成一个 chunk。在原来的 Webpack 中，chunk 之间的依赖是一种父子关系：如果一个 chunk 有父 chunk，那么就可以认定，在这个 chunk 被加载的时候，至少其一个父 chunk 已经被加载了。在这种假设下，Webpack 可以对 chunk 进行一些优化，比如：如果一个 chunk 中的某个 module 被所有父 chunk 使用了，那么这个 module 就可以从 chunk 中删除（因为在加载 chunk 的时候，至少有一个父 chunk 已经被加载了，故这个 module 肯定已经存在了）。</p>\n<p>然而，这种父子关系的模式，并不利于 chunk 的拆分：在 CommonsChunkPlugin 中，如果一个 chunk 被拆分了出来，那么这个 chunk 会被“当作”是原来 chunk 的父 chunk 进行处理。这种父子关系其实是不正确的，因此也会影响到其他一些优化的进行。</p>\n<p>因此，在 Webpack 4 中，引入了 chunk group 的概念，目的就是修正这一概念。</p>\n<p>一个 chunk group，顾名思义，就是一组 chunk 的集合。一个 Webpack 的加载入口、或是一个异步加载点就是一个 chunk group，这个 group 中所有的 chunk 都是可以被并行加载的。同时，一个 chunk 也可以归属于多个不同的 chunk group。有了 chunk group 的概念，在通过 SplitChunksPlugin 进行拆分的时候，只需要将拆出来的 chunk 划分到对应的各个 chunk group 中去，就可以保证正常的使用了。</p>\n<p>参考文档见<a href=\"https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366\">这里</a>。</p>","frontmatter":{"date":"2019-11-27","title":"Chunk Group","category":"Build"}}},{"node":{"id":"7dc217cf-0b7c-5c89-bffe-de976e7fdcfd","html":"<p><code class=\"language-text\">Node.isEqualNode</code> 可以用于比较当前节点（Node）和指定节点是否是相同的。和 <code class=\"language-text\">Node.isSameNode</code> 不同，<code class=\"language-text\">.isEqualNode</code> API 并不需要两个被比较的节点是同一个。只需要满足以下的条件，两个节点就会被认为是相同的：</p>\n<ol>\n<li>两个节点的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\">nodeType</a> 是相同的；</li>\n<li>（省略非 Element 比较的情况，具体细节可以参考 <a href=\"https://dom.spec.whatwg.org/#concept-node-equals\">DOM 规范</a>）；</li>\n<li>如果节点是 element 的话，那么对 <code class=\"language-text\">A.isEqualNode(B)</code> 来说，A 中所有的属性，都可以在 B 上找到相同的值（反之亦然）；</li>\n<li>两个节点应该有等长的 <code class=\"language-text\">children</code>；</li>\n<li>两个节点的 <code class=\"language-text\">children</code> 的每个相同位置上的值都是相同的（递归调用 <code class=\"language-text\">isEqualNode</code> 的定义）。</li>\n</ol>\n<p>这里需要说明的几点是：</p>\n<ol>\n<li>在属性判断的时候，并不需要关心顺序：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> second <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> className <span class=\"token operator\">=</span> <span class=\"token string\">'className'</span><span class=\"token punctuation\">;</span>\n\nfirst<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span>\nfirst<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> className<span class=\"token punctuation\">;</span>\n\nsecond<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> className<span class=\"token punctuation\">;</span>\nsecond<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// first: &lt;div id=\"id\" className=\"className\">&lt;/div></span>\n<span class=\"token comment\">// second: &lt;div className=\"className\" id=\"id\">&lt;/div></span>\nfirst<span class=\"token punctuation\">.</span><span class=\"token function\">isEqualNode</span><span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => true</span></code></pre></div>\n<ol start=\"2\">\n<li>属性的判断是直接对值进行比较的，因此 <code class=\"language-text\">style</code> 的顺序不同会造成结果的不同：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> second <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfirst<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>display <span class=\"token operator\">=</span> <span class=\"token string\">'block'</span><span class=\"token punctuation\">;</span>\nfirst<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">;</span>\n\nsecond<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">;</span>\nsecond<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>display <span class=\"token operator\">=</span> <span class=\"token string\">'block'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// first: &lt;div style=\"display:block;color:red\">&lt;/div></span>\n<span class=\"token comment\">// second: &lt;div style=\"color:red;display:block\">&lt;/div></span>\nfirst<span class=\"token punctuation\">.</span><span class=\"token function\">isEqualNode</span><span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span></code></pre></div>\n<ol start=\"3\">\n<li>属性的比较是顺序无关的，但是 <code class=\"language-text\">children</code> 的比较是顺序相关的：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> second <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> childA <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> childB <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfirst<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>childA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfirst<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>childB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsecond<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>childB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsecond<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>childA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfirst<span class=\"token punctuation\">.</span><span class=\"token function\">isEqualNode</span><span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span></code></pre></div>\n<ol start=\"4\">\n<li>Node 是 Element 的“父类”，除了一般的 DOM 节点之外，节点上的 attributes，节点中的 comment 等也是 Node。这些节点也有 <code class=\"language-text\">isEqualNode</code> API 可以用于比较。对于一般的 Element 来说，可以简单的认为类型，属性和子节点一样，<code class=\"language-text\">isEqualNode</code> 就会返回 <code class=\"language-text\">true</code>。</li>\n</ol>\n<p>原始的比较算法，可以参考 <a href=\"https://dom.spec.whatwg.org/#concept-node-equals\">DOM 规范</a>；MDN 的介绍在<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/isEqualNode\">这里</a>。</p>","frontmatter":{"date":"2019-11-26","title":"isEqualNode","category":"JavaScript"}}},{"node":{"id":"1de0a311-e54d-5928-bcf7-eccaae105279","html":"<p><code class=\"language-text\">Node.isSameNode</code> 这个 API 的作用，是判断另一个 Node 节点和当前节点是否是相同的。举例来说：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n\na<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => true</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span></code></pre></div>\n<p>因为在一个同一个 document 中，一个 Node 实际只有一个引用，因此 <code class=\"language-text\">.isSameNode</code> API 的实际效果其实和 <code class=\"language-text\">==</code> 或 <code class=\"language-text\">===</code> 运算是一致的。简单来说，上面的代码，可以等价于：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">a <span class=\"token operator\">===</span> c<span class=\"token punctuation\">;</span> <span class=\"token comment\">// => true</span>\na <span class=\"token operator\">===</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span></code></pre></div>\n<p>在 <a href=\"https://dom.spec.whatwg.org/#dom-node-issamenode-othernode-othernode\">DOM (Living Standard) 规范</a>中，也可以看到相关的注释，说明 <code class=\"language-text\">.isSameNode</code> 本质上只是因为历史原因而给出的 <code class=\"language-text\">===</code> 的别名（alias）。</p>\n<p>然而在某些有限的场景下，<code class=\"language-text\">.isSameNode</code> 依然有发挥的应用场景，目前可以想到的有以下几点：</p>\n<ol>\n<li>在节点相关算法（如 Diff 算法）中作为抽象方法直接使用。比如，在 <a href=\"https://github.com/patrick-steele-idem/morphdom\">morphdom</a> 中，就使用了 <code class=\"language-text\">.isSameNode</code> 这个 API 来比较两个节点是否相同，从而节省比较的次数(<a href=\"https://github.com/patrick-steele-idem/morphdom/blob/56f330fa0fa6df9e51eeeaaae5894e24f30edb7c/src/morphdom.js#L237\">源码</a>)。根据 morphdom 给出的<a href=\"https://github.com/patrick-steele-idem/morphdom/blob/e4a34d934b24bb5aad1fcbc6222ed21bcdb5e56d/docs/virtual-dom.md#L23\">文档</a>可以看到，morphdom 的算法也支持对 virtual dom 进行比较，只需要 virtual dom 也对节点实现了相应的 <code class=\"language-text\">.isSameNode</code> API，就有可能可以在比较的时候节省一定的计算次数。这里，<code class=\"language-text\">.isSameNode</code> 在 morphdom 中就被作为抽象方法使用了，算法本身并不在意真正在 diff 的对象是真实的 DOM 还是 virtual DOM，只要节点实现了符合要求的 API，算法就可以正确的进行。</li>\n<li>通过重写方法来达到“代理节点”的功能。现在大多数的 UI 库，都通过声明式的方式来定义组件。在这种情况下，开发者并不需要显示的写出在何时通过何种方式创建或更新一个节点，只需要写出 <code class=\"language-text\">state =&gt; UI</code> 这样的映射函数，UI 库就会在 state 更新后，通过映射函数去得到新的 UI 组件，然后通过 diff 算法去计算得到需要修改的部分，最终将必要的部分进行更新。在这种情况下，就没有办法通过 <code class=\"language-text\">===</code> 去比较两个节点是否相同了，因为流程上是需要通过新的 state 生成节点，然后再和已有的 Node 进行比较。这种情况下，通过改写 <code class=\"language-text\">.isSameNode</code> 就可以达到人为控制的目的。</li>\n</ol>\n<p>举一个 <a href=\"https://github.com/choojs/nanocomponent\">nanocomponent</a> 中提到的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> html <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nanohtml'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> el1 <span class=\"token operator\">=</span> html<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>pink is the best&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> el2 <span class=\"token operator\">=</span> html<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>blue is the best&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 对 el1 进行代理操作</span>\n<span class=\"token keyword\">const</span> proxy <span class=\"token operator\">=</span> html<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\nproxy<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">isSameNode</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">targetNode</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>targetNode <span class=\"token operator\">===</span> el1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nel1<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// true</span>\nel1<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// false</span>\nproxy<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nproxy<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<p>虽然 <code class=\"language-text\">proxy</code> 和 <code class=\"language-text\">el1</code> 并不是真的一样的两个节点，但是因为对 <code class=\"language-text\">isSameNode</code> 进行了改写，因而在 diff 算法中，两个节点会被当作是一致的。这有助于节省比较的次数。</p>\n<p><code class=\"language-text\">.isSameNode</code> API 的支持情况，可以查看 <a href=\"https://caniuse.com/#search=isSameNode\">Can I Use</a>；文档可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/isSameNode\">MDN</a>。</p>","frontmatter":{"date":"2019-11-25","title":"isSameNode","category":"JavaScript"}}},{"node":{"id":"d4f2cc35-174d-5e24-86fa-274d23e4c9a1","html":"<p>在 TypeScript 编译过程中，可能会遇到如下的报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">Exported variable &lt;variable name&gt; has or is using private name &lt;private name&gt;</code></pre></div>\n<p>这一报错只会出现在开启了 declaration 输出之后。开启的方式是编译时增加 <code class=\"language-text\">--declaration</code>，或者在 tsconfig.json 中加入：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"declaration\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>出现这一报错的原因是，最终被使用的某一个类型，引用到了某一个没有被公开（export）的类型。简单的例子如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">B</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">type</span> Props <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">|</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，之所以会出现问题，理由很简单：TypeScript 试图输出一个定义类型的文件，其中就包括了 <code class=\"language-text\">Props</code> 的定义。然而，如果要明确定义 <code class=\"language-text\">Props</code>，就需要用到两个类型 <code class=\"language-text\">A</code> 和 <code class=\"language-text\">B</code>。在这里，<code class=\"language-text\">A</code> 和 <code class=\"language-text\">B</code> 这两个类型因为没有被公开（export），因而是私有（private）的。故，理论上来说，TypeScript 的导出定义文件中不应该包含这两个类型。而没有这两个类型的话，TypeScript 就没有办法定义 <code class=\"language-text\">Props</code> 了。最终，TypeScript 只能报错。</p>\n<p>官方给出的解释可以参考<a href=\"https://github.com/ant-design/ant-design/pull/19846#event-2817984936\">这里</a>。</p>\n<p>要解决这个问题，方法也很简单：所有使用到的类型，全部都公开（export）就好了。</p>","frontmatter":{"date":"2019-11-21","title":"Export Variable using Private Name","category":"TypeScript"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}