{"componentChunkName":"component---src-pages-til-js","path":"/til/","webpackCompilationHash":"687e338135c47159cd63","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"bb00bd56-438b-5e03-926d-cb9348da2b4d","html":"<p>在 C 编程中，经常会用到 <code class=\"language-text\">Makefile</code> 来对源代码进行编译。一个简单的 <code class=\"language-text\">Makefile</code> 如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"makefile\"><pre class=\"language-makefile\"><code class=\"language-makefile\"><span class=\"token symbol\">out</span><span class=\"token punctuation\">:</span> input.c\n  <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> input.c -o out -Wall -Wextra -std<span class=\"token operator\">=</span>c99</code></pre></div>\n<p>这里，第一行的 <code class=\"language-text\">out: input.c</code> 表示 <code class=\"language-text\">make</code> 应该根据输入 <code class=\"language-text\">input.c</code> 来产出 <code class=\"language-text\">out</code> 这个文件。</p>\n<p>第二行的 <code class=\"language-text\">$(CC)</code> 会由 <code class=\"language-text\">make</code> 替换成本机的 cc 程序（即 <strong>c</strong> <strong>c</strong>ompiler）；后面跟着的是 <code class=\"language-text\">cc</code> 编译会用到的参数，包括输入源文件 <code class=\"language-text\">input.c</code>，输出文件 <code class=\"language-text\">out</code>，编译输出所有的 Warning（<code class=\"language-text\">-Wall</code> 即 <strong>W</strong>arning <strong>all</strong>，<code class=\"language-text\">-Wextra</code> 即 <strong>W</strong>arning <strong>extra</strong>），同时指定使用 <a href=\"https://en.wikipedia.org/wiki/C99\">C99</a> 标准来编译 C 代码（和 <a href=\"https://en.wikipedia.org/wiki/ANSI_C\">ANSI C</a> 相比，C99 允许在函数的任意位置定义变量，而不是必须在顶部）。</p>\n<p>运行 <code class=\"language-text\">make</code> 命令，程序会查找当前目录下的 <code class=\"language-text\">Makefile</code> 函数，读取其中的配置，根据输入输出的要求，查找文件，然后再选择编译。</p>\n<p>第一次编译，程序会用 <code class=\"language-text\">input.c</code> 编译出一个 <code class=\"language-text\">out</code> 文件来。</p>\n<p>在 <code class=\"language-text\">input.c</code> 没有修改的情况下，如果再运行一次 <code class=\"language-text\">make</code> 命令，会得到如下的输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">make: `out` is update to date.</code></pre></div>\n<p>这里，<code class=\"language-text\">make</code> 程序并没有通过任何外部文件的方式记录编译的情况。判断是否需要编译完全依赖于系统默认的文件功能，即简单的比较 <code class=\"language-text\">input.c</code> 和 <code class=\"language-text\">out</code> 两个文件的最后修改时间。如果 <code class=\"language-text\">out</code> 的最后修改时间比 <code class=\"language-text\">input.c</code> 要晚，就认为 <code class=\"language-text\">out</code> 是最新的，不再重复编译；如果 <code class=\"language-text\">input.c</code> 的最后修改时间晚于 <code class=\"language-text\">out</code> 的时间，或是 <code class=\"language-text\">out</code> 压根就不存在，那么 <code class=\"language-text\">make</code> 就会执行 <code class=\"language-text\">Makefile</code> 中配置的编译命令。</p>\n<p>可以通过以下方式欺骗 <code class=\"language-text\">Makefile</code> 来检查这一行为：</p>\n<ol>\n<li>修改一下 <code class=\"language-text\">input.c</code> 并保存</li>\n<li>删除 <code class=\"language-text\">out</code> 文件，然后用 <code class=\"language-text\">touch</code> 命令创建一个空的 <code class=\"language-text\">out</code> 文件。因为是先修改，再创建，所以 <code class=\"language-text\">out</code> 的创建时间会晚于 <code class=\"language-text\">input.c</code></li>\n<li>尝试执行 <code class=\"language-text\">make</code> 命令，会发现提示 <code class=\"language-text\">out</code> 已经是最新的，并没有执行真正的编译命令（尽管这里 <code class=\"language-text\">out</code> 并不是通过 <code class=\"language-text\">make</code> 编译出来的）</li>\n</ol>","frontmatter":{"date":"2019-08-04","title":"How Makefile works","category":"Bash"}}},{"node":{"id":"5017cac8-c3ff-523d-bee3-2831eaad1c50","html":"<p>在命令行中，一个命令会有一个返回数值，<code class=\"language-text\">0</code> 代表正确运行；如果命令返回了非 <code class=\"language-text\">0</code> 数据，则代表命令运行出现了错误。</p>\n<p>比如，如果 <code class=\"language-text\">Jest</code> 命令跑单元测试出现了错误，那么就会返回一个非 <code class=\"language-text\">0</code> 的值。运用 <code class=\"language-text\">set -e</code> 可以让 Bash 在遇到非零返回的命令行之后即停止，不再运行接下去的命令。</p>\n<p>那么，该如何确定之前的命令是否返回了 <code class=\"language-text\">0</code> 呢？</p>\n<p>可以简单的使用如下的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token variable\">$?</span></code></pre></div>\n<p>这里的 <code class=\"language-text\">$?</code> 就是上一个命令返回的数值。如果上一条命令执行成功，那么这里应该输出 <code class=\"language-text\">0</code>。</p>","frontmatter":{"date":"2019-08-02","title":"Check Exit Code of Command","category":"Bash"}}},{"node":{"id":"cd1eb582-4609-5413-b31d-1454b20b7d96","html":"<p>在写 CI 脚本的时候，希望可以在脚本执行失败之后终止后续的所有操作。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token string\">\"start\"</span>\n<span class=\"token function\">yarn</span> <span class=\"token function\">test</span>\n<span class=\"token keyword\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>如果 <code class=\"language-text\">yarn test</code> 这个命令失败了，希望不执行 <code class=\"language-text\">echo &quot;end&quot;</code> 语句。然而通过执行上面的代码，会发现默认是执行的。如果希望不执行这个操作，有几种思路：</p>\n<p>第一种，是用 <code class=\"language-text\">&amp;&amp;</code> 将语句串联起来，比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token string\">\"start\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">yarn</span> <span class=\"token function\">test</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>这样的方案，缺点是比较的麻烦。一旦东西比较多，就很难保证代码的可读性了。</p>\n<p>第二种方案，是使用 <code class=\"language-text\">set -e</code>，脚本改为：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">set</span> -e\n<span class=\"token keyword\">echo</span> <span class=\"token string\">\"start\"</span>\n<span class=\"token function\">yarn</span> <span class=\"token function\">test</span>\n<span class=\"token keyword\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>如此一来，脚本在语句执行失败（Exit Code 不是 0）之后就会退出，不会执行接下去的脚本。</p>\n<p><a href=\"http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#The-Set-Builtin\">参考文档</a></p>","frontmatter":{"date":"2019-08-01","title":"Exit when Command Fail","category":"Bash"}}},{"node":{"id":"95e9a909-b17d-5d27-a0f1-f9ae9e02b984","html":"<p>在进行网络请求的时候，有可能会遇上服务器指定链接跳转的情况。此时，无论是 301（永久转移）还是 302（暂时转移），在请求页面的时候都需要根据服务器的指示，去访问下一个链接。当然，这里下一个链接依然有可能是跳转链接，需要继续执行跳转操作。</p>\n<p>一段可用的 Node.js 代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> https <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">link</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> link<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> https <span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>link<span class=\"token punctuation\">,</span> <span class=\"token parameter\">response</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>statusCode <span class=\"token operator\">>=</span> <span class=\"token number\">300</span> <span class=\"token operator\">&amp;&amp;</span> response<span class=\"token punctuation\">.</span>statusCode <span class=\"token operator\">&lt;</span> <span class=\"token number\">400</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> location <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">[</span><span class=\"token string\">'set-cookie'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里，Node.js 处理 HTTP 和 HTTPs 请求使用的模块是不相同的，因而需要根据链接地址的 protocol 进行按需索取。同时，如果是 3xx 的 HTTP 结果，则需要进行链接跳转。可以直接读取 headers 中的 <code class=\"language-text\">location</code> 数据，找到下一步需要跳转到的位置。</p>","frontmatter":{"date":"2019-07-31","title":"Follow Redirection","category":"Node.js"}}},{"node":{"id":"bce782dd-1013-548b-a42e-8b7020a9a3c2","html":"<p>在 Docker 中使用 SSH 的功能时，发现 SSH 报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">Bad owner or permissions on ~/.ssh/config</code></pre></div>\n<p>通过 <code class=\"language-text\">ls -l</code> 查看 <code class=\"language-text\">~/.ssh/config</code>，得到如下结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">-rw------- 1 1000  1000   557 Jul 29 20:32 config</code></pre></div>\n<p>注意到给出的 User 和 Group 的值不是一个名字（如 <code class=\"language-text\">root</code>），而是一个数字。这说明，文件所属的 User / Group 无法找到。</p>\n<p>可以通过如下的命令查看当前 <code class=\"language-text\">root</code> 用户的 ID：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">id</span> -u root <span class=\"token comment\"># output => 0</span></code></pre></div>\n<p>可以看到和 <code class=\"language-text\">ls</code> 列出的 ID 是不匹配的。这说明，导致 SSH 无法正常工作的主要原因，是 <code class=\"language-text\">~/.ssh/config</code> 文件权限的设置有问题。可以通过如下的命令将权限分配给当前的 <code class=\"language-text\">root</code> 用户：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">chown</span> -R root:root /root/.ssh</code></pre></div>\n<p>再次运行 SSH 就可以正常工作了。</p>","frontmatter":{"date":"2019-07-30","title":"Bad owner or permissions","category":"Bash"}}},{"node":{"id":"6c27cfd3-d03c-5034-a29f-9ac99e7f51bf","html":"<p>当 Ant Design 和 Jest 一起使用的时候，在某些情况下（开启 coverage 的时候）会导致单元测试运行失败。一个可能造成问题的 Ant Design 代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Input <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'antd'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> TextArea <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> Input<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Jest 会报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">ReferenceError: Input is not defined\n\n  1 | import { Input } from &#39;ant-design&#39;;\n  2 |\n&gt; 3 | const { TextArea } = Input;</code></pre></div>\n<p>报错的直接原因，是使用了 Ant Design 推荐的 <code class=\"language-text\">babel-plugin-import</code> 和 Jest 计算 coverage 使用的 <code class=\"language-text\">babel-plugin-istanbul</code> 造成的。在<a href=\"https://github.com/ant-design/babel-plugin-import/issues/172\">这里</a>、<a href=\"https://github.com/ant-design/babel-plugin-import/issues/189#issuecomment-445139343\">这里</a>等 GitHub Issue 中都有相应的讨论。</p>\n<p>要修复这个问题，只需要在 Jest 或者单元测试环境中，不使用 <code class=\"language-text\">babel-plugin-import</code> 这个转换插件就可以了。参考代码如下，在 <code class=\"language-text\">.babelrc</code> 中：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"env\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"development\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">[</span>\n          <span class=\"token string\">\"import\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">{</span>\n            <span class=\"token property\">\"libraryName\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"antd\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"style\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"production\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// same as above</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token comment\">// rest of plugins...</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如此一来，只有在 <code class=\"language-text\">NODE_ENV</code> 为 <code class=\"language-text\">production</code> 或 <code class=\"language-text\">development</code> 的情况下，Babel 才会启用 <code class=\"language-text\">babel-plugin-import</code> 这个转换插件。对于 Jest 来说，因为默认设置了环境变量 <code class=\"language-text\">NODE_ENV</code> 为 <code class=\"language-text\">test</code>，所以 Plugin 不会起效。</p>\n<p>这样造成的问题是 Jest 的运行速度会有所降低。</p>","frontmatter":{"date":"2019-07-29","title":"Jest with Ant Design","category":"JavaScript"}}},{"node":{"id":"111b032a-a1fc-57f1-8eed-7a908e9ee7e3","html":"<p>如果手上有多台设备在管理，SSH 的时候需要记住各个设备的 IP 地址、输入，总是很麻烦的。SSH 提供了配置文件的功能，可以为不同的 IP 设置别名，同时配置登陆需要用到的用户名和 RSA 私钥等。</p>\n<section><h2>配置方法</h2><p>修改 <code class=\"language-text\">~/.ssh/config</code> 文件，增加每个设备对应的配置数据。举例如下：</p><div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">Host pi\n    Hostname 192.168.xx.xx\n    User pi\n    IdentityFile ~/.ssh/id_pi_rsa</code></pre></div><p>这样就配置好了一个 Raspberry Pi 的别名。接下来，可以直接使用如下的命令来访问设备：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ssh</span> pi</code></pre></div><p>除了 SSH 之外，SCP 也可以使用同样的配置。比如：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">scp</span> -r /local/path pi:/remote/path</code></pre></div></section>","frontmatter":{"date":"2019-07-28","title":"SSH Host Config","category":"Bash"}}},{"node":{"id":"4aa86de8-f5ef-545f-82b2-a0200ca867de","html":"<p>默认情况下，Webapck 会用 Chunk ID 为 <code class=\"language-text\">import()</code> 产生的独立文件命名，最终的结果就是类似于 <code class=\"language-text\">0.bundle.js</code> 这样的文件。这样的文件并不方便理解和管理，所以一般会使用 <code class=\"language-text\">webpackChunkName</code> 这个注释来让 Webapck 使用更加有意义的命名。例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* webpackChunkName: \"module-name\" */</span> <span class=\"token string\">'path-to-bundle'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>最终产生的文件为 <code class=\"language-text\">module-name.bundle.js</code>（这里假设在 Webpack 中配置了 <code class=\"language-text\">output.filename</code> 为 <code class=\"language-text\">[name].bundle.js</code>）。</p>\n<p>然而，每次要手写这样的注释有些麻烦。如果动态加载的模块本身存放位置有规律可循（比如是在 pages 目录下，每个目录有一个入口文件），那么也可以考虑使用 Babel 插件的方式，自动为每个 <code class=\"language-text\">import()</code> 增加合适的 bundle name。</p>\n<p>参考代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">addComments</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arg<span class=\"token punctuation\">,</span> name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// only add leading comment when not found</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">.</span>leadingComments<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  arg<span class=\"token punctuation\">.</span>leadingComments <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n    type<span class=\"token punctuation\">:</span> <span class=\"token string\">'CommentBlock'</span><span class=\"token punctuation\">,</span>\n    value<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">` webpackChunkName: '</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">' `</span></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getChunkNameFromImportPath</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">importPath</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// find a way to transform from import path to chunk name</span>\n  <span class=\"token comment\">// example: from 'path/to/file' to 'path.to.file' as chunk name</span>\n  <span class=\"token keyword\">return</span> importPath<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/\\//g</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nmodule<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">exports</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">babel</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> types<span class=\"token punctuation\">:</span> t <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> babel<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">'add-bundle-name'</span><span class=\"token punctuation\">,</span>\n    visitor<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function-variable function\">CallExpression</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">path</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> node <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> path<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">isImport</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>callee<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>firstArg<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>arguments<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> importPath <span class=\"token operator\">=</span> firstArg<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">addComments</span><span class=\"token punctuation\">(</span>firstArg<span class=\"token punctuation\">,</span> <span class=\"token function\">getChunkNameFromImportPath</span><span class=\"token punctuation\">(</span>importPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"date":"2019-07-26","title":"Import Chunkname with Babel Plugin","category":"JavaScript"}}},{"node":{"id":"e021306b-55f0-5457-9892-4bc9c1e12835","html":"<p>在 Docker 开发的过程中，有时会有脚本出错，导致执行结果不及预期的情况。这种错误有时是环境导致的，在非 Docker 环境下无法重现。如果需要通过构建 Docker 添加诸如日志之类的信息来了解具体可能出错的原因，不免有些曲折。可以考虑直接在 Docker 环境下运行 Bash 命令，通过执行脚本中的语句，来查找可能出现问题的原因。</p>\n<p>要在 Docker 环境下执行 Bash 脚本，可以遵循以下的步骤：</p>\n<ol>\n<li>首先，需要知道当前运行 Docker 的容器 ID</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker container <span class=\"token function\">ls</span></code></pre></div>\n<p>上述命令会列出所有的容器，找到需要调试的那一个即可。</p>\n<ol start=\"2\">\n<li>在该容器环境内执行 Bash 命令</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token function\">exec</span> -ti xxx /bin/bash</code></pre></div>\n<p>这里，<code class=\"language-text\">xxx</code> 就是第一步找到的 Container ID。上述命令用到了两个参数，<code class=\"language-text\">-t</code> 和 <code class=\"language-text\">-i</code>。<code class=\"language-text\">-t</code> 是 <code class=\"language-text\">--tty</code> 的缩写，用于让 Docker 将用户的终端和 stdin/stdout 关联起来；<code class=\"language-text\">-i</code> 是 <code class=\"language-text\">--interactive</code> 的缩写，用于让 Docker 在执行命令的时候允许用户进行交互式的输入输出。</p>\n<p>如果只是希望执行一个语句并输出结果（比如 <code class=\"language-text\">echo</code> 一个字符串），那么 <code class=\"language-text\">-t</code> 就足够了，不需要 <code class=\"language-text\">-i</code>。但是对于需要在 Docker 环境下输入 Bash 命令并检查执行结果的情况来说，<code class=\"language-text\">-i</code> 就是必须的。</p>\n<p>一个输出 Hello World 的简单例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token function\">exec</span> -t <span class=\"token keyword\">echo</span> <span class=\"token string\">\"hello world\"</span></code></pre></div>\n<p>另外，可以通过如下的命令知道，<code class=\"language-text\">docker exec</code> 运行的默认环境是在 <code class=\"language-text\">/</code> 下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token function\">exec</span> -t <span class=\"token function\">pwd</span> <span class=\"token comment\"># output: /</span></code></pre></div>\n<p>如需修改这一默认行为，可以通过 <code class=\"language-text\">-w</code> 参数（或 <code class=\"language-text\">--workdir</code>）来执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token function\">exec</span> -w /root -t xxx <span class=\"token function\">pwd</span> <span class=\"token comment\"># output: /root</span></code></pre></div>","frontmatter":{"date":"2019-07-25","title":"Execute Bash in Docker","category":"Docker"}}},{"node":{"id":"32799a20-826d-5a55-8cdc-d47c46c6d61d","html":"<p>Alpine 是 Docker 中非常流行的镜像，因为它体积小（5 MB 左右），且包管理机制友善。然而即使体积小，一旦网络条件受到限制，使用 Alpine 安装依赖依然十分费劲。这让 Docker 镜像的安装变得非常缓慢且容易失败。</p>\n<p>假设原先的 Dockerfile 如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>edge\n\n<span class=\"token keyword\">RUN</span> apk update &amp;&amp; \\\n  <span class=\"token comment\"># ...</span></code></pre></div>\n<p>那么可以考虑改用国内的镜像源来加速网络下载过程：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>edge\n\n<span class=\"token keyword\">RUN</span> echo <span class=\"token string\">'http://mirrors.aliyun.com/alpine/edge/community/'</span> <span class=\"token punctuation\">></span> \\\n    /etc/apk/repositories &amp;&amp; \\\n  echo <span class=\"token string\">'http://mirrors.aliyun.com/alpine/edge/main/'</span> <span class=\"token punctuation\">></span><span class=\"token punctuation\">></span> \\\n    /etc/apk/repositories &amp;&amp; \\\n  apk update &amp;&amp; \\\n  <span class=\"token comment\"># ...</span></code></pre></div>\n<p>除了上面提到的<a href=\"https://mirrors.aliyun.com/alpine/\">阿里镜像</a>之外，<a href=\"https://mirrors.tuna.tsinghua.edu.cn/alpine/\">清华</a>、<a href=\"https://mirrors.nju.edu.cn/alpine/\">南大</a>、<a href=\"https://mirrors.ustc.edu.cn/alpine/\">中科大</a>等镜像也可以考虑。更多镜像及其对应的网络状态可以在<a href=\"https://mirrors.alpinelinux.org/\">这里</a>找到。</p>\n<p>注意使用的镜像版本必须与 Docker 需要使用的版本保持一致。如上例中，Docker 需要基于 <code class=\"language-text\">alpine:edge</code>，那么在设置镜像的使用，也应该使用 <code class=\"language-text\">edge</code> 的版本（在 URL 中可以找到 <code class=\"language-text\">/alpine/edge/</code>）。</p>","frontmatter":{"date":"2019-07-24","title":"Alpine Mirror","category":"Docker"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}