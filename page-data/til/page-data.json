{"componentChunkName":"component---src-pages-til-js","path":"/til/","webpackCompilationHash":"e6ece375915cc981625d","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"a3a5604f-70d9-56ff-9818-d07ddbaef1de","html":"<p>浏览器提供了 <code class=\"language-text\">performance</code> 用于测量 JavaScript 的一些运行效率，并在浏览器的对应位置（如 Chrome 的 Performance Tab）生成火焰图，可以方便的查看程序调用栈的执行效率。简单的操作如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getMarkName</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token string\">`mark: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">beginMark</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">mark</span><span class=\"token punctuation\">(</span><span class=\"token function\">getMarkName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">endMark</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> markName <span class=\"token operator\">=</span> <span class=\"token function\">getMarkName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    performance<span class=\"token punctuation\">.</span><span class=\"token function\">measure</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> markName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果 markName 无法被找到（也就是 beginMark 函数没有被调用）</span>\n    <span class=\"token comment\">// 那么程序在 performance.measure 的时候会报错</span>\n    <span class=\"token comment\">// 这里无需将报错抛出，直接吞掉就可以了</span>\n  <span class=\"token punctuation\">}</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">clearMarks</span><span class=\"token punctuation\">(</span>markName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">clearMeasure</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">beginMark</span><span class=\"token punctuation\">(</span><span class=\"token string\">'label name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 需要进行的操作</span>\n  <span class=\"token function\">endMark</span><span class=\"token punctuation\">(</span><span class=\"token string\">'label name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>具体来说，通过 <code class=\"language-text\">performance.mark</code> 函数标记一个点，然后在需要测量的程序执行完成之后，通过 <code class=\"language-text\">performance.measure</code> 来计算当前和最初 mark 的点之间的运行时间。最终，这一段结果会在 Chrome 的 Performance Timings 中形成对应的火焰图数据。</p>\n<p><code class=\"language-text\">performance.measure</code> 也支持三个参数的调用，三个参数分别是 label 的名称，起始 mark 的名称以及终止 mark 的名称。如果省略最后一个参数，那么终止的时间点就是当前 <code class=\"language-text\">performance.measure</code> 调用的时间点。</p>\n<p>最后，通过 <code class=\"language-text\">performance.clearMarks</code> 及 <code class=\"language-text\">performance.clearMeasure</code> 删除标记，清理不必要的内存使用。</p>\n<p>更多的介绍，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance\">MDN</a> 的文档。React 中也使用了类似的技术用于在 Performance 中生成每个 Component 渲染花费的时间，相关的代码可以参考 <a href=\"https://github.com/facebook/react/blob/50addf4c0e411e351de7290c8c60ec775c25c8c4/packages/react-reconciler/src/ReactDebugFiberPerf.js#L80\">ReactDebugFiberPerf.js</a>。</p>","frontmatter":{"date":"2019-09-30","title":"Performance Measure","category":"JavaScript"}}},{"node":{"id":"bd452c56-2b4b-5efe-9310-ffe36aa861eb","html":"<p>JavaScript 中提供了 <code class=\"language-text\">devicemotion</code> 事件，可以用于监听设备各个方向上受到的力（加速度）。有了这个事件，就可以用于判断当前用户是否在进行类似“摇一摇”之类的操作，方便开发基于特定交互的一些功能。</p>\n<p>具体来说，<code class=\"language-text\">devicemotion</code> 事件会提供 <code class=\"language-text\">accelerationIncludingGravity</code> 数据，作为一个对象分别提供 <code class=\"language-text\">x</code>，<code class=\"language-text\">y</code> 和 <code class=\"language-text\">z</code> 三个方向上的加速度。通过不同时间点上加速度值的不同，就可以判断当前用户是否在进行摇晃手机的操作了。</p>\n<p>使用 <code class=\"language-text\">devicemotion</code> 的示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>accelerationIncludingGravity<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// do stuff here</span>\n<span class=\"token punctuation\">}</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'devicemotion'</span><span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>判断是否在摇晃手机，简单来说，只需要判断当前的各方向加速度之差，是否有至少两个超过了给定的阈值。<a href=\"https://github.com/alexgibson/shake.js\">shake.js</a> 中就使用了这样的方法来判断当前用户是否在摇晃手机，具体的代码可以参考<a href=\"https://github.com/alexgibson/shake.js/blob/d232eee7a5f31e9fd37aa79aa83f1f206035ccc9/shake.js#L104\">源码</a>。</p>\n<p><code class=\"language-text\">devicemotion</code> 更多的信息，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/devicemotion_event\">MDN</a>。</p>","frontmatter":{"date":"2019-09-29","title":"Mobile Shake","category":"JavaScript"}}},{"node":{"id":"f6c8d069-1e12-58f8-b517-2bbee6e9e37f","html":"<p>在 Webpack 的编译过程中，可以通过 <code class=\"language-text\">devtool</code> 的配置选项选择以什么样的形式输出 SourceMap。Webpack 提供了非常多的选择方案，不同的选项可以达到的效果是不一样的，也会极大的影响最终编译的时间。Webpack 的官方<a href=\"https://webpack.js.org/configuration/devtool/\">文档</a>，从编译时间、重编译时间（针对 Watch 下的修改重编译）以及最终的使用效果三个纬度，给出了各个配置选项的实际效果。（中文版文档在<a href=\"https://webpack.docschina.org/configuration/devtool/\">这里</a>）</p>\n<p>一般情况下：生产环境最终的打包，建议使用 <code class=\"language-text\">source-map</code> 作为配置。这种配置会将 SourceMap 文件打包到另外一个独立的文件中，线上代码不会暴露源文件，同时提供了最精细的代码映射关系，方便线上代码的调试和问题定位。当然，这种配置的缺点也非常明显，就是构建过程比较花费时间，因此一般只建议在最终要上线的版本中使用这种配置。</p>\n<p>对于开发环境 Watch 模式下打包 Hot Reload 的版本，建议使用 <code class=\"language-text\">eval-source-map</code> 或者 <code class=\"language-text\">cheap-module-eval-source-map</code>。这两种模式，都会将代码用 <code class=\"language-text\">eval</code> 函数包裹起来，重编译的速度比较快，区别主要在于 SourceMap 的生成方案。前者会生成高品质的 SourceMap，因而初次构建的速度会比较慢，但是提供了行和列的映射；后者只提供了行层面的代码映射，因此会更加快一些，但是断点的效果会略打折扣（无法提供到列的映射关系）。</p>\n<p>更多的类型以及各种情况的说明，可以参考官方文档（链接在上面给出）。</p>","frontmatter":{"date":"2019-09-27","title":"SourceMap in Webpack","category":"Build"}}},{"node":{"id":"898ae752-777a-51e5-a284-fbdb8b57b1f2","html":"<p>优化的第一步，是知道瓶颈在哪里。</p>\n<p>在针对 Webpack 编译速度优化的过程中，知道哪些 loader / plugin 运行耗费了很多时间就显得非常重要了。</p>\n<p>Speed Measure Plugin 是一款针对 Webpack 的插件，只需要一些非常简单的操作，插件就可以在已有配置的基础上，给 Webpack 的打包过程增加必要的计时功能，同时清晰的列举出各个 loader / plugin 在本次编译中的耗时情况。Plugin 的文档在<a href=\"https://github.com/stephencookdev/speed-measure-webpack-plugin#readme\">这里</a>。</p>\n<p>简单来说，只需要在原有的配置基础上，这么额外包一层 Speed Measure Plugin 就可以了：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> SpeedMeasurePlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"speed-measure-webpack-plugin\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> smp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SpeedMeasurePlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> disable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token function\">smp</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，<code class=\"language-text\">disable: false</code> 表示需要 Speed Measure Plugin 记录时间，这也是默认的值，可以不传。如果赋值是 <code class=\"language-text\">true</code>，那么就会告知 Speed Measure Plugin 不要做任何处理，结果等同于没有使用 Speed Measure Plugin。如果需要经常对 Webpack 的打包进行优化，可以将 Speed Measure Plugin 的代码写入到库中，并通过环境变量等方法在打包的时候开启或关闭这个记录的功能。</p>","frontmatter":{"date":"2019-09-26","title":"Webpack Speed Measure","category":"Build"}}},{"node":{"id":"68c1de3e-714f-573c-9c19-9507372865ab","html":"<p><code class=\"language-text\">mochawesome</code> 是为 Mocha 提供的一个 Report 库，可以用于生成不错的 HTML 报告（见 <a href=\"https://www.npmjs.com/package/mochawesome\">npm</a>）。库本身提供了一个 <code class=\"language-text\">addContext</code> 的 API，可以用于在运行 Test 的时候，存入额外的信息到 Context 中，最终在生成 HTML 报告的时候，将这部分 Context 信息写入对应的测试用例内。</p>\n<p>参考代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> addContext <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mochawesome/addContext'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test suite'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'unit test'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addContext</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'content'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// or</span>\n    <span class=\"token function\">addContext</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      title<span class=\"token punctuation\">:</span> <span class=\"token string\">'title'</span><span class=\"token punctuation\">,</span>\n      value<span class=\"token punctuation\">:</span> <span class=\"token string\">'value or object'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>几点说明：</p>\n<ol>\n<li>在 <code class=\"language-text\">beforeEach</code> 或 <code class=\"language-text\">afterEach</code> 的钩子内调用 <code class=\"language-text\">addContext</code> 也是允许的；</li>\n<li>如果给定的第二个参数是 URL 或是一个图片的话，<code class=\"language-text\">mochawesome</code> 可以有相对应的展示；</li>\n<li>记得 <code class=\"language-text\">it</code> 函数的第二个参数不要使用箭头函数，否则 <code class=\"language-text\">this</code> 的指向会有问题</li>\n</ol>\n<p>然而，在 Cypress 中如果试图直接使用上述方法运行代码，会发现并不能成功。最终生成的报告内并没有对应的 context 信息。其原因在于，Cypress 在运行的过程中，原本被赋值的 <code class=\"language-text\">context</code> 属性被覆盖掉了，导致虽然进行了 <code class=\"language-text\">addContext</code> 的赋值，但是最终的结果中并没有保留这部分数据。</p>\n<p>一个可行的解决方案是，在 <code class=\"language-text\">test:after:run</code> 事件中再进行赋值，保证结果生效。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> addContext <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mochawesome/addContext'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nCypress<span class=\"token punctuation\">.</span>Commands<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'addContext'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">content</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  cy<span class=\"token punctuation\">.</span><span class=\"token function\">once</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test:after:run'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">test</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> test <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>几点说明：</p>\n<ol>\n<li>因为 <code class=\"language-text\">addContext</code> API 本质上就是往 <code class=\"language-text\">test</code> 对象上写 context 数据，而 Cypress 的 API 正好提供了 test 对象，因而第一个参数不需要传 <code class=\"language-text\">this</code>，直接将 test 以合适的方法传入就可以了；</li>\n<li>上面的代码定义了一个 Cypress 的命令方便各个地方调用，类似的代码改成一个普通的函数也是可以的；</li>\n<li>需要用 <code class=\"language-text\">cy.once</code> 保证这个代码只会被调用一次，这样其他的测试用例中不会有类似的数据被写入</li>\n</ol>","frontmatter":{"date":"2019-09-25","title":"Add Context in Mochawesome Report","category":"Cypress"}}},{"node":{"id":"7e8635b2-a762-5558-bf73-f7bb053d0afd","html":"<p>在用 React 处理业务的过程中，经常会遇到这样的场景：某一个 UI 需要等待网络请求来展示，在等待的过程中，需要显示 Loading 界面，并在请求完成后，显示真正的 UI。这种情况，和按需加载模块的行为非常类似。既然 React.Suspense + React.lazy 可以组合用于按需加载模块时候的 UI 展示，那么是否可以使用同样的组合来完成类似等待网络请求的 UI 显示呢？答案是肯定的。下面给出一个示例代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">time</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fakeFetch</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">\"finished!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> Component <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">fakeFetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">text</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">default</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>text<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"App\"</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>React<span class=\"token punctuation\">.</span>Suspense fallback<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>loading<span class=\"token operator\">...</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello World<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>Component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>React<span class=\"token punctuation\">.</span>Suspense<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如此一来，在 Promise 没有返回的时候，组件会显示 <code class=\"language-text\">&lt;div&gt;loading...&lt;/div&gt;</code>。而等到 Promise resolve 之后，就会显示真正的 UI。</p>\n<p>几点说明：</p>\n<ol>\n<li><code class=\"language-text\">React.lazy</code> 本身是为 <code class=\"language-text\">import()</code> 设计的，所以在 Promise 返回的时候，需要将组件放到 <code class=\"language-text\">default</code> 属性下面，保持和 <code class=\"language-text\">import()</code> 的行为一致；</li>\n<li><code class=\"language-text\">React.Suspense</code> 和 <code class=\"language-text\">React.lazy</code> 的组合，本质上内部是使用了 <code class=\"language-text\">throw</code> + <code class=\"language-text\">componentDidCatch</code> 的方式进行实现的，因而如果不使用 <code class=\"language-text\">React.lazy</code>，直接在组件内 <code class=\"language-text\">throw Promise</code>，也可以达到类似的效果：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fakeFetch</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">fn</span> <span class=\"token operator\">=></span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"finished!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> data <span class=\"token operator\">=</span> <span class=\"token string\">\"before\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Component</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data <span class=\"token operator\">===</span> <span class=\"token string\">\"before\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token function\">fakeFetch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newData</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      data <span class=\"token operator\">=</span> newData<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"App\"</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>React<span class=\"token punctuation\">.</span>Suspense fallback<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>loading<span class=\"token operator\">...</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello World<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>Component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>React<span class=\"token punctuation\">.</span>Suspense<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-09-24","title":"Suspense & Lazy in React","category":"JavaScript"}}},{"node":{"id":"9f0ffe72-aaac-5ece-9abb-6023471761dd","html":"<p>一般情况下，只有当用户有操作的情况下，在一个 tick 里，JavaScript 通过 <code class=\"language-text\">window.open</code> 或是 <code class=\"language-text\">&lt;a target=&quot;_blank&quot;&gt;</code> HTML 元素直接 <code class=\"language-text\">click</code> 打开新的窗口才能正常弹出。如果一旦涉及到异步的操作，弹框就会默认被浏览器阻止，无法正常显示。</p>\n<p>这样设计的初衷，是为了防止前端随意弹框，影响到用户正常的体验。然而，在某些情况下，用户操作后需要经过网络请求，返回结果后才知道应该如何展示弹框。这种情况下，简单的 <code class=\"language-text\">fetch().then(() =&gt; window.open())</code> 肯定是不行的。需要一些 Hack 的方案，如下。</p>\n<p>在用户进行了操作之后，首先先打开一个新的窗口，等到异步操作返回之后，再通过 JavaScript 修改这个窗口的地址，从而达到异步打开窗口的目的。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">element<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onclick</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> win <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 模拟异步操作</span>\n  <span class=\"token keyword\">await</span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  win<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> <span class=\"token string\">'actual location'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这样操作可能的问题及解决方法：</p>\n<ol>\n<li>如果在异步的过程中本窗口被关闭了，就会留下一个空白的新窗口。因而，需要监听 <code class=\"language-text\">beforeunload</code> 事件，以保证必要时候可以关闭新打开的窗口；</li>\n<li>如果异步的时间比较长，打开一个空白的窗口用户体验较差（打开后默认会获得焦点）。这种情况下，可以打开一个静态的页面，展示一个 loading 的 UI 以告诉用户当前正在进行的操作。待异步操作完成，再通过 postMessage 等方式通知窗口进行页面的跳转。</li>\n</ol>","frontmatter":{"date":"2019-09-23","title":"Open Window Async","category":"JavaScript"}}},{"node":{"id":"b95258d9-4be2-55c1-bc37-5a5f19841f21","html":"<p>在实际的开发过程中，经常有多分支并发操作的情况，比如：</p>\n<ol>\n<li>PC 软件需要维护多个版本，在新的版本分支上开发新功能，同时维护旧的版本以修复问题；</li>\n<li>针对 Gerrit 这类只允许单 commit 迁入的工具，一个版本开发多个功能，可能需要分成多个分支同时进行</li>\n</ol>\n<p>这种情况下，在版本间切换往往有两个常见的方式：</p>\n<ol>\n<li>将当前的代码 stash 后，切换分支，进行对应的处理，处理完了再回到原来的分支 <code class=\"language-text\">git stash pop</code> 继续原先的开发工作；</li>\n<li>直接 <code class=\"language-text\">git clone</code> 一个新的仓库，在上面完成必要的工作</li>\n</ol>\n<p>第一种方案的问题主要是，切换多次的话，很容易搞不清楚当前分支下还有哪些是 stash 的，管理起来有点麻烦。有时候方便起见，也会直接将当前的内容 commit 到分支上，再进行切换。考虑到 git hook 的存在，commit 可能还需要加上 <code class=\"language-text\">--no-verify</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> <span class=\"token function\">add</span> -A <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> commit -m <span class=\"token string\">\"wip\"</span> --no-verify</code></pre></div>\n<p>第二种方案的问题主要是，多个文件仓库重复下载了多次 <code class=\"language-text\">.git</code> 目录，在一些大型项目中，这里会导致大量的硬盘空间被浪费。</p>\n<p>Git 在 2.5 版本中提供了 worktree 的功能，用于解决这一痛点。在一个 Git 项目中，只需要执行如下的命令，就可以新创建一个文件仓库：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree <span class=\"token function\">add</span> -b new-branch-name /path/to/folder origin/branch/name</code></pre></div>\n<p>新创建的文件仓库被放在 <code class=\"language-text\">/path/to/folder</code> 中，使用的仓库名称是 <code class=\"language-text\">new-branch-name</code>，基于 <code class=\"language-text\">origin</code> 上的 <code class=\"language-text\">branch/name</code>。如果只需要使用一个已经存在的分支，可以简化成：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree <span class=\"token function\">add</span> /path/to/folder local/branch/name</code></pre></div>\n<p>之后，在 <code class=\"language-text\">/path/to/folder</code> 中就可以进行常规的开发了。值得一提的是，原 Git 目录下的 Hook 文件也会一并同步到新的工作目录下，可以直接使用。通过查看目录下的文件，不难发现 Git 的同步方式。事实上，在 WorkTree 目录下，并没有一个 <code class=\"language-text\">.git</code> 目录，取而代之的，只有一个 <code class=\"language-text\">.git</code> 文件，里面标注了真正的 <code class=\"language-text\">.git</code> 目录应该去那里查找。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">gitdir: /path/to/actual/.git/worktrees/name</code></pre></div>\n<p>也正因为如此，WorkTree 下所有的 Git 配置都是同步的。</p>\n<p>如果需要查看当前的 Git 中到底有多少个 WorkTree，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree list</code></pre></div>\n<p>命令会列出所有 WorkTree 的目录以及当前使用的分支名称。</p>\n<p>在开发完成后，如果希望删除 WorkTree，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree remove /path/to/folder</code></pre></div>\n<p>删除完成后，可以通过 <code class=\"language-text\">git worktree list</code> 来检查是否真的被删除了。</p>\n<p>延伸阅读：</p>\n<ul>\n<li><a href=\"https://git-scm.com/docs/git-worktree\">官方文档</a></li>\n<li><a href=\"https://spin.atomicobject.com/2016/06/26/parallelize-development-git-worktrees/\">Parallelize Development Using Git Worktrees</a></li>\n<li><a href=\"https://www.saltycrane.com/blog/2017/05/git-worktree-notes/\">git worktree notes</a></li>\n</ul>","frontmatter":{"date":"2019-09-22","title":"Git Worktree","category":"Git"}}},{"node":{"id":"de5b8ad5-a04c-56e0-9009-c61442c38736","html":"<p>在 React 的开发中，需要在 Component 的 render 函数或是 Functional Component 的函数中，返回一个定义好的 JSX 内容，用于表示具体需要渲染出来的 UI 样式。Babel 或 TypeScript 会在编译时将这个对象转化成一个 JavaScript 可以理解的一般函数调用（具体调用的函数根据库的不同可能存在差异，对于 React 来说就是 <code class=\"language-text\">React.createElement</code> 函数，对于 Preact 来说则是 <code class=\"language-text\">h</code> 函数）。这个函数会在运行时被执行，并返回一个普通的 Object。React 拿到这个 Object 之后，就可以根据其中的内容来渲染出对应的 UI（根据具体执行的环境，这个步骤可能通过 React-DOM 或 React Native 来完成）。</p>\n<p>既然 JSX 的部分会被编译成普通的函数调用，并在运行时被反复执行，这里必然会有一些性能上的损耗。</p>\n<p>而在实际的开发中，存在着很多的组件，实际需要返回的 JSX 是固定不变的。比如说：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在上面这个例子中，实际上条件的第一种结果，返回的 JSX 是一个固定的值。手动的优化可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> loadingComponent <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> loadingComponent<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样，每次当 <code class=\"language-text\">loading = true</code> 的时候，都会直接返回 <code class=\"language-text\">loadingComponent</code>，而不需要反复执行 <code class=\"language-text\">React.createElement(Loading)</code> 这个函数去拿到最终的返回 Object。除了在运行时减少了重复计算，节省了时间和内存开销（这个在 re-render 非常频繁的时候有一定的优势），另一个好处是，React 可以通过比较返回的结果知道 Object 并没有发生变化，从而直接结束渲染的流程，不再进行接下来更深层次的渲染。</p>\n<p>这部分的操作，其实可以交给编译器去完成。Babel 有一个插件 <code class=\"language-text\">@babel/plugin-transform-react-constant-elements</code> 可以拿来做这方面的优化，具体的使用方式以及可能存在的问题可以参考<a href=\"https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements/\">文档</a>。</p>\n<p>当然，上面的优化依然存在小的瑕疵：因为把创建 Object 的操作提到了初始化的时候就直接进行了，如果存在大量类似的优化，会导致 JavaScript 初始运行的速度被减慢。大量的 Object 被事先创建了出来，而实际上这部分内容都远还没有到需要用的时候。一个更极致的优化可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> loadingComponent<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>loadingComponent<span class=\"token punctuation\">)</span> loadingComponent <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> loadingComponent<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这部分的操作就不是 Babel 插件原生支持的了。</p>\n<p>从目前的实际情况来看，生成 JSX 对应 Object 拖慢初始化的例子暂时还不存在（毕竟 <code class=\"language-text\">React.createElement</code> 的执行速度并不是非常慢，而且一个项目中的 JSX 数量也不会非常庞大）。如果有必要，可以 <a href=\"https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-react-constant-elements\">GitHub</a> 上提出 PR，按照类似上面提到的方式进行进一步的优化。</p>","frontmatter":{"date":"2019-09-19","title":"Babel JSX Improvement","category":"Build"}}},{"node":{"id":"060923b5-5ddc-5a04-a343-4fa21b287b7f","html":"<p>在判断一个 DOM 节点是否包含另一个节点的时候，常常用到 <code class=\"language-text\">contains</code> 这个 API。在实际的使用从过程中，也经常会遇到这样的情况，需要判断 A 是否包含 B，返回是 <code class=\"language-text\">false</code>，但经过排查，发现其实 A 和 B 就是同一个节点。这种情况下，光用 <code class=\"language-text\">contains</code> API 就有点不够用了。同时，也暴露了这个 API 本身能力的局限性。</p>\n<p>在 DOM Level 3 的<a href=\"https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-compareDocumentPosition\">规范</a>中，定义了一个新的 API，<code class=\"language-text\">compareDocumentPosition</code>。相比于 <code class=\"language-text\">contains</code>，<code class=\"language-text\">compareDocumentPosition</code> 提供了更强大的判断结果。</p>\n<p><code class=\"language-text\">compareDocumentPosition</code> 这个 API 比较后会返回一个数字，通过二进制位的比较，可以用于判断两个节点之间的关系。假设调用的函数为 <code class=\"language-text\">A.compareDocumentPosition(B)</code>，那么返回值具体支持的类型如下：</p>\n<table>\n<thead>\n<tr>\n<th>常量名</th>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code></td>\n<td>1</td>\n<td>不在一个文档中</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_PRECEDING</code></td>\n<td>2</td>\n<td>B 在 A 之前</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_FOLLOWING</code></td>\n<td>4</td>\n<td>B 在 A 之后</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_CONTAINS</code></td>\n<td>8</td>\n<td>B 包含 A</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_CONTAINED_BY</code></td>\n<td>16</td>\n<td>A 包含 B</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code></td>\n<td>32</td>\n<td>A 和 B 的位置关系取决于具体的实现方式（不由规范确定）</td>\n</tr>\n</tbody>\n</table>\n<p>这里之所以使用二进制位表示位置关系，一个很重要的原因就是：API 有可能会一次性返回多个结果。举个例子，假设 <code class=\"language-text\">A.contains(B)</code> 返回 <code class=\"language-text\">true</code>。那么，在调用 <code class=\"language-text\">A.compareDocumentPosition(B)</code> 的时候，返回值是 <code class=\"language-text\">20</code>，也就是 <code class=\"language-text\">Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY</code> 的结果。换句话说，B 元素在文档中的位置在 A 的后面，同时 B 也是 A 的一个子元素。</p>\n<p>这里，<code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code> 表示两个节点不再同一个文档中，有几种可能的情况：</p>\n<ol>\n<li>A 和 B 中某一个存在于 iframe 中，因而两者不属于同一个文档（<code class=\"language-text\">A.ownerDocument !== B.ownerDocument</code>）；</li>\n<li>A 和 B 中某一个元素被删除了（或没有插入到 DOM 中），导致两者不属于同一个文档（可以通过 <code class=\"language-text\">A.parentElement</code> 和 <code class=\"language-text\">B.parentElement</code> 判断是否被删除，被删后就没有父元素了）</li>\n</ol>\n<p>另外，<code class=\"language-text\">DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code> 有两种情况：</p>\n<ol>\n<li>A 和 B 没有任何相同的 container，这种情况和 <code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code> 是等价的。换句话说，当有 <code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code> 的时候，一定同时有 <code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code>；</li>\n<li>A 和 B 是同一个元素的两个属性值，这种情况下，谁先谁后是由具体实现决定的。比如，<code class=\"language-text\">Element.attributes</code> 返回一个 <code class=\"language-text\">NamedNodeMap</code>。根据<a href=\"https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1780488922\">规范</a> 的定义，<code class=\"language-text\">NamedNodeMap</code> 不维护一个具体的顺序，但同时提供使用 index 访问的 API。也就是说，<code class=\"language-text\">Element.attributes</code> 中的任意两个字段，是没有定义上的先后之分的（虽然可能通过不同的下标获取到）。具体来说：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// div = &lt;div id=\"id\" class=\"class>&lt;/div></span>\n<span class=\"token keyword\">const</span> attributes <span class=\"token operator\">=</span> div<span class=\"token punctuation\">.</span>attributes<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> attributes<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareDocumentPosition</span><span class=\"token punctuation\">(</span>attributes<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// result = 36</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，<code class=\"language-text\">compareDocumentPosition</code> 返回的结果是 <code class=\"language-text\">36</code>，即 <code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING</code>。因此，在实际使用 API 的时候，有必要检查是否有 <code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code> 这一位，如果有的话，其他的结果都可以忽略不计了。</p>\n<p>另外，如果 A 和 B 是同一个元素，那么返回的结果将是 <code class=\"language-text\">0</code>，因为 A 和 B 的关系不属于上面列出的任何一种情况。同时，也不难发现，只有当 A 和 B 是同一个元素的时候，才会出现返回值是 0 的情况。</p>","frontmatter":{"date":"2019-09-18","title":"compareDocumentPosition","category":"JavaScript"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}