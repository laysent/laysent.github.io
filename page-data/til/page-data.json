{"componentChunkName":"component---src-pages-til-js","path":"/til/","webpackCompilationHash":"e6ece375915cc981625d","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"142aa83b-239d-50b5-945f-7bff7ae9d9b3","html":"<p>在 VSCode 中，搜索的时候，默认会将选中的文字填充到搜索框中。这是一个见仁见智的功能，有时候并不非常好用。</p>\n<p>可以通过一下方式取消这一行为：</p>\n<ol>\n<li>打开 Preferences > Settings</li>\n<li>搜索 <code class=\"language-text\">Seed Search String From Selection</code></li>\n<li>取消勾选</li>\n</ol>","frontmatter":{"date":"2019-08-21","title":"Seeding Search in VSCode","category":"VSCode"}}},{"node":{"id":"5b377b6b-3612-54d4-8aa9-83e052dd29c6","html":"<p>在前端组件中，有不少组件对鼠标的响应并不是通过 CSS 的 hover 来触发的，而是通过 JavaScript 监听对应的鼠标事件，然后再进一步修改 DOM 的结构。比如，Ant Design 中的 <a href=\"https://ant.design/components/popover/\">Popover</a> 控件，在鼠标移上去后，会在 DOM 中插入一组元素，并在鼠标移开后删除。</p>\n<p>在这种情况下，一旦出现样式上的问题，就不容易在 DevTool 中对样式进行查看了。因为只要一点击右键审查元素，Popover 的内容很可能就会因为触发了鼠标事件而消失不见。</p>\n<p>对于这种情况，没法直接用 DevTool 中的 CSS 模拟来强制样式显示。如果需要通过触发事件来触发 DOM 的修改机制（不论是 <code class=\"language-text\">dispatchEvent</code> 还是在 React Extension 中触发回调），总体上是比较麻烦的。因为组件的层级结构很可能很复杂，知道应该往哪儿触发什么事件，也不是个容易的事情。</p>\n<p>既然从程序的角度触发比较复杂，不如换个思路，考虑从行为的角度来触发。比如，如果是通过鼠标悬停触发的样式修改，那么就直接通过这种行为来触发。唯一的问题是：应该如何保持这种样式，不在鼠标离开的时候被重制（否则就没法在 DevTool 里进行查看了）。</p>\n<p>这种时候，有一个简单的方法可以“暂停”浏览器。在 Console 中输入：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">debugger</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>就会在三秒后触发 <code class=\"language-text\">debugger</code>，从而暂停 JavaScript 的执行。这时候，鼠标离开的事件不会得到响应，也就可以安心在 DevTool 中对样式进行仔细的查看和调整了。</p>\n<p>当然，这里触发 <code class=\"language-text\">debugger</code> 的方式可以根据实际情况来写。只要保证在 DOM 改变后触发 <code class=\"language-text\">debugger</code> 就可以了。</p>","frontmatter":{"date":"2019-08-20","title":"Inspect Element after MouseEnter","category":"Chrome"}}},{"node":{"id":"31600c51-582c-5fcb-8841-b0cde5d94aa8","html":"<p>当 <code class=\"language-text\">display: inline-block</code> 和 <code class=\"language-text\">overflow: hidden</code> 一起使用的时候，会发现文字的显示比一般正常的情况要“高”一些。举个例子来说：</p>\n<p><span>g<span style=\"display:inline-block;overflow:hidden;color:#f54a45\">o</span>od</span></p>\n<p>上面的四个文字中，第一个 <code class=\"language-text\">o</code> 被设置为 <code class=\"language-text\">display:inline-block</code> 以及 <code class=\"language-text\">overflow:hidden</code>。最终的显示效果，第一个 <code class=\"language-text\">o</code> 的底部明显高于两边的 <code class=\"language-text\">g</code> 和 <code class=\"language-text\">o</code>。</p>\n<p>通过给第一个 <code class=\"language-text\">o</code> 和整行文字画上边框，不难发现，这个文字是整体被抬高了。</p>\n<p><span style=\"border:1px solid #007acc\">g<span style=\"display:inline-block;overflow:hidden;color:#f54a45;border:1px solid #ffe564\">o</span>od</span></p>\n<p>在上面的例子中，<code class=\"language-text\">inline-block</code> 的高度是由 <code class=\"language-text\">line-height</code> 决定的，因而看上去会比 <code class=\"language-text\">inline</code> 情况时候的要高（<code class=\"language-text\">inline</code> 情况下 border 画出来的高度是固定的，由 <code class=\"language-text\">font-family</code> 和 <code class=\"language-text\">font-size</code> 决定）；同时，<code class=\"language-text\">overflow:hidden</code> 会让内容的底部和父元素的文字基线（baseline）持平，从而会让整体的显示结果更高（这一点从上面的显示中不难发现，其中 <code class=\"language-text\">g</code> 的部分有少量是低于基线显示的，可以看到也低于第一个 <code class=\"language-text\">o</code> 的底部区域）。</p>\n<p>因此，在这种情况下，<code class=\"language-text\">line-height</code> 越大，会看到这种情况下的文字越是高，高出来的空白区域主要是 <code class=\"language-text\">line-height</code> 本身比文字大的部分，以及对齐方式不同造成的差异距离。</p>\n<p>上述这种情况，想要正确的对齐，只需要修改垂直对齐的方式就可以了。设置 <code class=\"language-text\">vertical-align:bottom</code> 后的结果：</p>\n<p><span>g<span style=\"display:inline-block;overflow:hidden;color:#f54a45;vertical-align:bottom\">o</span>od</span></p>\n<p>符合预期。</p>","frontmatter":{"date":"2019-08-19","title":"Overflow & InlineBlock","category":"CSS"}}},{"node":{"id":"4dd889a0-b599-5758-afdd-6d90f9f867c4","html":"<p>在 Web 中，如果希望点击一个链接可以进行下载的操作，有以下两种方案可供参考：</p>\n<section><h2>后端的解决方案</h2><p>后端在返回 Response Header 的时候，可以通过指定 <code class=\"language-text\">Content-Disposition</code> 的值，来改变浏览器默认对链接的行为，从而达到让浏览器直接下载某一个资源的目的。这里，<code class=\"language-text\">Content-Disposition</code> 的第一个参数有两种值可写：<code class=\"language-text\">inline</code> 和 <code class=\"language-text\">attachment</code>。其中，<code class=\"language-text\">inline</code> 是默认的值，表示响应中的消息体会以页面的形式展示，而 <code class=\"language-text\">attachment</code> 则会将这个行为改成下载到本地。</p><p>设置成 <code class=\"language-text\">attachment</code> 之后，还可以进一步通过配置 <code class=\"language-text\">filename</code> 来指定下载文件的文件名。例子如下：</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Content-Disposition: attachment; filename=&quot;example.jpg&quot;</code></pre></div><p>如此设置之后，前端在访问到这个 URL 的时候，浏览器就会以 <code class=\"language-text\">example.jpg</code> 为文件名下载当前的资源了。</p><p>更多相关的介绍可以参考<a href=\"https://juejin.im/post/5d521575f265da03ee6a4bda\">这篇文章</a>。</p></section>\n<section><h2>前端的解决方案</h2><p>除了后端的解决方案之外，前端也可以通过指定 <code class=\"language-text\">a</code> 标签中的 <code class=\"language-text\">download</code> 字段来下载文件。对于使用了 <code class=\"language-text\">download</code> 字段的 <code class=\"language-text\">a</code> 标签，点击后的默认行为将会有跳转浏览改成文件下载。<code class=\"language-text\">download</code> 属性可以跟一个文件名作为值，浏览器会将这个值作为下载文件的文件名来使用。</p><p>当然，前端的方案相对来说会有更多的限制，主要是以下几点：</p><ol>\n<li>文件必须是同域的，对于跨域的资源，<code class=\"language-text\">download</code> 并不会直接触发下载功能，行为上会和在新窗口打开资源一致；</li>\n<li>如果后端在 <code class=\"language-text\">Content-Disposition</code> 指定了不同的文件名，那么会以后端指定的结果为准</li>\n<li>如果后端 <code class=\"language-text\">Content-Disposition</code> 设置为 <code class=\"language-text\">inline</code>，不同的浏览器会有不同的行为：Firefox 会按 <code class=\"language-text\">Content-Disposition</code> 的结果来执行；Chrome 则会按 <code class=\"language-text\">download</code> 字段的设置来执行</li>\n</ol><p>更多细节可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a\">MDN</a> 文档的相关部分。</p></section>","frontmatter":{"date":"2019-08-15","title":"Download in HTML","category":"HTML"}}},{"node":{"id":"46d018b7-4b20-5c51-a532-4888709f833f","html":"<p>JavaScript 内建的 <code class=\"language-text\">String.prototype.replace</code> 函数，如果传入的第一个参数是字符串，那么替换行为只会发生一次。如果需要将一个字符串内所有某子字符串都替换掉，往往需要一些额外的操作。以下提供一些可行的方案：</p>\n<ol>\n<li>使用循环进行多次替换</li>\n</ol>\n<p>最直观的想法，就是替换完成后通过 <code class=\"language-text\">indexOf</code> 等方案查找字符串，如果还有就继续替换：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input<span class=\"token punctuation\">,</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> input <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">,</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当然，这并不是一个优雅的解决方案。</p>\n<ol start=\"2\">\n<li>使用正则表达式</li>\n</ol>\n<p><code class=\"language-text\">String.prototype.replace</code> 支持第一个参数传递正则表达式。有了正则表达式，只要设置上 <code class=\"language-text\">g</code> 标签，就可以全局匹配并替换所有的情况了。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input<span class=\"token punctuation\">,</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这个方案的劣势在于，如果需要替换的内容中含有某些正则表达式特有的匹配符号，可能会导致非预期的结果。举个例子来说，如果希望把 <code class=\"language-text\">.+</code> 这个字符串替换成 <code class=\"language-text\">+.</code> 这样，上面的函数并不能达到预期的效果，因为 <code class=\"language-text\">.+</code> 在正则表达式中可以匹配任意的字符。<code class=\"language-text\">replace(&#39;hello.+world&#39;, &#39;.+&#39;, &#39;+.&#39;)</code> 的执行结果是 <code class=\"language-text\">+.</code>。</p>\n<ol start=\"3\">\n<li>使用 <code class=\"language-text\">split</code> &#x26; <code class=\"language-text\">join</code></li>\n</ol>\n<p>这是一个比较取巧的方案，先用 <code class=\"language-text\">split</code> 函数将字符串进行拆分，然后再用 <code class=\"language-text\">join</code> 将拆分后的结果重新拼接起来。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input<span class=\"token punctuation\">,</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这个方案代码比较简洁，也不会有正则表达式中提到的问题。虽然计算会产生中间变量（数组），但只要不是频繁或在大规模数据上使用，效率的影响可以忽略不计。</p>","frontmatter":{"date":"2019-08-14","title":"Replace All Substring","category":"JavaScript"}}},{"node":{"id":"5dd793e1-7752-53af-b3a3-50e4538c99b4","html":"<p>在使用 stylelint 的时候，发现了一个有趣的问题：如果直接使用 stylelint 的 <code class=\"language-text\">bin</code> 文件对批量 LESS 文件进行检查，程序可以如预期的运行；但是如果把同样的命令写到 <code class=\"language-text\">package.json</code> 中，以 npm script 的方式进行运行，最终被检查的文件就少了很多，实际只有一个文件参与了检查。</p>\n<p>具体来说，<code class=\"language-text\">./node_modules/.bin/stylelint src/**/*.less</code> 这个命令可以检查所有的 LESS 文件，但是把 <code class=\"language-text\">stylelint src/**/*.less</code> 写到 <code class=\"language-text\">package.josn</code> 中之后，再运行却只检查了一个文件。</p>\n<p>通过检查 stylelint 的<a href=\"https://github.com/stylelint/stylelint/blob/master/docs/user-guide/cli.md\">文档</a>，发现官方在写命令的时候，写法和上述略有不同，为：<code class=\"language-text\">stylelint &quot;src/**/*.less&quot;</code>。</p>\n<p>经过排查问题，发现根源在于：<code class=\"language-text\">npm</code> 使用了 <code class=\"language-text\">sh</code> 来执行代码，而 <code class=\"language-text\">sh</code> 和 <code class=\"language-text\">zsh</code> 在解析 Glob 的时候，行为是不同的。</p>\n<p><code class=\"language-text\">npm</code>，包括其他 Linux 进程，在使用 shell 的时候，默认使用的都是 <code class=\"language-text\">sh</code>，除非有其他明确的指定。这意味着，即使当前正在使用的 shell 是 <code class=\"language-text\">zsh</code>，在运行 <code class=\"language-text\">npm</code> 命令的时候，还是默认使用了 <code class=\"language-text\">sh</code> 对脚本进行执行。也就是说，<code class=\"language-text\">./node_modules/.bin/stylelint src/**/*.less</code> 这个命令执行，使用的是当前打开的 shell 程序（比如 <code class=\"language-text\">zsh</code>）；而当这个命令写到 <code class=\"language-text\">package.json</code> 中，并以 npm script 的方式进行运行的时候，执行 shell 的就是 <code class=\"language-text\">sh</code> 了。</p>\n<p>使用不同的 shell 程序，难免就会在行为上造成不一致。这里的 Glob 解析就是一个例子。在 <code class=\"language-text\">zsh</code> 里面可以简单的做一个实验。执行如下的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ls</span> src/**/*.less</code></pre></div>\n<p>可以看到，<code class=\"language-text\">zsh</code> 给出了当前 <code class=\"language-text\">src</code> 目录下所有的 LESS 文件， 不管这个文件是在多深的子目录下；而如果先在 <code class=\"language-text\">zsh</code> 中执行 <code class=\"language-text\">sh</code> 或 <code class=\"language-text\">bash</code> 进入到 <code class=\"language-text\">sh</code> 或 <code class=\"language-text\">bash</code> 的工作环境中，再执行同样的命令，可以看到输出的结果可能就是不同的。实际上，对于 <code class=\"language-text\">sh</code> 来说，它本身并不识别 <code class=\"language-text\">**</code> 这个语法，这个表示在 <code class=\"language-text\">sh</code> 中会被简单的识别为 <code class=\"language-text\">*</code>，<code class=\"language-text\">src/**/*.less</code> 在 <code class=\"language-text\">sh</code> 中等价于 <code class=\"language-text\">src/*/*.less</code>。换句话说，在 <code class=\"language-text\">sh</code> 的环境中，上述命令只会寻找所有在 <code class=\"language-text\">src</code> 目录下一级子目录中的 LESS 文件，一旦层级大于一层，就不会被找到了。</p>\n<p>这也是为什么同样的命令，直接执行和在 npm 中执行会有差异的原因。</p>\n<p>最后，加上双引号 <code class=\"language-text\">stylelint &quot;src/**/*.less&quot;</code> 就可以解决这一问题的原因在于：一旦加上了双引号，这一个 Glob 就不会被 shell 直接解析，而是会以字符串的形式直接传递给 stylelint。（具体来说，如果不加双引号，shell 会先将 Glob 解析成一组具体的文件，stylelint 实际拿到的 <code class=\"language-text\">process.env.argv</code> 很可能会是一个很长的字符串数组，每一个元素都是一个具体的文件；而如果加上了双引号，stylelint 拿到的只有一个 Glob 表达式字符串。）有了这个 Glob 的字符串，stylelint 内部就可以使用相应的 package 来进行解析，从而得到一串具体的文件列表。因为使用了 stylelint 内部自带的 Glob 解析，就可以保证在不同的 shell 环境中都得到一致的结果了。</p>\n<p><a href=\"https://stackoverflow.com/questions/32017169/npm-glob-pattern-not-matching-subdirectories\">参考</a></p>","frontmatter":{"date":"2019-08-13","title":"Glob in NPM","category":"JavaScript"}}},{"node":{"id":"f6e23fb7-0916-5e2d-b9f0-37e5d898e377","html":"<p>在 Chrome 调试的构成中，单步执行代码是常有的操作。然而，一般来说，出问题的很可能是业务代码，具体依赖的库（如 React 或者 Mobx 等）相对则是更加稳定的。如果单步调试的过程中，会频繁进出库相关的代码，显然会对调试造成很多的干扰，不利于问题的排查。</p>\n<p>为此，Chrome 提供了 Blackbox 的功能，可以帮助将部分指定的文件从调试中剔除。一旦使用 Blackbox 剔除了某些代码文件，那么：</p>\n<ul>\n<li>从这些文件中造成的报错不会暂停代码（除非开启了 Pause on exception）</li>\n<li>Step in/out/over 不会执行到这部分的代码</li>\n<li>这些文件中的事件监听断点不会触发</li>\n<li>文件中设置的断点也不会被触发（代码不会暂停）</li>\n</ul>\n<p>有几个方法可以添加 Blackbox：</p>\n<ol>\n<li>打开 DevTools 后按 F1 打开 Settings 界面，然后选择 Blackboxing 并填写</li>\n</ol>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cfc690ef64b8fa20f3d7653491ae0c05/b2a12/2019-08-12-blackbox-rule-screenshot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 40.476190476190474%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKUlEQVQoz41SXY+DIBD0//+7ez7bplV7/UABAUHUzu3Q9OGSXlKScRYWxtmFKoQJg9aIMWLbNoyjg/cezjkYYwsTn4zH44FKa4P9/gClFJZlRdO0aLsO558LmrYr8fF0QpgmzPOMlJJgLgZiTGVOzjk/BUMI6Pu+JLigJFaqRz9oiQcMwpOI0TmdPtkX99aOcKUajyjnOardbl8EmORgTFHO2QpjrThfsK6CP7xKi9bijKbI3FcZY8TFUMQyS27PxZ22TsqcBVlcxPcIMy7XG+q6hhYdVlLxw/7FOGFZN3w3FodO46osBpvk0P8YfRIzBvf7XVoxPgVplw5ft/x18KjPsjYm3HQsP+JL4OZ34Dn2nzG5Yu2vG5KLh3EZXZ9hfZb5Bi4z9yl+Afj4aleYhfmFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"DevTools 设置 Blackbox 匹配规则\"\n        title=\"\"\n        src=\"/static/cfc690ef64b8fa20f3d7653491ae0c05/b9e4f/2019-08-12-blackbox-rule-screenshot.png\"\n        srcset=\"/static/cfc690ef64b8fa20f3d7653491ae0c05/cf440/2019-08-12-blackbox-rule-screenshot.png 148w,\n/static/cfc690ef64b8fa20f3d7653491ae0c05/d2d38/2019-08-12-blackbox-rule-screenshot.png 295w,\n/static/cfc690ef64b8fa20f3d7653491ae0c05/b9e4f/2019-08-12-blackbox-rule-screenshot.png 590w,\n/static/cfc690ef64b8fa20f3d7653491ae0c05/b2a12/2019-08-12-blackbox-rule-screenshot.png 630w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>如果网站的标准库是通过 CDN 文件直接引入的，可以把文件名直接写在这里，如 <code class=\"language-text\">react.min.js</code> 或是 <code class=\"language-text\">jquery.min.js</code> 等；类似的，如果页面是通过 Webpack 进行打包的，那么 vendor 的部分很可能也会打包到一个独立的文件中，比如就叫 <code class=\"language-text\">vendor.xxx.js</code>，那么也可以把相应的匹配写在这里。</p>\n<ol start=\"2\">\n<li>打开 DevTools 后在 Sources 标签下找到需要屏蔽的文件，在文件内容处右键，并选择 Blackbox</li>\n</ol>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/301011fa6736a78f21b3cd10071e7032/34e8a/2019-08-12-blackbox-file-screenshot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 75.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAADXklEQVQ4y22UaU8bVxSG/Y+rSpWaECirsWPAJsZmTwihCRE7iVpFaqUqn5CifmlTiPG+jtdZPB7PeOXpmYHkQ9UZvZp7Z3nuec+cc30tVeM2maFYqqBpGrlcllarhaq2KBQKlEpF7747d5/puk61WiWVSlEu33+TzeZQlKr3na9aF0ihQjZfIZ0tCjxNKp2lUCyTyeb5+/M11zcJT/lCiVqtLnAVTdQ2NMy2jmnoNOpVWaCMz+4Y3BQtrm6apDN5EqkSyUyZVLbC9W2OL6kCLcOmpdu0rQH9/oDxaITTH1FRh9T04f1V66HpBr5Ox6RpOFRbHbGXkyhyYjVHLp/xxuVSXqJSUMVOvVaVcc2TLhGWlYaoTrGsU67odHUNX7vdZjjo4TgWxWaJdDVFopL4prSS5rZ8i6IqdO0uw+FQ3h9yJ1GOR0PGD/OBaDQY3AMdp4fV7WLabQzbQLd1fv/4G29PDrn85YKjsyPO3p1y8f6ct0eH7B+85OrTFc7IwepZfD1GsogH7AmwK0Dd0ml2mmhdjZ29bVYiS2xurxN+tsLWzgar0TCPJn/k+x++4+BwH6NneO/2hz36o77k1XkA9nrYti25bJKtZkgpKV7s77AcDrGxHScSXSG+sUY0tkpsPUpoKcj+mz3qao2sIrmuF0iWkqi6KkBTLNsOmpSA0qhIYjvoUltvXr8isOT3QC5wfStGfHONYGiRyZ8mODs7pafZdJumlE4XtWHgGF18pml6ds22SbVd5y/lmkQzzfOfn7MQmCMcXebpSoDlSIgl0Zx/honJRxxLXv97DN0cukDXrmEYNBrSFWJBqyTZfblBUECxzSirsQjP4qtE1sLMLc4yMfWY88szDzIej7m7u/PGg69/2QXqUu1G9h/sP//A+fCaw70t/MuLrMYjhCJPPaA/5GdmYZrHArx4d/H/QNeuK6tjUe+qfG4kuW3lxPIuoXDQizC4HGDGP82sRLcQnOeJ5PD4/NiD3D2cnuWhAN3GtizLa/KW1qDTNmibOjsvNgkE5omuRZhfmOXJ1IT8jEmmpiclhxOcnJ7cRzgYC8ktQrnI2Hd980WaXWCymzRkx2iUa9JKec5/PWX31TYHR/ts7W0Q24kS34190+WHSxKFhGwsGSqFIsVCnqK05L9QZQ5M8/57MAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"DevTools 设置单个文件 Blackbox\"\n        title=\"\"\n        src=\"/static/301011fa6736a78f21b3cd10071e7032/b9e4f/2019-08-12-blackbox-file-screenshot.png\"\n        srcset=\"/static/301011fa6736a78f21b3cd10071e7032/cf440/2019-08-12-blackbox-file-screenshot.png 148w,\n/static/301011fa6736a78f21b3cd10071e7032/d2d38/2019-08-12-blackbox-file-screenshot.png 295w,\n/static/301011fa6736a78f21b3cd10071e7032/b9e4f/2019-08-12-blackbox-file-screenshot.png 590w,\n/static/301011fa6736a78f21b3cd10071e7032/34e8a/2019-08-12-blackbox-file-screenshot.png 600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p><a href=\"https://developer.chrome.com/devtools/docs/blackboxing\">参考文档</a></p>","frontmatter":{"date":"2019-08-12","title":"Chrome DevTools Blackbox","category":"Chrome"}}},{"node":{"id":"09d8bc9f-9e58-54de-9b47-3f8838554b24","html":"<p>在 SQLite 中，如果需要对列表的字符串数据做一些简单的变化，可以直接通过 SQLite 内建的函数来完成，而不需要借助外部的程序语言（如 Node.js）。使用内建的操作，转化的效率会远高于使用外部的语言来进行操作。下面通过一些例子来简单介绍一些和字符串相关的操作方法：</p>\n<section><h2>字符串截取</h2><p>可以使用 SQLite 自带的 <code class=\"language-text\">substr</code> 的函数来截取字符串。函数的签名是 <code class=\"language-text\">substr(string, start, length)</code>，其中 <code class=\"language-text\">start</code> 和 <code class=\"language-text\">length</code> 可以是负数，具体的行为可以参考<a href=\"http://www.sqlitetutorial.net/sqlite-functions/sqlite-substr/\">这里</a>的介绍。</p><p>假设有一列图像文件相关的数据：</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">xxx.jpg\nyyy.gif\nzzz.png</code></pre></div><p>想要统计文件的格式，一个简单的写法如下（不考虑 <code class=\"language-text\">.jpeg</code> 之类的情况）：</p><div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> substr<span class=\"token punctuation\">(</span>image_column_name<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> suffix <span class=\"token keyword\">from</span> table_name <span class=\"token keyword\">group</span> <span class=\"token keyword\">by</span> suffix<span class=\"token punctuation\">;</span></code></pre></div><p>需要注意的一点是，SQLite 中的 <code class=\"language-text\">substr</code> 函数，记录的 start 下标，是从 1 而不是 0 开始的。</p></section>\n<section><h2>查找字符</h2><p>在上例中，如果需要考虑 <code class=\"language-text\">.jpeg</code> 之类的情况，直接写死起始数字的下标就显得不太合适了。这时候，可以使用 <code class=\"language-text\">instr</code> 来配合查找：</p><div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> substr<span class=\"token punctuation\">(</span><span class=\"token keyword\">column</span><span class=\"token punctuation\">,</span> instr<span class=\"token punctuation\">(</span><span class=\"token keyword\">column</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> suffix <span class=\"token keyword\">from</span> table_name<span class=\"token punctuation\">;</span></code></pre></div><p><code class=\"language-text\">instr</code> 的文档可以看<a href=\"http://www.sqlitetutorial.net/sqlite-functions/sqlite-instr/\">这里</a>。</p></section>\n<section><h2>字符串长度</h2><p>如果需要删除字符串的最后几位，光有 <code class=\"language-text\">substr</code> 函数就不够用了，还需要知道一个字符串具体的长度，才能确定需要截取的字符串长度是多少（定长字符串除外）。这就需要 SQLite 自带的 <code class=\"language-text\">length</code> 函数了。细节可以参见<a href=\"http://www.sqlitetutorial.net/sqlite-functions/sqlite-length/\">文档</a>，以下举一个实际的例子。</p><p>假设有一列身高相关的数据：</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">170cm\n168cm\n182cm</code></pre></div><p>想要截取其中数字的部分，可以使用 <code class=\"language-text\">substr</code> 和 <code class=\"language-text\">length</code> 配合着这么写：</p><div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> substr<span class=\"token punctuation\">(</span><span class=\"token keyword\">column</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> length<span class=\"token punctuation\">(</span><span class=\"token keyword\">column</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span><span class=\"token punctuation\">;</span></code></pre></div><section><h3>字符串转数字</h3><p>接着上文的例子，如果希望进一步把字符串转化成数字，可以使用 <code class=\"language-text\">cast</code> 函数：</p><div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> cast<span class=\"token punctuation\">(</span><span class=\"token string\">'170'</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">integer</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>结合起来：</p><div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> cast<span class=\"token punctuation\">(</span>substr<span class=\"token punctuation\">(</span><span class=\"token keyword\">column</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> length<span class=\"token punctuation\">(</span><span class=\"token keyword\">column</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">integer</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span><span class=\"token punctuation\">;</span></code></pre></div><p>注意，这里 <code class=\"language-text\">substr</code> 和 <code class=\"language-text\">cask</code> 函数在处理 <code class=\"language-text\">NULL</code> 的时候，都是不会做任何操作，直接返回 <code class=\"language-text\">NULL</code> 的。因此，如果上述的列中有数据是 <code class=\"language-text\">NULL</code> 而不是字符串，使用 <code class=\"language-text\">cask</code> + <code class=\"language-text\">substr</code> 的操作也会得到 <code class=\"language-text\">NULL</code> 的结果，不会有报错或其他问题。</p></section><section><h3>转化成 NULL</h3><p>然而在上例中，如果 <code class=\"language-text\">cask</code> 收到的参数是空字符串，那么转换的结果就是 0。这就不一定符合需求了。可以使用 <code class=\"language-text\">nullif</code> 这个操作符，将这种情况强制转化成 <code class=\"language-text\">NULL</code>：</p><div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token keyword\">nullif</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">column</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div></section><section><h3>获取 ASCII 码</h3><p>使用字符串存储的成本会比使用整数来的大一些。除了上面提到的将字符串直接转化成数字的例子，对于一些单个字符类型的值，转化成数字存储也不失为一个好方案。比如，将某组 <code class=\"language-text\">A</code> 到 <code class=\"language-text\">Z</code> 的字母转化成 <code class=\"language-text\">0</code> 到 <code class=\"language-text\">25</code> 的数字。这时候，就可以使用 <code class=\"language-text\">unicode</code> 函数了：</p><div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> unicode<span class=\"token punctuation\">(</span><span class=\"token keyword\">column</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">65</span> <span class=\"token keyword\">from</span> table_name<span class=\"token punctuation\">;</span></code></pre></div><p>这里 <code class=\"language-text\">65</code> 是 <code class=\"language-text\">A</code> 的 ASCII 码。</p></section></section>","frontmatter":{"date":"2019-08-11","title":"String Manipulation in SQLite","category":"SQLite"}}},{"node":{"id":"d8da12e2-c818-5675-975f-a855ec4bc841","html":"<p>JavaScript 中可以很方便在字符串和数字之间进行转换，比如：<code class=\"language-text\">+&#39;123&#39;</code> => <code class=\"language-text\">123</code>，<code class=\"language-text\">(123).toString()</code> => <code class=\"language-text\">&#39;123&#39;</code>。</p>\n<p>然而，需要注意的一点是，JavaScript 中的数字并不是整数，而是浮点数。更确切的说，数字使用的是 64 bit 双精度浮点数来表示的。这意味着，如果服务器存储的数字是一个 Int64，那么在给到前端的时候，很有可能会出现转化上的问题。对于双精度浮点数来说，能够表示的最大的数是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mn>53</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{53}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">5</span><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，超过的部分就会被截断，无法精确表示。</p>\n<p>比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token string\">'9223372036854775808'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">**</span> <span class=\"token number\">63</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// output: 9223372036854776000</span></code></pre></div>\n<p>JavaScript 提供了 <code class=\"language-text\">Number.isSafeInteger</code> 这个 API 来判断一个数字是否是在可表示的安全范围内。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Number<span class=\"token punctuation\">.</span><span class=\"token function\">isSafeInteger</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">**</span> <span class=\"token number\">63</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// output: false</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Number<span class=\"token punctuation\">.</span><span class=\"token function\">isSafeInteger</span><span class=\"token punctuation\">(</span><span class=\"token number\">9223372036854776000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// output: false</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Number<span class=\"token punctuation\">.</span><span class=\"token function\">isSafeInteger</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">**</span> <span class=\"token number\">53</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// output: true</span></code></pre></div>\n<p>这里，<code class=\"language-text\">2 ** 53 - 1</code> 就是 JavaScript 中可以表示的最大整数，<code class=\"language-text\">Number.MAX_SAFE_INTEGER</code> 这个常量也等于这个值。超过这个数值的所有值都会被认为是不安全的，哪怕该值实际表示的结果“凑巧”是正确的。上例中，<code class=\"language-text\">9223372036854776000</code> 这个数字的表示结果“刚好”就是 <code class=\"language-text\">9223372036854776000</code> 本身，但是因为这个数已经超过了 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mn>53</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{53} - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">5</span><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，所以依然被判定为是不安全的。</p>\n<p>虽然 JavaScript 本身的数字不支持大数，但是 Chrome 已经集成了 <code class=\"language-text\">BigInt</code> 数据类型，它可以被用于表示任意大的整形数字，可以用于这样的使用场景。（注：<code class=\"language-text\">BigInt</code> 本身还在 staging 3，并不是标准的一部分）</p>\n<p>简单的使用方法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> num <span class=\"token operator\">=</span> <span class=\"token function\">BigInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">**</span> <span class=\"token number\">63</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// or:</span>\n<span class=\"token comment\">// const num = BigInt('9223372036854776000');</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// output: 9223372036854775808n</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// output: bigint</span></code></pre></div>\n<p>需要注意的是，<code class=\"language-text\">BigInt</code> 不可以使用 <code class=\"language-text\">new</code> 运算符，否则会报错。直接像函数一样传递参数调用就可以了。</p>\n<p><code class=\"language-text\">BigInt</code> 也是支持数字运算的，运算的结果依然是 <code class=\"language-text\">BigInt</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1n</span> <span class=\"token operator\">+</span> <span class=\"token number\">2n</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => 3n</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3n</span> <span class=\"token operator\">-</span> <span class=\"token number\">1n</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => 2n</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2n</span> <span class=\"token operator\">*</span> <span class=\"token number\">3n</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => 6n</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">5n</span> <span class=\"token operator\">/</span> <span class=\"token number\">2n</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => 2n</span></code></pre></div>\n<p>特别需要注意的是，因为是整型数字之间的转换，所以在做除法的时候，不会出现小数。在上面的例子中，<code class=\"language-text\">5n</code> 和 <code class=\"language-text\">2n</code> 的除法，结果是 <code class=\"language-text\">2n</code> 而不是 <code class=\"language-text\">2.5</code>，这一个行为和 C 中两个 Integer 之间除法的行为是一致的。</p>\n<p>另外，<code class=\"language-text\">BigInt</code> 不支持和其他的数据类型进行混合计算。比如：<code class=\"language-text\">1n + 2</code> 这样的计算是会报错的，需要显式的进行类型转换后，才可以进行运算。这一点，和 JavaScript 中其他数据类型之间随意混乱的运算行为是不同的（比如，<code class=\"language-text\">1 + &#39;2&#39;</code> 这样的计算 JavaScript 就不会报错，还会得到 <code class=\"language-text\">&#39;12&#39;</code> 这样怪异的结果）。</p>\n<p>虽然 <code class=\"language-text\">BigInt</code> 不允许和一般的 <code class=\"language-text\">Number</code> 进行混合计算，但是比较运算符是可以在两者之间进行比较的。比如：<code class=\"language-text\">1n &lt; 2</code> 或 <code class=\"language-text\">2n &gt; 1</code> 这些都是成立的。<code class=\"language-text\">BigInt</code> 和 <code class=\"language-text\">Number</code> 之间无法取得 <code class=\"language-text\">===</code> 的严格等价关系，但是 <code class=\"language-text\">==</code> 的比较是可能成立的。换句话说：<code class=\"language-text\">1n == 1</code> 是成立的，但是 <code class=\"language-text\">1n === 1</code> 是不成立的。</p>\n<p>更多关于 <code class=\"language-text\">BigInt</code> 的行为，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt\">MDN</a>。</p>","frontmatter":{"date":"2019-08-08","title":"Big Number in JavaScript","category":"JavaScript"}}},{"node":{"id":"e0dd7268-fba7-523c-bdcd-ec5a9895590e","html":"<p>OSX 自带的 QuickTime Player 支持屏幕的录制功能。具体的操作步骤如下：</p>\n<ol>\n<li>打开 QuickTime Player</li>\n<li>点击菜单中的 File => New Screen Recording</li>\n<li>拖拽选择需要录制的区域，并点击开始录制，点击右上角可以结束录制</li>\n<li>录屏结束后，可以选择菜单中的 File => Export => As Movie 来保存视频</li>\n</ol>\n<section><h2>转化为 Gif 格式</h2><p>假设上述步骤保存了一个名为 <code class=\"language-text\">in.mov</code> 的视频，通过以下步骤可以将视频转化为 Gif 格式：</p><ol>\n<li>\n<p>右键点击 <code class=\"language-text\">in.mov</code> 文件，选择 <code class=\"language-text\">Get Info</code>，在 <code class=\"language-text\">More Info</code> 中找到视频的大小信息，这里假设大小为 60x40</p>\n</li>\n<li>\n<p>运行如下命令，将 <code class=\"language-text\">in.mov</code> 转化为 <code class=\"language-text\">out.gif</code> 文件</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">ffmpeg -i in.mov -s 60x40 -pix_fmt rgb24 -r 10 -f gif out.gif</code></pre></div>\n<p>这里参数的具体含义如下：</p>\n<ul>\n<li><code class=\"language-text\">-s 60x40</code> 指定了最大宽度和最大高度。这里可以不指定，输出将按照原始大小来。如果指定较小的长宽值，输出将变小。</li>\n<li><code class=\"language-text\">-r 10</code> 将帧数从 25 调整为 10。</li>\n</ul>\n</li>\n</ol><p>如果 <code class=\"language-text\">ffmpeg</code> 命令找不到，可以使用 <code class=\"language-text\">Homebrew</code> 进行安装：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> ffmpeg</code></pre></div></section>\n<section><h2>优化 Gif 文件</h2><p>可以使用 <code class=\"language-text\">gifsicle</code> 命令对产生的 gif 文件进行压缩：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">gifsicle out.gif --optimize<span class=\"token operator\">=</span>3 -o optimized.gif</code></pre></div><p>这里，<code class=\"language-text\">--optimize=3</code> 参数要求 <code class=\"language-text\">gifsicle</code> 使用最高等级优化图片。这会需要更多的时间和 CPU 来计算，但是压缩效果相对也是最好的。</p><p>如果找不到 <code class=\"language-text\">gifsicle</code> 命令，可以使用 <code class=\"language-text\">Homebrew</code> 进行安装：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> gifsicle</code></pre></div><p>经测试，一个 <code class=\"language-text\">463 KB</code> 的文件，压缩后的大小为 <code class=\"language-text\">417 KB</code>，压缩了 10%。</p><p>以上生成 Gif 和优化 Gif 的命令可以放到一起执行：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">ffmpeg -i in.mov -s 60x40 -pix_fmt rgb24 - <span class=\"token operator\">|</span> gifsicle --optimize<span class=\"token operator\">=</span>3 <span class=\"token operator\">></span> out.gif</code></pre></div></section>\n<section><h2>参考</h2><ul>\n<li><a href=\"https://gist.github.com/dergachev/4627207\">https://gist.github.com/dergachev/4627207</a></li>\n<li>该文作者针对 mov 到 gif 的转换写了一个 Ruby 脚本，可以显著提高转化后的质量，脚本见 <a href=\"https://github.com/dergachev/screengif\">https://github.com/dergachev/screengif</a></li>\n</ul></section>","frontmatter":{"date":"2019-08-07","title":"Screen Recording in MacOS","category":"Tool"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}