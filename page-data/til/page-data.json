{"componentChunkName":"component---src-pages-til-js","path":"/til/","webpackCompilationHash":"e6ece375915cc981625d","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"50775b1d-7fc1-5e13-9eb0-5ff1ab27876e","html":"<p>根据 TSLint 官方给出的建议，TypeScript 项目的代码，现在也推荐使用 ESLint 来进行代码规范的检查。</p>\n<p>在具体使用的时候，需要在 <code class=\"language-text\">.eslintrc</code> 中增加如下部分的设置：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"parser\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"@typescript-eslint/parser\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"@typescript-eslint\"</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"parserOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"ecmaVersion\"</span><span class=\"token operator\">:</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"sourceType\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"module\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"project\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./tsconfig.json\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"ecmaFeatures\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"jsx\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>其中，需要用到 <code class=\"language-text\">typescript-eslint</code> 这个库来帮助 ESLint 解析代码（<a href=\"https://github.com/typescript-eslint/typescript-eslint\">GitHub</a>）。</p>\n<p>然而，在实际使用 ESLint 来检查 TypeScript 代码的时候，需要额外注意一个细节：</p>\n<p>根据<a href=\"https://github.com/typescript-eslint/typescript-eslint/issues/355#issuecomment-473353680\">这里</a>给出的解释，ESLint 默认情况下并不会检查非 <code class=\"language-text\">.js</code> 和 <code class=\"language-text\">.jsx</code> 结尾的文件。也就是说，如果 <code class=\"language-text\">src</code> 目录下有以下几个文件：<code class=\"language-text\">src/index.js</code>，<code class=\"language-text\">src/app.tsx</code>，<code class=\"language-text\">src/utils.ts</code>，那么在运行命令 <code class=\"language-text\">eslint src</code> 的时候，只有 <code class=\"language-text\">src/index.js</code> 会被检查，剩下的两个会直接被忽略。</p>\n<p>需要检查 TypeScript 的代码，需要手动在调用 <code class=\"language-text\">eslint</code> 命令行的时候加上 <code class=\"language-text\">--ext</code> 参数，如：<code class=\"language-text\">--ext js,jsx,ts,tsx</code>。</p>\n<p>当然，如果给 ESLint 手动指定需要检查的文件，或是通过 <code class=\"language-text\">lint-staged</code> 工具在 Git 签入的时候对 TypeScript 文件进行检查，这些情况下都是不需要额外指定 <code class=\"language-text\">--ext</code> 参数的，ESLint 可以正确处理 TypeScript 的代码。</p>","frontmatter":{"date":"2019-09-02","title":"ESlint for TypeScript","category":"Tool"}}},{"node":{"id":"8f7c51c8-bc2a-596e-b801-8e6ed41a889d","html":"<p>在 React 中，经常会有这样的场景：通过某一个参数是否是真值，来决定某一个元素是否需要显示出来。</p>\n<p>以 Ant Design 为例，<a href=\"https://ant.design/components/tooltip/\">Tooltip</a> 的定义中，就包含了 <code class=\"language-text\">title</code> 这个参数，用于决定是否显示 Tooltip 及显示什么。如果传递的是 <code class=\"language-text\">false</code>，<code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code>，那么最终 Tooltip 就不会被显示出来。</p>\n<p>常用的调用形式可能如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Tooltip</span></span> <span class=\"token attr-name\">title</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>hide <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">'text'</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>在最初 Ant Design 对此的定义上，使用了如下的 TypeScript 类型定义：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Props</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  title<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> React<span class=\"token punctuation\">.</span>ReactNode <span class=\"token operator\">|</span> RenderFunction<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里，<code class=\"language-text\">title</code> 的定义用到了“可选参数”。看上去，是符合预期的行为，然而这里有几个细节值得注意：</p>\n<ol>\n<li><code class=\"language-text\">React.ReactNode</code> 的定义是：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> ReactNode <span class=\"token operator\">=</span>\n  ReactChild <span class=\"token operator\">|</span> ReactFragment <span class=\"token operator\">|</span> ReactPortal <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">|</span> undefined<span class=\"token punctuation\">;</span></code></pre></div>\n<p>可以看到，即使不是可选参数，<code class=\"language-text\">undefined</code> 等一系列值也是可以赋予给 <code class=\"language-text\">title</code> 的；</p>\n<ol start=\"2\">\n<li><code class=\"language-text\">title?: string</code> 和 <code class=\"language-text\">title: string | undefined</code> 之间存在着细微的差别。</li>\n</ol>\n<p>这里展开对比一下 <code class=\"language-text\">title?: string</code> 和 <code class=\"language-text\">title: string | undefined</code> 之间的细微差别。如果定义的类型是 <code class=\"language-text\">title?: string</code>，那么，以下的调用方式都是正确的：</p>\n<ol>\n<li>传递字符串作为参数：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Tooltip</span></span> <span class=\"token attr-name\">title</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>string<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<ol start=\"2\">\n<li>传递 <code class=\"language-text\">undefined</code> 作为参数：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Tooltip</span></span> <span class=\"token attr-name\">title</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<ol start=\"3\">\n<li>不传递参数：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Tooltip</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>而如果是 <code class=\"language-text\">title: string | undefined</code>，那么上面的第三种方案（即不传参数）就是不可行的。</p>\n<p>还是以 Tooltip 为例，显然前两种调用方法都是真实存在的场景，毕竟 Tooltip 可能是需要根据外部条件来选择性展示的；但是对于第三种场景，即不提供 <code class=\"language-text\">title</code> 数据、一直保持不渲染 Tooltip 的状态，可以认为是有错误的，应该由 TypeScript 进行检查并报错。</p>\n<p>故，改成以下这种形式就可以了，毕竟 <code class=\"language-text\">React.ReactNode</code> 就允许了 <code class=\"language-text\">undefined</code> 的使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Props</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  title<span class=\"token punctuation\">:</span> React<span class=\"token punctuation\">.</span>ReactNode <span class=\"token operator\">|</span> RenderFunction<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ant Design 对这种情况进行了<a href=\"https://github.com/ant-design/ant-design/pull/18515\">修正</a>。</p>","frontmatter":{"date":"2019-08-29","title":"Conditional Props in React","category":"TypeScript"}}},{"node":{"id":"1cc08454-1e44-5baf-abed-ef94a305425b","html":"<p>在 Cypress 开发的过程中，因为其他操作导致内存吃紧，最终 Cypress 被操作系统杀掉。之后，再重启 Cypress，发现一直运行失败，所有 Test 全部都无法执行成功。</p>\n<p>通过 <code class=\"language-text\">cypress open</code> 来打开 UI 并执行任意测试用例，发现浏览器直接返回 No Internet。浏览器给出的建议是：</p>\n<ol>\n<li>检查系统是否联网</li>\n<li>检查是否有 Proxy 配置</li>\n</ol>\n<p>电脑本身可以正常上网，也没有手动进行任何 Proxy 配置，浏览器给出的建议并不能真正解决问题。</p>\n<p>通过 <code class=\"language-text\">ps -ef | grep Cypress</code> 后发现，即使在 Cypress 没有运行的情况下，依然有运行中的进程：</p>\n<p>执行 <code class=\"language-text\">kill</code> 命令杀死这些个进程。再重试 Cypress 就可以正常运作了。</p>","frontmatter":{"date":"2019-08-28","title":"Cypress No Internet","category":"Cypress"}}},{"node":{"id":"0985ea6e-c29c-558d-9d39-e158bb6caccd","html":"<p>在 Cypress 中可以通过字符串来查找和定位元素，常用的命令包括 <code class=\"language-text\">get</code>，<code class=\"language-text\">find</code> 等。这里以 <code class=\"language-text\">get</code> 命令为例，在其<a href=\"https://docs.cypress.io/api/commands/get.html#Syntax\">文档</a>可以看到一些用法的说明。</p>\n<p>JavaScript 中支持的 selector 在 <code class=\"language-text\">get</code> 中都是可以使用的，除此之外，文档指出所有 jQuery 支持的也同样支持。（事实上，在 Cypress 注册命令的<a href=\"https://github.com/cypress-io/cypress/blob/a038e7f5d4c56d3efa844e745da40a3d917fefea/packages/driver/src/cy/commands/traversals.coffee\">代码</a>处可以，可以找到和 DOM 相关的代码，这部分代码中不难发现 jQuery 的<a href=\"https://github.com/cypress-io/cypress/blob/0e3289debd1323ad7c6b5f11a573685f24d56629/packages/driver/src/dom/jquery.js\">影子</a>）。</p>\n<p>有了 jQuery 的强力支持，就可以写出复杂的选择条件。比如，选取含有某一文案的 HTML 组件。</p>\n<p>在 jQuery 中，提供了 <code class=\"language-text\">:contains</code> 这个选择器（<a href=\"https://api.jquery.com/contains-selector/\">文档</a>），可以找出所有包含某一指定字符串的所有元素。</p>\n<p>于是，想要找出弹出层中的 Submit 按钮，就可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">Cypress<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'[role=dialog] button:contains(\"Submit\")'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这里，使用了 <code class=\"language-text\">[role=dialog]</code> 来找到弹出层（dialog 相关的介绍可以看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/dialog_role\">MDN</a>），然后再通过 <code class=\"language-text\">button</code> 找到按钮，最后用 <code class=\"language-text\">:contains(&quot;Submit&quot;)</code> 来找到 Submit 按钮。</p>\n<p>当然，如果一个产品本身支持 i18n，那么 <code class=\"language-text\">:contains</code> 后面的部分就不好写了。一个可行的方案，是通过当前页面的语言，从一组文案中找到合适的文案，再调用 <code class=\"language-text\">:contains</code> 选择器。比如，写一个简单的 Cypress 命令，如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">Cypress<span class=\"token punctuation\">.</span>Commands<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'getByText'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">query<span class=\"token punctuation\">,</span> texts</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  cy<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'html'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">first</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">html</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> lang <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> html<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> cy<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>query<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">:contains('</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>texts<span class=\"token punctuation\">[</span>lang<span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">')`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，通过 HTML 上的 <code class=\"language-text\">lang</code> 标记来确定当前页面所选用的语言（<code class=\"language-text\">lang</code> 的一些细节可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang\">MDN</a>），然后再根据语言，从一组文案（即 <code class=\"language-text\">texts</code> 这个对象）中选取当前需要使用的文案。</p>\n<p>命令的使用方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">cy<span class=\"token punctuation\">.</span><span class=\"token function\">getByText</span><span class=\"token punctuation\">(</span><span class=\"token string\">'[role=dialog] button'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> en<span class=\"token punctuation\">:</span> <span class=\"token string\">'Submit'</span><span class=\"token punctuation\">,</span> zh<span class=\"token punctuation\">:</span> <span class=\"token string\">'提交'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">first</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">click</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-08-27","title":"Get Element by Content","category":"Cypress"}}},{"node":{"id":"e0ffe68b-8500-57e6-b444-95d30bd9e6e8","html":"<p>在大多数时候，Mac 系统和 Linux 系统在终端的使用体验上是比较一致的，但偶尔也有一些命令，会出现两端不一样的情况。比如，当需要通过 <code class=\"language-text\">date</code> 命令获取昨天的日期。</p>\n<p>在 Mac 中，可以通过如下的命令来完成：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">date</span> -v <span class=\"token string\">'-1d'</span> <span class=\"token string\">'+%Y-%m-%d'</span></code></pre></div>\n<p>输出的结果是 <code class=\"language-text\">2019-08-25</code>。（这里，<code class=\"language-text\">&#39;+%Y-%m-%d&#39;</code> 指定 <code class=\"language-text\">date</code> 以“年-月-日”的格式输出日期；另外，如果想要得到明天的日期，可以通过 <code class=\"language-text\">+1 day</code> 或 <code class=\"language-text\">+1d</code> 来得到）</p>\n<p>然而，在 Linux 系统下，同样的命令无法使用。需要修改成：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">date</span> -d <span class=\"token string\">'-1 day'</span> <span class=\"token string\">'+%Y-%m-%d'</span></code></pre></div>\n<p>才可以得到同样的结果。这里需要注意一点，如果 Docker 是基于 Alpine 的，默认 <code class=\"language-text\">date</code> 不支持 <code class=\"language-text\">-d</code> 这个选项，需要额外安装 <code class=\"language-text\">coreutils</code> 之后，才可以使用。即，在 Dockerfile 中增加：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">RUN</span> apk add <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>update coreutils &amp;&amp; rm <span class=\"token punctuation\">-</span>rf /var/cache/apk/*</code></pre></div>\n<p>之后，上面的命令才能正确运行。</p>\n<p>如果希望一个命令可以在两个系统中运行，可以用如下的方法进行整合：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token variable\">$OSTYPE</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"darwin\"</span>* <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> \\\n  <span class=\"token function\">date</span> -v <span class=\"token string\">'-1d'</span> <span class=\"token string\">'+%Y-%m-%d'</span> <span class=\"token operator\">||</span> \\\n  <span class=\"token function\">date</span> -d <span class=\"token string\">'-1 day'</span> <span class=\"token string\">'+%Y-%m-%d'</span></code></pre></div>\n<p>注意，这里需要使用 <code class=\"language-text\">[[</code> 进行判断，<code class=\"language-text\">[</code> 的比较是无法使用 <code class=\"language-text\">*</code> 元字符匹配的。当然，这里没有考虑 Windows 的情况，毕竟 Windows 的情况太特殊了，大部分的命令都不兼容。</p>","frontmatter":{"date":"2019-08-26","title":"Get Yesterday Date in Bash","category":"Bash"}}},{"node":{"id":"7d953477-4f78-5637-be3e-1e06c851760c","html":"<p>用 Docker 管理定时任务，依然可以通过 Cron 来进行。</p>\n<section><h2>Cron 配置</h2><p>可以通过以下的方式测试 Docker 中 Cron 的执行：</p><div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker run -ti --rm alpine sh -c \\\n  <span class=\"token string\">\"echo \\\"* * * * * echo hello\\\" | crontab - &amp;&amp; crond -f -L /dev/stdout\"</span></code></pre></div><p>运用同样的原理，可以写一个简单的 Dockerfile 如下：</p><div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">RUN</span> touch /var/log/cron.log\n\n<span class=\"token keyword\">CMD</span> echo <span class=\"token string\">\"* * * * * echo 'Hello World' >> /var/log/cron.log 2>&amp;1\"</span> <span class=\"token punctuation\">|</span> \\\n  crontab <span class=\"token punctuation\">-</span> &amp;&amp; \\\n  crond <span class=\"token punctuation\">-</span>f <span class=\"token punctuation\">-</span>L /dev/stdout</code></pre></div><p>在上面的例子中，每一分钟都会输出一个 Hello World 到 <code class=\"language-text\">/var/log/cron.log</code> 文件中。Cron 的时间书写，可以在<a href=\"https://crontab.guru/\">这里</a> 进行直观的配置。</p></section>\n<section><h2>时区配置</h2><p>如果要进行更加复杂的 Cron 配置，很可能就会涉及到时间的问题。默认情况下，Docker 使用的 Linux Alpine 使用的是 UTC 时间。如果配置的 Cron 也需要用 UTC 来书写，显然不直观，也不方便。</p><p>简单的处理方法，就是在创建 Docker 的时候，对时区进行配置。比如，将时区设置成北京时间：</p><div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">ARG</span> timezone=<span class=\"token string\">\"Asia/Beijing\"</span>\n\n<span class=\"token keyword\">RUN</span> apk add tzdata &amp;&amp; \\\n  cp /usr/share/zoneinfo/$timezone /etc/localtime &amp;&amp; \\\n  echo <span class=\"token string\">\"$timezone\"</span> <span class=\"token punctuation\">></span> /etc/timezone &amp;&amp; \\\n  apk del tzdata\n\n<span class=\"token keyword\">RUN</span> touch /var/log/cron.log\n\n<span class=\"token keyword\">CMD</span> echo <span class=\"token string\">\"30 8 * * * echo 'Wake Up!' >> /var/log/cron.log 2>&amp;1\"</span> <span class=\"token punctuation\">|</span> \\\n  crontab <span class=\"token punctuation\">-</span> &amp;&amp; \\\n  crond <span class=\"token punctuation\">-</span>f <span class=\"token punctuation\">-</span>L /dev/stdout</code></pre></div><p>如上，通过 tzdata 来配置时区，将时间调整成北京时间，进而再执行每日 8:30 的 cronjob，以确保在北京时间的早晨执行某一个命令。</p></section>","frontmatter":{"date":"2019-08-25","title":"Cron in Docker","category":"Docker"}}},{"node":{"id":"b4e043f5-4e07-56f2-8b0d-986a4468b3f7","html":"<p>在 Docker 开发的过程中，可能会产生很多无用的临时 Docker Image。这些 Image 很可能没有 Tag，在 <code class=\"language-text\">docker image ls</code> 显示的时候，Tag 一列显示为 <code class=\"language-text\">&lt;none&gt;</code>。</p>\n<p>要批量清除这些 Image，可以使用如下的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker <span class=\"token function\">rm</span> <span class=\"token variable\"><span class=\"token variable\">$(</span>docker images -f <span class=\"token string\">\"dangling=true\"</span> -q --no-trunc<span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果需要强制删除，可以将 <code class=\"language-text\">rm</code> 改为 <code class=\"language-text\">rmi</code>。</p>\n<p>这里，<code class=\"language-text\">docker images -f &quot;dangling-true&quot;</code> 命令会列出所有没有 Tag 标记的 Image，加上 <code class=\"language-text\">-q</code> 标记后，将会只列出每个 Image 的 ID，<code class=\"language-text\">--no-trunc</code> 保证显示的是完整的 ID 而不仅仅只是 ID 的前几位。</p>\n<p>再配合 <code class=\"language-text\">docker rm</code> 就可以将这批 Image 全部一次性删除了。</p>","frontmatter":{"date":"2019-08-22","title":"Remove Docker Images without Tag","category":"Docker"}}},{"node":{"id":"142aa83b-239d-50b5-945f-7bff7ae9d9b3","html":"<p>在 VSCode 中，搜索的时候，默认会将选中的文字填充到搜索框中。这是一个见仁见智的功能，有时候并不非常好用。</p>\n<p>可以通过一下方式取消这一行为：</p>\n<ol>\n<li>打开 Preferences > Settings</li>\n<li>搜索 <code class=\"language-text\">Seed Search String From Selection</code></li>\n<li>取消勾选</li>\n</ol>","frontmatter":{"date":"2019-08-21","title":"Seeding Search in VSCode","category":"VSCode"}}},{"node":{"id":"5b377b6b-3612-54d4-8aa9-83e052dd29c6","html":"<p>在前端组件中，有不少组件对鼠标的响应并不是通过 CSS 的 hover 来触发的，而是通过 JavaScript 监听对应的鼠标事件，然后再进一步修改 DOM 的结构。比如，Ant Design 中的 <a href=\"https://ant.design/components/popover/\">Popover</a> 控件，在鼠标移上去后，会在 DOM 中插入一组元素，并在鼠标移开后删除。</p>\n<p>在这种情况下，一旦出现样式上的问题，就不容易在 DevTool 中对样式进行查看了。因为只要一点击右键审查元素，Popover 的内容很可能就会因为触发了鼠标事件而消失不见。</p>\n<p>对于这种情况，没法直接用 DevTool 中的 CSS 模拟来强制样式显示。如果需要通过触发事件来触发 DOM 的修改机制（不论是 <code class=\"language-text\">dispatchEvent</code> 还是在 React Extension 中触发回调），总体上是比较麻烦的。因为组件的层级结构很可能很复杂，知道应该往哪儿触发什么事件，也不是个容易的事情。</p>\n<p>既然从程序的角度触发比较复杂，不如换个思路，考虑从行为的角度来触发。比如，如果是通过鼠标悬停触发的样式修改，那么就直接通过这种行为来触发。唯一的问题是：应该如何保持这种样式，不在鼠标离开的时候被重制（否则就没法在 DevTool 里进行查看了）。</p>\n<p>这种时候，有一个简单的方法可以“暂停”浏览器。在 Console 中输入：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">debugger</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>就会在三秒后触发 <code class=\"language-text\">debugger</code>，从而暂停 JavaScript 的执行。这时候，鼠标离开的事件不会得到响应，也就可以安心在 DevTool 中对样式进行仔细的查看和调整了。</p>\n<p>当然，这里触发 <code class=\"language-text\">debugger</code> 的方式可以根据实际情况来写。只要保证在 DOM 改变后触发 <code class=\"language-text\">debugger</code> 就可以了。</p>","frontmatter":{"date":"2019-08-20","title":"Inspect Element after MouseEnter","category":"Chrome"}}},{"node":{"id":"31600c51-582c-5fcb-8841-b0cde5d94aa8","html":"<p>当 <code class=\"language-text\">display: inline-block</code> 和 <code class=\"language-text\">overflow: hidden</code> 一起使用的时候，会发现文字的显示比一般正常的情况要“高”一些。举个例子来说：</p>\n<p><span>g<span style=\"display:inline-block;overflow:hidden;color:#f54a45\">o</span>od</span></p>\n<p>上面的四个文字中，第一个 <code class=\"language-text\">o</code> 被设置为 <code class=\"language-text\">display:inline-block</code> 以及 <code class=\"language-text\">overflow:hidden</code>。最终的显示效果，第一个 <code class=\"language-text\">o</code> 的底部明显高于两边的 <code class=\"language-text\">g</code> 和 <code class=\"language-text\">o</code>。</p>\n<p>通过给第一个 <code class=\"language-text\">o</code> 和整行文字画上边框，不难发现，这个文字是整体被抬高了。</p>\n<p><span style=\"border:1px solid #007acc\">g<span style=\"display:inline-block;overflow:hidden;color:#f54a45;border:1px solid #ffe564\">o</span>od</span></p>\n<p>在上面的例子中，<code class=\"language-text\">inline-block</code> 的高度是由 <code class=\"language-text\">line-height</code> 决定的，因而看上去会比 <code class=\"language-text\">inline</code> 情况时候的要高（<code class=\"language-text\">inline</code> 情况下 border 画出来的高度是固定的，由 <code class=\"language-text\">font-family</code> 和 <code class=\"language-text\">font-size</code> 决定）；同时，<code class=\"language-text\">overflow:hidden</code> 会让内容的底部和父元素的文字基线（baseline）持平，从而会让整体的显示结果更高（这一点从上面的显示中不难发现，其中 <code class=\"language-text\">g</code> 的部分有少量是低于基线显示的，可以看到也低于第一个 <code class=\"language-text\">o</code> 的底部区域）。</p>\n<p>因此，在这种情况下，<code class=\"language-text\">line-height</code> 越大，会看到这种情况下的文字越是高，高出来的空白区域主要是 <code class=\"language-text\">line-height</code> 本身比文字大的部分，以及对齐方式不同造成的差异距离。</p>\n<p>上述这种情况，想要正确的对齐，只需要修改垂直对齐的方式就可以了。设置 <code class=\"language-text\">vertical-align:bottom</code> 后的结果：</p>\n<p><span>g<span style=\"display:inline-block;overflow:hidden;color:#f54a45;vertical-align:bottom\">o</span>od</span></p>\n<p>符合预期。</p>","frontmatter":{"date":"2019-08-19","title":"Overflow & InlineBlock","category":"CSS"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}