{"componentChunkName":"component---src-pages-til-js","path":"/til/","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"02b85200-7d40-5bec-9650-68d06623bba3","html":"<p>在 Mac 系统中，选择中文输入法，通过快捷键 <code class=\"language-text\">Option + Shift + L</code> 可以打开“查找输入码”功能（另外的打开方式可以查看<a href=\"https://support.apple.com/zh-cn/guide/chinese-input-method/cim11846/mac\">官方文档</a>）。在该功能中输入中文，就可以得到输入值的拼音（Pinyin）、五笔字型（Wubi Xing）、笔画（Stroke）以及结构性拼音（Structural）。</p>\n<p>多音字会将可能的情况都列出来。遇到生僻字可以通过这个小功能进行查找。</p>\n<p>其中，列出的结构性拼音就是拆字。在输入拼音的时候，输入包含两个或多个音节的拆字输入码，然后按下 <code class=\"language-text\">Shift + Space</code> 就可以得到相对应的汉字输入选项。比如，输入 <code class=\"language-text\">niu niu niu</code> 然后按 <code class=\"language-text\">Shift + Space</code> 就可以看到“犇”（bēn）的选项。</p>","frontmatter":{"date":"2019-12-16","title":"Find Input Code","category":"MacOS"}}},{"node":{"id":"d830ddcc-f58f-54f7-bb6b-2f994c67700c","html":"<p>React 为了消除不同浏览器上的 Event 差异，设计了一套合成事件（SyntheticEvent）。一般常用的有 <code class=\"language-text\">onClick</code>，<code class=\"language-text\">onKeyDown</code> 等等。</p>\n<p>类似于原生的浏览器事件，React 的合成事件也有捕获和冒泡两个不同的阶段。一般常用的 <code class=\"language-text\">onClick</code> 是在冒泡阶段的回调函数，对应的捕获阶段的回调函数是 <code class=\"language-text\">onClickCapture</code>。</p>\n<p>需要注意的是，React 合成事件的设计，是在顶层元素上捕获事件，然后通过 React 内部的机制生成对应的合成事件，并转发给 React 元素。其中的捕获和冒泡是由 React 自身来维护的。通过下面的例子，可以直观的看到 React 合成事件和原生浏览器的事件之间的执行顺序。</p>\n<p>假设有下面一段 HTML 代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>not-react-dom-outer<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span> <span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>not-react-dom-inner<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>app<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>以及下面这段配套的 JavaScript 代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> outer <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#not-react-dom-outer'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nouter<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'not-react-dom-outer (bubble)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nouter<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'not-react-dom-outer (capture)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">const</span> inner <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#not-react-dom-inner'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninner<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'not react div inner (bubble)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninner<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'not react div inner (capture)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Button</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>div\n    onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react div (bubble)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    onClickCapture<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react div (capture)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>button\n      onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react button (bubble)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n      onClickCapture<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react button (capture)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">></span>\n      Click Me\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>Button <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'app'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>那么，在点击了 <code class=\"language-text\">&lt;button&gt;</code> 按钮之后，控制台的输出顺序为：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">not-react-dom-outer (capture)\nnot react div inner (capture)\nnot react div inner (bubble)\nnot-react-dom-outer (bubble)\nreact div (capture)\nreact button (capture)\nreact button (bubble)\nreact div (bubble)</code></pre></div>\n<p>执行顺序上是先完成了从捕获到冒泡的所有原生事件，然后再执行从捕获到冒泡的所有 React 合成事件。</p>\n<p>关于合成事件，可以参考官方给出的<a href=\"https://reactjs.org/docs/events.html\">文档</a>。</p>","frontmatter":{"date":"2019-12-15","title":"React Capture Event","category":"React"}}},{"node":{"id":"cb888251-ad71-502a-a55d-4f215d5bba15","html":"<p>在 <code class=\"language-text\">~/.gitconfig</code> 中进行如下配置（或者使用命令：<code class=\"language-text\">git config --global diff.noprefix true</code>）：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">[diff]\n    noprefix = true</code></pre></div>\n<p>之后，Git 输出的 diff 内容，比较的文件名前将不再包含 <code class=\"language-text\">a/</code> 和 <code class=\"language-text\">b/</code> 这样的前缀。</p>\n<p>举例来说，在配置前，使用 <code class=\"language-text\">git diff</code> 命令，看到的输出可能如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">diff --git a/package.json b/package.json\nindex ac6f0b2..f937b7b 100644\n<span class=\"token coord\">--- a/package.json</span>\n<span class=\"token coord\">+++ b/package.json</span>\n<span class=\"token coord\">@@ -13,7 +13,7 @@</span>\n<span class=\"token unchanged\">   \"bugs\": {\n     \"url\": \"https://github.com/laysent/some-codemod/issues\"\n   },\n</span><span class=\"token deleted-sign deleted\">-  \"version\": \"0.1.2\",\n</span><span class=\"token inserted-sign inserted\">+  \"version\": \"0.2.0\",\n</span><span class=\"token unchanged\">   \"license\": \"MIT\",\n   \"scripts\": {\n     \"test\": \"jest\"</span></code></pre></div>\n<p>而进行了配置之后，输出如下：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\"><span class=\"gatsby-highlight-code-line\">diff --git package.json package.json</span>index ac6f0b2..f937b7b 100644\n<span class=\"token coord\">--- package.json</span>\n<span class=\"token coord\">+++ package.json</span>\n<span class=\"token coord\">@@ -13,7 +13,7 @@</span>\n<span class=\"token unchanged\">   \"bugs\": {\n     \"url\": \"https://github.com/laysent/some-codemod/issues\"\n   },\n</span><span class=\"token deleted-sign deleted\">-  \"version\": \"0.1.2\",\n</span><span class=\"token inserted-sign inserted\">+  \"version\": \"0.2.0\",\n</span><span class=\"token unchanged\">   \"license\": \"MIT\",\n   \"scripts\": {\n     \"test\": \"jest\"</span></code></pre></div>\n<p>此时，无论是直接在终端复制这个文件名，还是直接点击文件名跳转打开，都比较容易。</p>\n<p>（来源：<a href=\"https://twitter.com/brandur/status/1182066723337293828\">tweet</a> from <a href=\"https://twitter.com/brandur\">@brandur</a>）</p>\n<p>需要注意的一点是，如果配置了 <code class=\"language-text\">noprefix</code>，那么在进行 <code class=\"language-text\">git diff</code> 创建 Patch 文件并通过 <code class=\"language-text\">git apply</code> 提交修改的时候，可能会遇到 Git 的报错：</p>\n<blockquote>\n<p>error: git diff header lacks filename information when removing 1 leading pathname component (line 5)</p>\n</blockquote>\n<p>原因就是生成的 Patch 文件，目录名称没有了前缀。针对这种情况，可以改用下面的方案进行 <code class=\"language-text\">git apply</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> apply -p0 change.patch</code></pre></div>\n<p>这里，<code class=\"language-text\">-p0</code> 表示 Git 在进行补丁操作的时候，需要先删除<strong>零</strong>层前缀字符，然后再读取真实的目录地址。这里，Git 会根据 <code class=\"language-text\">/</code> 字符将目录地址拆分开来，然后删除必要的层数，将剩下的部分作为文件地址。默认值是 <code class=\"language-text\">1</code>，也就是会将 <code class=\"language-text\">a/package.json</code> 当作 <code class=\"language-text\">package.json</code> 目录进行处理。如果改成 <code class=\"language-text\">-p2</code>，那么 <code class=\"language-text\">a/dir/file</code> 会被当成 <code class=\"language-text\">file</code> 目录进行处理。</p>\n<p>相关的说明可以参考 <a href=\"https://git-scm.com/docs/git-apply#Documentation/git-apply.txt--pltngt\">Git 文档</a>。</p>","frontmatter":{"date":"2019-12-12","title":"Git Diff Filenames","category":"Git"}}},{"node":{"id":"dd6397f0-93cc-5c70-af8e-6a02ee16d25b","html":"<p>在实际开发过程中，可能会遇到这样的问题：因为重构，一些文件从 A 目录移动到了 B 目录，而后又对文件内容做了修改。这时，如果希望将其中的某些修改（比如和安全相关的布丁）应用回重构前的代码，就显得比较困难了。直接通过 Git 进行 cherry-pick 并不顺利，因为具体修改的 commit 中并不包含文件目录移动的信息。</p>\n<p>可以简单使用下面的命令来构建一个场景：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> init<span class=\"token punctuation\">;</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"console.log('hello world');\"</span> <span class=\"token operator\">></span> origin.js<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> -A<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"first commit\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">git</span> checkout -b <span class=\"token string\">\"new_branch\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">mv</span> origin.js modified.js<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> -A<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"rename commit\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"console.log('hi')\"</span> <span class=\"token operator\">>></span> origin.js<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> -A<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"modify commit\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">git</span> checkout master<span class=\"token punctuation\">;</span></code></pre></div>\n<p>这时候，希望直接将 <code class=\"language-text\">new_branch</code> 中最后一个 commit cherry-pick 到 master 是比较困难的。</p>\n<p>针对这种情况，可以考虑使用 Git Patch 功能。首先将修改的部分生成 Patch 文件，然后手动将 Patch 中的目录映射关系处理正确，最终将修改后的 Patch 应用到重构前的某个旧版本中。</p>\n<section><h2>创建 Patch</h2><p><code class=\"language-text\">git diff</code> 命令输出的结果就是一个 Patch，可以简单的将输出的内容存储到文件中，就生成了一个当前未签入内容的 Patch 文件：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">diff</span> <span class=\"token operator\">></span> change.patch</code></pre></div><p>如果希望只是将部分修改的文件生成 Patch，可以先将需要的部分放入缓冲区中（<code class=\"language-text\">git add</code>），然后通过 <code class=\"language-text\">git diff --cached</code> 命令，仅针对缓冲区中的修改生成 Patch 文件。</p><p>以上这些生成的方案，比较适合为没有写权限的 Git 仓库提交修改的场景。直接将 Patch 文件通过 email 的形式发送，就可以进行修改的讨论了。</p><p>注：如果改动包含了二进制文件的修改，可以通过增加 <code class=\"language-text\">--binary</code> 命令来获取到这部分文件的修改 Patch。</p><p>针对已经签入的提交，也可以通过 <code class=\"language-text\">git format-patch</code> 或 <code class=\"language-text\">git show</code> 命令来生成 commit 对应的 Patch 文件。</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> show commit-id <span class=\"token operator\">></span> change.patch</code></pre></div><p>可以生成单个 commit 的 Patch 文件；如果希望生成一组 commit 的 Patch，可以使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> format-patch A<span class=\"token punctuation\">..</span>B</code></pre></div><p>上面的命令会生成为从 A 到 B 之间的所有 commit 生成对应的 Patch 文件（包含 B commit，但是不包含 A commit；如果需要包含 A，可以使用 <code class=\"language-text\">A^..B</code> 命令）。或者，如果希望将所有的改动合成到一个 Patch 文件中，可以使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> format-patch A<span class=\"token punctuation\">..</span>B --stdout <span class=\"token operator\">></span> changes.patch</code></pre></div><p>上面的 A 和 B 除了可以是 commit id 之外，也可以是 Branch 或者 Tag。</p></section>\n<section><h2>应用 Patch</h2><p>将生成的 Patch 文件应用到当前的代码中，只需要使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> apply change.patch</code></pre></div><p>Git 会将 Patch 中提到的修改应用到当前的项目中，但改动不会被自动提交；如果希望直接将 Patch 以 commit 的形式进行提交，可以直接使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> am change.patch</code></pre></div></section>\n<section><h2>关于 Patch</h2><p>Git 生成的 Patch 文件，除了提交作者、commit message 这些信息外，核心的部分是通过 <code class=\"language-text\">diff</code> 命令生成的修改内容。如果只是需要修改一下文件的位置，应该可以通过观察文件直接找到。更多关于 <code class=\"language-text\">diff</code> 命令生成的补丁文件的格式，可以参考 <a href=\"https://en.wikipedia.org/wiki/Diff\">Wikipedia</a> 中的相关描述。</p></section>","frontmatter":{"date":"2019-12-11","title":"Apply Git Patch","category":"Git"}}},{"node":{"id":"93b6f6b5-db64-5bd8-827b-e4d39247908f","html":"<p>在 Git 中，可以通过 <code class=\"language-text\">cherry-pick</code> 命令将某一个 commit 选到当前的分支上。在 Git 1.7.2+ 中，可以支持将一组连续的 commit 全部都选到当前的分支上。</p>\n<p>使用的语法是：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> cherry-pick A<span class=\"token punctuation\">..</span>B</code></pre></div>\n<p>或者</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> cherry-pick A^<span class=\"token punctuation\">..</span>B</code></pre></div>\n<p>这里，<code class=\"language-text\">A..B</code> 要求 A 是在 B 的前面（更老）。在实际挑选的过程中，A 并不会被选入，实际选入的是 A 之后的下一个 commit，直到 B 为止。如果希望选择也包括 A 这个提交，可以使用 <code class=\"language-text\">A^..B</code> 的语法。</p>","frontmatter":{"date":"2019-12-10","title":"Cherry-pick Range of Git Commits","category":"Git"}}},{"node":{"id":"b35a1817-487c-5f69-97a0-2421bd23089a","html":"<p>在 Git 中，可以通过 <code class=\"language-text\">git checkout -</code> 切换会上一个分支。重复使用该命令，就会在最近的两个切换的分支上往复。</p>\n<p>需要注意的一点是，虽然 git worktree 之间是共用同一个 <code class=\"language-text\">.git</code> 数据的，但是切换的分支也是当前目录下最新使用的两个分支。其他 worktree 上的分支切换记录不会影响到当前目录的切换行为。</p>","frontmatter":{"date":"2019-12-09","title":"Checkout Previous Branch","category":"Git"}}},{"node":{"id":"202b1c1f-e486-5449-863c-b7cad49cf68a","html":"<p>在使用 TypeScript + Webpack 的项目中，可能会遇到如下类似的报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in ./src/xxx.tsx 346:0-62\n&quot;export &#39;xxx&#39; was not found in &#39;./xxxx&#39;</code></pre></div>\n<p>这类报错出现的情况是，在 <code class=\"language-text\">./scr/xxx.tsx</code> 文件中，先 <code class=\"language-text\">import</code> 了一个类型定义，然后又将这个类型定义重新 <code class=\"language-text\">export</code> 出去了。产生报错的原因在于，TypeScript 的文件需要通过 loader（无论是 babel-loader 还是 ts-loader）转化成 Webpack 可识别的 JavaScript 文件。在转化之后，TypeScript 中定义的纯类型（如 interface）都丢失了。正因为这些类型丢失了，在试图重新 <code class=\"language-text\">export</code> 的时候，Webpack 就无法找到对应的定义，只能报错（Warning）了。</p>\n<p>可以考虑通过以下的方案避免警告：</p>\n<ol>\n<li>将所有的类型定义放到单独的文件（比如 <code class=\"language-text\">types.ts</code> 中），然后通过 <code class=\"language-text\">export * from &#39;types.ts&#39;</code> 一次性将所有内容 export 出去（这样可以避免具体声明需要 export 的内容）；</li>\n<li>重新在当前文件中定义一个类型，然后将这个类型 export 出去：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Type <span class=\"token keyword\">as</span> _Type <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./type'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> Type <span class=\"token operator\">=</span> _Type<span class=\"token punctuation\">;</span></code></pre></div>\n<p>在 TypeScript 3.7 之前，上面的代码可以简写为：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Type <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./type'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> Type <span class=\"token operator\">=</span> Type<span class=\"token punctuation\">;</span></code></pre></div>\n<p>在 3.7 及之后的版本中，必须保证新定义的类型名称和原来的类型名称不同。这是因为在 TypeScript 3.7 中对类型定义做了调整，在提供更强大的递归引用类型功能的同时，不再允许定义同名的类型。相关的介绍，可以查看官方的<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#more-recursive-type-aliases\">发布文档</a>。</p>","frontmatter":{"date":"2019-12-05","title":"Export was Not Found","category":"TypeScript"}}},{"node":{"id":"6f7bce64-d072-5ef5-abd7-98cd4c6118b3","html":"<p>要知道一个网页中的文本，具体是使用什么字体渲染出来的，并不是非常简单的事情，可以有以下一些方案进行尝试。</p>\n<section><h2>getComputedStyle</h2><p>使用 <code class=\"language-text\">window.getComputedStyle</code> 属性获取对应元素的 <code class=\"language-text\">font-family</code> 字段。因为字体的设置一般是通过顶层配置，子元素继承的方式完成的，因此在大多数的元素上，并没有 <code class=\"language-text\">font-family</code> 设置。即使有，大概率也是通过 CSS 完成的，因此从 <code class=\"language-text\">.style</code> 或者 <code class=\"language-text\">.attributeStyleMap</code> 无法拿到需要的数据。<code class=\"language-text\">getComputedStyle</code> 可以获取当前元素上样式的最终计算值，因此即使字体实际来自于继承或者系统默认字体，都可以通过该 API 获取到。比如，在一个没有 CSS 设置的页面上，可以通过下面的代码知道具体使用的系统默认字体是什么：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">window<span class=\"token punctuation\">.</span><span class=\"token function\">getComputedStyle</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>fontFamily<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// MacOS (Chrome): Times</span>\n<span class=\"token comment\">// Windows (Chrome): Microsoft YaHei</span></code></pre></div><p>非编程的方案，可以在 Chrome DevTools 中直接找到 Elements 下的 Computed 部分，查看实际使用的 CSS 属性值。注：如果 <code class=\"language-text\">font-family</code> 并没有被定义过，可以勾选 All 来查看系统默认的属性值。</p><p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2f6b9b41cfadb16613696e96a940262e/cb0d3/2019-12-04-computed-style.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 130.95975232198143%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAABYlAAAWJQFJUiTwAAAD40lEQVRIx5WVi2/aVhjF+Uv336ybFjKSNMnWbR1dq6pb1ocqVVMndWuabqFZIh62IZSHedoY24BtwOAXZ9+9EAYk1VpLB/va3OPfvd/1uTHXddFut1EsFlEqlTAYDKB1VOQlAYW8CLlawXg0Qr3egCSJME0ThmHw84juO47Dxfr1ej3EuIGmodPpoKt1oOs6qi0TUrmNS7mDgtyF0u1B73b5i9lz1rHf73MT27ZhWRZvM8UajQYymQw3VDUDFxkRZ2kJqQsBTdVEvalAlPKQ5Srevy8in5egKHNjBjIcDrnplWKe52E6nXIZtgfN8qDbPp199IYBgsCH7/vwvIX8FVHfTcVw0xF59BMAMx9R4GEW+iRvTez+TUdsNpthKboRei5aJ0mkn+9C/uM79M9+gn6ahJFKwkzdo/M99E7vwkw/5f9f609aErIGh/MnUI73UX71JaTfvoB5tgcnvY/B+W3YF/v82kxtQ0vdX/a76ssJNw1DbwLt7SE0cR9/v72FdOoWikIc8mWC9DUqhV30hD0yfPDxhuqbA7TEBB78voOthwfYe3yA5Mvvcfflj3iR2oOajn+aoXJMhsI2Hh0nkXj2DIknjxA/eoivjh7j+V930ElvoXP6CYbaySEU6TZSmS2c57bwTy6Oc4GJXW+jm91F991HGrKitGnIjkTKf0vnb2CJh1w2XQ8LdzDI7KLzoSGvlnxOOIZGVe4eJ6C/2eHSXieovbNoE92fcRjv7vNlg81ls/mGKAzg6jI8s/afDGrr1YUqXK5Rx2xldNfWYRRFcy3MZ/+jqz7XvhSWGCalx9KQFBIlF33HIZsGpYrw9RHCFz8g/HUX0eefIfplGz49sxZptUwbhxKiT9kW0MceBswoXBd7wdRFaCgI60WEpTSCVz/Dz57AJ1SWlSwfWaTxtDFbLYwokgYUYXa5jAklhjuZzEXhyzWZwvVpbsMILBKafQdCpU5G5iKJVtKmryoY5/MYCgJ8wmeUAZkt6VZpA5ZAEQ9bQZCIyOGFCFZGFtObDViZNCwhB7t4yc+WKGA86GNCGTkhwgm9YLIgZkTliox6o8mJ3JXnTLGBqmIsinzYbqOOMe0rXr/Hq705n0EY8krKtL+0FXW+bjf+E9Mbc8JBLgunViNCAQ7FPadbefMVISteqVzlhIz2ZkJJwpCG6ZIhI+TV3pw/RsjmkA5m1mi2rq8IRmjQTuaQoV0uwcpmiE5em7dNQjZvakdDJieiVKEvx5tuENJuxwgZ3Yh2NZeK9CFCJvbtdnUDWapyrd7kVV4jNInQpqI4NXk5H8v1d4PY7qjTQs4XiqjKNd5eff4vE5Ka/A6hyHoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Screenshot of Chrome DevTools > Elements > Computed\"\n        title=\"\"\n        src=\"/static/2f6b9b41cfadb16613696e96a940262e/b9e4f/2019-12-04-computed-style.png\"\n        srcset=\"/static/2f6b9b41cfadb16613696e96a940262e/cf440/2019-12-04-computed-style.png 148w,\n/static/2f6b9b41cfadb16613696e96a940262e/d2d38/2019-12-04-computed-style.png 295w,\n/static/2f6b9b41cfadb16613696e96a940262e/b9e4f/2019-12-04-computed-style.png 590w,\n/static/2f6b9b41cfadb16613696e96a940262e/cb0d3/2019-12-04-computed-style.png 646w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p></section>\n<section><h2>Rendered Fonts</h2><p>使用 <code class=\"language-text\">getComputedStyle</code> 只能得到实际使用的 CSS 属性值，有时候并不能准确表达实际真实使用的具体字体类型。</p><p>举例来说，一个 <code class=\"language-text\">font-family</code> 定义可能是：</p><div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">body</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span>\n    <span class=\"token string\">'Rubik'</span><span class=\"token punctuation\">,</span>\n    -apple-system<span class=\"token punctuation\">,</span> <span class=\"token string\">'system-ui'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'BlinkMacSystemFont'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'PingFang SC'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Segoe UI'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Roboto'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Oxygen'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Ubuntu'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Cantarell'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Fira Sans'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Droid Sans'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Helvetica Neue'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Helvetica'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Arial'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Hiragino Sans GB'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Microsoft Yahei'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'WenQuanYi Micro Hei'</span><span class=\"token punctuation\">,</span> sans-serif；\n<span class=\"token punctuation\">}</span></code></pre></div><p>在如此众多的定义中，具体浏览器使用了哪一款字体，并不容易知道。这其中涉及到了大量的变量。用户使用的系统环境、字体下载情况、正在阅读的文字是中文还是英文等，这些都有可能影响到最终浏览器所选用的字体。甚至在不复杂的 <code class=\"language-text\">font-family</code> 设置下，最终的选用字体依然可能并不直观。举例来说，如果设置 CSS 为：<code class=\"language-text\">font-family: system-ui</code>，具体使用的字体并没有从设置的字段中直观的反馈出来。</p><p>Chrome DevTools 提供了一个 Rendered Fonts 功能，可以帮助开发者了解当前真实使用的字体。示意图如下：</p><p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dc6b98d142218bfc4e588ffbe34ab2d0/26dcc/2019-12-04-rendered-fonts.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 538px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 187.36059479553904%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAlCAYAAABCr8kFAAAACXBIWXMAABYlAAAWJQFJUiTwAAAFB0lEQVRIx51WyW4bRxCdjw5yygfkB5KD7zkFCAIYQbwFgeEttixS3HeJ5HAdchbOvvLlVZMjUbJkC27goXt6ZqpreVXVWhAE2Gw26PV6GI1GGA6H0HUdnh9gZjj4XO/hvN5HpdHHYLyC4/pYr1YIwxDyr+d52O12sCxLydGWyyUGgwEmk4l6sd0YuLocot/voUohnaGO+cZFpTnEh/M2qvUWut0uqtUqarUarq6ulKDFYqGEa9vtVmk36PdhmhauZgZqrQEq9S7RRrM7xMa00e92UK9dUFgHrVZLCRSMx2Ol3Ypa+74PLc9zlCPNcpgB4EQH7GLAljks8NAoigJZll3Pmmzu93tCrbAvMs65Whd5gjyLOadI0+QWkkSQqn9Ph3YQdtiUE1zXw2K1wehqBj/kT+keYZwjIuK0QJwckGYFgxJSeIobpfY3GsoQ813XRaf+Bp/fP8V08B/MRQ3bWRXm/AIW1/JsLWswZnX4DEKaZTiVcUug+MG2LTjT59Dbf6BX+R3R6iUK818k65dIN6+QGv8g5+zpTxlEg0oUDwvMRaBlwtFfIfaXGF1ekgFdzGa68qP4MxP/RQ682QtY5gbZ1wQWxZ4UOAiMfAMrw8RkqqM/GMFxdjBJDz+IKNA7CvyGhiJwu93AHL9A6K4YkAxbc0vyjrE2eMB6Ta4FCDybbnnGJFg9wmT60J6+Qp44KsLCzYwRTdJyZoSTEO7s5eNNdvVn2NtvkFsfUNgfkJrvkJnvkXOtYL1FMP/r2yYfaLODMT2DM38He0ZwtvS3CuqZkHfG5D1z36HW+W2Bd4kdhpEyL4i4FsQZCZ4iIGQdHvfjhGSPoq8TW+YojhETScI5KdfJzd7JHFKgcPcLDcsNeVme9BjcNzQpkpZpImLBFB+K2QK1Vs/59b7MYqJAtJYia9ukkOOolBVoATcnrNA+1T+q+mCpuquVPM/nM2bSTNVDg1zVRGrIhT+dIuBJEUuSaCsOP4VYIi5pt9t4/fo1ib7BJQlv2w7Jb1LgmpSzoRlkv91swm2werD6xqy6ydGkU0gQZEi1/vvZc3S6fZWWko4GW4BkkgjXXPYRj/0jYAvwW01E1DSnQIFoJH4rISa6no/Fco2pPlN7KsongdWkg1ntFmz2ix2ri/nxI6xKBTtqGx5NLRHHkTKt0WxTwx5anS4Lx1AV5fIbRZuc2ZFRdcGpw++jSRwnLBKG4ut932oBfebQ0Q59s2P3c6Wdsk0GrMaioVCj7MHiS302R6PVVi2z3C+/EWgZfeV3OtidfYLXaChfevUaYgYr54klL7NjqZ/Pl8rkIs9v8baEllB1f0Q/NBvwhwNWkTmCxRwhfZsKkZPkmsgSgDUPavaGvFn41yQ/hSacC8ijgA0/pBkxT4n4QuGEj2J+HAbYRTHmrRqW0wn34i/4eqg2pXPvOPh2Rz9eCFYT4O2fN1l1ty/jUeP4U+gBv/0MRMGDX2oWk1vYLrMwXa2ZQnJxKqMoDT0MfGS//ICw9g4iLjhG+S60erOFT2fn+Fyp4rxygWa7g8pFDbV6U1Vvhwfs2EeSX39E/OQn2BTmsHE5PFCqjKUUuIEmoV6S/XNexwTS2URbOU0iqa541NhsVeCy38heeSf074m0un1VLuoqjc7Oq7igZv3hSHFMTB9djjEYXmKoL7DZmtiwCMxJLYFJdnzhw/1X6t+jwnUnPbXvLf8PtQHte4Q8BFHqf1USFQCODxGiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Screenshot of Chrome DevTools > Elements > Computed > Rendered Fonts\"\n        title=\"\"\n        src=\"/static/dc6b98d142218bfc4e588ffbe34ab2d0/26dcc/2019-12-04-rendered-fonts.png\"\n        srcset=\"/static/dc6b98d142218bfc4e588ffbe34ab2d0/cf440/2019-12-04-rendered-fonts.png 148w,\n/static/dc6b98d142218bfc4e588ffbe34ab2d0/d2d38/2019-12-04-rendered-fonts.png 295w,\n/static/dc6b98d142218bfc4e588ffbe34ab2d0/26dcc/2019-12-04-rendered-fonts.png 538w\"\n        sizes=\"(max-width: 538px) 100vw, 538px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p><p>Chrome 会将当前选中元素真实使用的所有字体都列出来。需要注意两点：</p><ol>\n<li>需要选中一个有文字内容的元素，不然这里并不会显示；</li>\n<li>\n<p>选中的文字内容可能需要多种字体类型共同配合渲染，Chrome 会讲所有用到的元素都列举出来。</p>\n<p>比如，<code class=\"language-text\">笑，😊，smile</code> 这样一段文字，在 MacOS Chrome 下，默认就需要以下三种字体来进行渲染：</p>\n<ul>\n<li>Times（渲染英文）</li>\n<li>Songti SC（渲染中文）</li>\n<li>Apple Color Emoji（渲染 emoji）</li>\n</ul>\n<p>以上三种字体在 Rendered Fonts 中都会被列举出来。</p>\n</li>\n</ol><p>Chrome 的 Blog 介绍可以查看<a href=\"https://developers.google.com/web/updates/2013/09/DevTools-answers-What-font-is-that\">这里</a>。</p><p>这一方案暂时没有 JavaScript API 可以直接调用，无法在程序运行时进行自动的判断。</p></section>","frontmatter":{"date":"2019-12-04","title":"Rendered Fonts","category":"Chrome"}}},{"node":{"id":"ddf203aa-1bf8-5e71-9ad4-a9dbe9bd9530","html":"<p>在 JavaScript 中，直接定义一个对象（Object），性能上远不如定义一个 <code class=\"language-text\">JSON.parse()</code> 的表达式。具体来说，下面的两行，<code class=\"language-text\">JSON.parse</code> 的表达式会有更好的性能表现：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> slow <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> foo<span class=\"token punctuation\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> bar<span class=\"token punctuation\">:</span> <span class=\"token number\">1337</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fast <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token string\">'{\"foo\":42,\"bar\":1337}'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>同样的效果，但是在 JavaScript 引擎中的表现却差别很大。根据<a href=\"https://github.com/GoogleChromeLabs/json-parse-benchmark\">这里</a>给出的测试数据，<code class=\"language-text\">JSON.parse</code> 的速度是直接写对象速度的 1.7 倍。而且这不仅仅只是 V8 表现上的不同，在各类 JavaScript 引擎上都有类似的表现，性能差异均非常明显（<a href=\"https://developer.apple.com/documentation/javascriptcore\">JavaScriptCore</a> 的性能差异可以到两倍）。</p>\n<p>这里差异的主要原因在于，引擎在解析时候算法复杂度有着巨大的差异。简单来说，JSON 的数据结构是非常简单且固定的，因而在解析的时候可以有更好的表现。这种简单体现在以下几个方面：</p>\n<ol>\n<li>JSON 的数据支持类型不多，只有字符串，数组，数字，NULL，对象这几种；相比之下，JavaScript 中一个对象的支持类型非常的复杂，情况更多；</li>\n<li>从抽象语法树（AST）的角度看，<code class=\"language-text\">JSON.parse</code> 的情况比单纯写一个 JavaScript 对象要简单的多。对于前者来说，就是一个 CallExpression 和一个 StringLiteral；而对于一个 JavaScript 对象来说，涉及到大量的 ObjectExpression，当中可能还包含 StringLiteral，NumericLiteral，Identifier 等等；</li>\n<li>JSON 的解析是上下文无关的；而 JavaScript 对象的解析却需要结合当前的上下文（context）来确定；</li>\n</ol>\n<p>举一个例子来说明：假设有这样一个 JavaScript 代码片段：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> y <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> x <span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里的 <code class=\"language-text\">x</code> 代表什么含义，其实有非常多的可能性，比如：</p>\n<ul>\n<li><code class=\"language-text\">const y = ({ x })</code>，此时 <code class=\"language-text\">x</code> 的值和上下文中的 <code class=\"language-text\">x</code> 变量是相关的，定义是一个 JavaScript 对象；</li>\n<li><code class=\"language-text\">const y = ({ x } = { x: 2 })</code>，此时 <code class=\"language-text\">x</code> 和上下文是相关的，但定义的是一个赋值语句，而不是对象（根据语法，对 <code class=\"language-text\">const</code> 二次赋值导致语法错误）；</li>\n<li><code class=\"language-text\">const y = ({ x }) =&gt; x;</code>，此时 <code class=\"language-text\">x</code> 的值和上面的 <code class=\"language-text\">x</code> 无关，是一个函数的参数；</li>\n</ul>\n<p>换句话说，当 JavaScript 引擎在解析一个 JavaScript 对象的时候，需要考虑很多的可能性，在解析的过程中很可能无法确定当前的类型，甚至连语法是否正确也不能确定。但反观 JSON，定义就简单的多，在解析的当下，引擎就可以很清楚的知道当前的内容是一个数组，还是一个对象，亦或是有语法错误。</p>\n<p>除了上述提到的性能比较数据之外，<a href=\"https://joreteg.com/blog/improving-redux-state-transfer-performance\">这里</a>还有一份针对 Redux 应用的优化分析。数据显示，使用 <code class=\"language-text\">JSON.parse</code> 调用之后 TTI (Time To Interactive) 时间缩短了 0.74s (18%)。考虑到整个改动是非常“简单”的，这一性能提升显得非常客观。</p>\n<p>这里之所以说改动是非常“简单”的，是因为整个优化思路非常的明确，完全可以通过对应的工具在编译时完成。目前开源社区已经提供了各类相关的工具，可以直接使用，列举一些如下：</p>\n<ul>\n<li>Webpack（<a href=\"https://github.com/webpack/webpack/releases/tag/v4.35.3\">v4.35.3</a> 或以上）默认会将 JSON 打包成 <code class=\"language-text\">JSON.parse()</code>；使用 <code class=\"language-text\">json-loader</code> 可以去掉这一优化（具体见这个 <a href=\"https://github.com/webpack/webpack/pull/9349\">Pull Request</a>）；</li>\n<li>一些 Babel Plugin 支持将满足要求的 JavaScript 对象转化成 <code class=\"language-text\">JSON.parse</code> 语法，比如 <a href=\"https://github.com/nd-02110114/babel-plugin-object-to-json-parse\">babel-plugin-object-to-json-parse</a> 或 <a href=\"https://github.com/keyz/babel-plugin-transform-optimize-object-literal\">babel-plugin-transform-optimize-object-literal</a>。</li>\n</ul>","frontmatter":{"date":"2019-12-03","title":"Cost of parsing JSON","category":"JavaScript"}}},{"node":{"id":"1f47e54e-3226-5831-b830-c394c36ddda6","html":"<p>Node.js 的 Docker 有基于 Alpine 的版本。在这个 Docker 中使用 <a href=\"https://github.com/develar/7zip-bin\">7zip-bin</a> 库的时候遇到了错误，无法正常启动。</p>\n<p>一个简单的重现 <code class=\"language-text\">Dockerfile</code> 可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>10<span class=\"token punctuation\">-</span>alpine\n\n<span class=\"token keyword\">RUN</span> mkdir <span class=\"token punctuation\">-</span>p example &amp;&amp; \\\n  cd example &amp;&amp; \\\n  yarn init <span class=\"token punctuation\">-</span>y &amp;&amp; \\\n  yarn add 7zip<span class=\"token punctuation\">-</span>bin &amp;&amp; \\\n  mkdir /lib64 &amp;&amp; \\\n  ln <span class=\"token punctuation\">-</span>s /lib/libc.musl<span class=\"token punctuation\">-</span>x86_64.so.1 /lib64/ld<span class=\"token punctuation\">-</span>linux<span class=\"token punctuation\">-</span>x86<span class=\"token punctuation\">-</span>64.so.2\n\n<span class=\"token keyword\">ADD</span> run.sh /run.sh\n\n<span class=\"token keyword\">RUN</span> chmod +x /run.sh\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"/run.sh\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>其中，<code class=\"language-text\">run.sh</code> 可以写：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> example\n<span class=\"token variable\"><span class=\"token variable\">$(</span>node -e \"console.log<span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">(</span><span class=\"token string\">'7zip-bin'</span><span class=\"token punctuation\">)</span>.path7za<span class=\"token variable\">)</span></span>\"<span class=\"token punctuation\">)</span></code></pre></div>\n<p>报错的内容是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/run.sh: line 2: /example/node_modules/7zip-bin/linux/x64/7za: not found</code></pre></div>\n<p>通过进入 Docker 内部观察不难发现，<code class=\"language-text\">/example/node_modules/7zip-bin/linux/x64/7za</code> 这个文件实际是真实存在的，但是在使用的时候系统却报错 <code class=\"language-text\">not found</code>。造成这一问题的原因，可能是动态库缺失。</p>\n<p>通过 <code class=\"language-text\">ldd</code> 命令可以列出动态库依赖关系（<a href=\"https://linux.die.net/man/1/ldd\">文档</a>）：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">ldd /example/node_modules/7zip-bin/linux/x64/7za</code></pre></div>\n<p>输出结果是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibpthread.so.0 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibstdc++.so.6 =&gt; /usr/lib/libstdc++.so.6 (0x7febe52b9000)\nlibm.so.6 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibgcc_s.so.1 =&gt; /usr/lib/libgcc_s.so.1 (0x7febe52a5000)\nlibc.so.6 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)</code></pre></div>\n<p>注意到缺少了 <code class=\"language-text\">/lib64/ld-linux-x86-64.so.2</code> 这个动态库，因此导致了 <code class=\"language-text\">7zip-bin</code> 这个库无法正常使用。造成这个的原因是，Alpine 使用的是 <a href=\"https://www.musl-libc.org/\">musl</a>，而 <code class=\"language-text\">7zip-bin</code> 使用的二进制文件是基于 glibc 编译出来的。要解决这个问题，有两种思路：</p>\n<ol>\n<li>在 Alpine 中安装 libc 的兼容库：<code class=\"language-text\">RUN apk add --no-cache libc6-compat</code>；</li>\n<li>或者，<code class=\"language-text\">ln -s /lib/libc.musl-x86_64.so.1 /lib/ld-linux-x86-64.so.2</code> 将 musl 的版本软连过去，直接让 <code class=\"language-text\">7zip-bin</code> 的二进制使用</li>\n</ol>\n<p>当然，最佳的方案是不使用 <code class=\"language-text\">7zip-bin</code> 中的 pre-build 版本，而改用 Alpine 的 <a href=\"https://pkgs.alpinelinux.org/package/edge/main/x86/p7zip\">p7zip</a> 版本。用 Alpine 的包管理器安装好 <code class=\"language-text\">pz7ip</code> 之后（<code class=\"language-text\">apk add p7zip</code>），使用类似下面的代码直接替换脚本就好了：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cp</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">type</span> -p 7za<span class=\"token variable\">)</span></span> <span class=\"token variable\"><span class=\"token variable\">$(</span>node -p <span class=\"token string\">\"require('7zip-bin').path7za\"</span><span class=\"token variable\">)</span></span></code></pre></div>\n<section><h2>参考链接</h2><ul>\n<li>在 7zip-bin issue 中的<a href=\"https://github.com/develar/7zip-bin/issues/8\">相关讨论</a></li>\n<li>重现的配置代码 <a href=\"https://gist.github.com/laysent/b12faceac4bcf10bee04aabfa505c244\">gist</a></li>\n<li>node-gyp 在 Alpine 中也可能会遇到类似的问题，在<a href=\"https://medium.com/devgorilla/node-gyp-support-in-alpine-linux-9374c6191140\">这里</a>可以找到相关的讨论</li>\n</ul></section>","frontmatter":{"date":"2019-12-02","title":"7zip-bin in Alpine Docker","category":"Docker"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}