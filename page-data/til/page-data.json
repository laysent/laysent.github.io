{"componentChunkName":"component---src-pages-til-js","path":"/til/","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"d4f2cc35-174d-5e24-86fa-274d23e4c9a1","html":"<p>在 TypeScript 编译过程中，可能会遇到如下的报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">Exported variable &lt;variable name&gt; has or is using private name &lt;private name&gt;</code></pre></div>\n<p>这一报错只会出现在开启了 declaration 输出之后。开启的方式是编译时增加 <code class=\"language-text\">--declaration</code>，或者在 tsconfig.json 中加入：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"declaration\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>出现这一报错的原因是，最终被使用的某一个类型，引用到了某一个没有被公开（export）的类型。简单的例子如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">B</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">type</span> Props <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">|</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，之所以会出现问题，理由很简单：TypeScript 试图输出一个定义类型的文件，其中就包括了 <code class=\"language-text\">Props</code> 的定义。然而，如果要明确定义 <code class=\"language-text\">Props</code>，就需要用到两个类型 <code class=\"language-text\">A</code> 和 <code class=\"language-text\">B</code>。在这里，<code class=\"language-text\">A</code> 和 <code class=\"language-text\">B</code> 这两个类型因为没有被公开（export），因而是私有（private）的。故，理论上来说，TypeScript 的导出定义文件中不应该包含这两个类型。而没有这两个类型的话，TypeScript 就没有办法定义 <code class=\"language-text\">Props</code> 了。最终，TypeScript 只能报错。</p>\n<p>官方给出的解释可以参考<a href=\"https://github.com/ant-design/ant-design/pull/19846#event-2817984936\">这里</a>。</p>\n<p>要解决这个问题，方法也很简单：所有使用到的类型，全部都公开（export）就好了。</p>","frontmatter":{"date":"2019-11-21","title":"Export Variable using Private Name","category":"TypeScript"}}},{"node":{"id":"80ff40b4-417e-59fe-8b49-49f477af38e5","html":"<p><code class=\"language-text\">dd</code> 是一个 Bash 命令，可以用于文件/硬盘的整体拷贝。比如，希望将 Raspberry Pi 的 SD 卡复制一份，就可以使用 <code class=\"language-text\">dd</code> 这个命令来进行。</p>\n<p>但是默认的 <code class=\"language-text\">dd</code> 命令并没有进度提示，在完整执行完之前，默认在 stdout 中不会看到任何输出。</p>\n<p>如果想要获得当前 <code class=\"language-text\">dd</code> 的执行进度，可以尝试如下的一些方法：</p>\n<ol>\n<li>通过 <code class=\"language-text\">Control + T</code> 将 <code class=\"language-text\">SIGINFO</code> 发送给 <code class=\"language-text\">dd</code> 命令，<code class=\"language-text\">dd</code> 收到后会输出当前的进度信息；</li>\n<li>类似的，也可以通过 <code class=\"language-text\">pkill</code> 命令将 <code class=\"language-text\">SIGINFO</code> 发送给 <code class=\"language-text\">dd</code>：<code class=\"language-text\">pkill -INFO -x dd</code>。</li>\n</ol>\n<p>其中，针对第二点的命令，可以写一个简单的脚本来定时输出当前的进度：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> pgrep ^dd<span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span> <span class=\"token function\">pkill</span> -INFO <span class=\"token function\">dd</span><span class=\"token punctuation\">;</span> <span class=\"token function\">sleep</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">done</span></code></pre></div>\n<p><code class=\"language-text\">dd</code> 的输出结果示例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">1000+0 records in\n1000+0 records out\n67108864000 bytes transferred in 3.720346 secs (18038339571 bytes/sec)</code></pre></div>\n<p>更多方法（原理都是发送 <code class=\"language-text\">SIGINFO</code> 给 <code class=\"language-text\">dd</code>），可以参考<a href=\"https://www.commandlinefu.com/commands/view/11666/check-the-status-of-dd-in-progress-os-x\">这里</a>。</p>","frontmatter":{"date":"2019-11-20","title":"Progress of dd","category":"Bash"}}},{"node":{"id":"0442beaa-4143-5c44-ad49-5d031a3c488b","html":"<p>Raspberry Pi 的操作系统写在 SD Card 中。如果想将这个当前的系统做克隆（用于备份或存储迁移），可以通过 <code class=\"language-text\">dd</code> 命令来进行。</p>\n<ol>\n<li>将原始的 SD Card 以及新的 SD Card 插入电脑；</li>\n<li>通过 <code class=\"language-text\">diskutil</code> 命令来查看当前两张 SD Card 在 <code class=\"language-text\">dev</code> 中分别的命名是怎样的：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">diskutil list</code></pre></div>\n<p>运行后的结果大致如：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/dev/disk2\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n  ...\n\n/dev/disk3\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   ...</code></pre></div>\n<p>其中 <code class=\"language-text\">/dev/disk2</code> 和 <code class=\"language-text\">/dev/disk3</code> 就分别是插入的两个 SD Card（具体在不同的机器上可能有所不同，需要根据 <code class=\"language-text\">diskutil</code> 列出的数据进行区分）。</p>\n<p>接下来，需要将 <code class=\"language-text\">/dev/disk3</code>（也就是新的 SD Card）进行 unmount 操作，因为 SD Card 最终要写成的格式并不是 MacOS “理解”的格式（这里只是进行了 unmount，文件系统已经不可访问了，但是物理的 SD Card 依然是系统可以访问的，因而可以被写成任意的格式）：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">diskutil unmountDisk /dev/disk2</code></pre></div>\n<p>最后，使用 <code class=\"language-text\">dd</code> 命令进行数据的克隆就可以了：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/dev/disk2 <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>/dev/disk3</code></pre></div>\n<p>当然，如果不需要克隆到新的 SD Card，只是做一个简单的备份，也可以将内容保存到本地的文件中：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/dev/disk2 <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>/path/to/file.dmg</code></pre></div>\n<p>还原备份只需要：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/path/to/file.dmg <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>/dev/disk3</code></pre></div>","frontmatter":{"date":"2019-11-19","title":"Clone SD Card","category":"Bash"}}},{"node":{"id":"96f3c780-0e41-571e-abef-50a625e53a84","html":"<section><h2>现状</h2><p>当前的 Ant Design，常见的样式覆盖方案，大体上有两种：</p><ol>\n<li>使用 Ant Design 提供的 LESS 变量来覆盖原有的样式（详情可以参考官方的<a href=\"https://ant.design/docs/react/customize-theme-cn\">文档</a>）；</li>\n<li>先一次性载入完整的 Ant Design CSS/LESS 文件，然后再载入新的覆盖样式（一些文章提到了这样的处理方法，比如<a href=\"https://www.jianshu.com/p/a2e7728d8717\">这里</a>）。</li>\n</ol><p>第一种方案的主要缺点是写法不太直观，优点是替换非常彻底，而且是官方推荐的方案；第二种方案，优点是覆盖的写法非常的直观，直接写 CSS/LESS 覆盖原有样式就可以了，但是缺点是需要一次性加载所有的样式，再覆盖。</p></section>\n<section><h2>按需加载的困难点</h2><p>如果使用了 <code class=\"language-text\">babel-plugin-import</code> 对样式进行按需加载，再想要进行样式的覆盖，就很容易出现问题。</p><p>在了解具体可能存在的问题前，先来看一下 <code class=\"language-text\">babel-plugin-import</code> 的按需加载是如何运作的：在 JavaScript / TypeScript 文件遇到任何 Ant Design 组件的引用，就会同时将该组件的样式也插入到引用的位置。也就是说，如果有下面的 JavaScript 代码：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Select <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'antd'</span><span class=\"token punctuation\">;</span></code></pre></div><p>那么，编译转化后的代码大体如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token string\">'antd/lib/select/style'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> Select <span class=\"token keyword\">from</span> <span class=\"token string\">'antd/lib/select'</span><span class=\"token punctuation\">;</span></code></pre></div><p>这里实际载入的样式文件来自 <code class=\"language-text\">antd/lib/select/style</code> 目录下的 <code class=\"language-text\">index.js</code> 文件。在这个文件中，具体引用了需要用到的各个 LESS 文件。对 Select 来说，这个样式引用的代码是：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../../style/index.less\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./index.less\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../../empty/style\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>可以看到，除了 Select 自身的 <code class=\"language-text\">index.less</code> 文件外，先后还引用了 <code class=\"language-text\">../../style/index.less</code> 文件和 <code class=\"language-text\">../../empty/style</code> 文件。换句话说，<code class=\"language-text\">babel-plugin-import</code> 在处理按需加载的时候，并不是仅加载了当前使用组件的样式，还包含了一些组件需要的隐含依赖样式。这一点，在 AutoComplete 这样的复杂组件中更为明显。在使用 AutoComplete 的时候，其 <code class=\"language-text\">style/index.js</code> 内容如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../../style/index.less\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./index.less\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../../select/style\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../../input/style\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>可以看到，除了自身的样式之外，Select 和 Input 的样式代码也被加载了一遍。换句话说，如果希望做按需加载的样式覆盖，在加载 AutoComplete 组件的时候，除了需要加载样式覆盖 AutoComplete 的部分，还需要额外加载样式将 Select 和 Input 的样式也覆盖一遍。而这些隐含的样式依赖，在代码上是不容易被察觉的。一旦漏了 Select 和 Input 的样式覆盖，就容易出现问题：明明 Select 的样式在加载的时候已经覆盖过了，但是在加载了 AutoComplete 组件之后，原先已经被覆盖的样式，又被新载入的 Select 原始样式给覆盖回去了。</p><p>因为 Ant Design 的样式没有采用 CSS Module，因此 CSS/LESS 的样式覆盖就强依赖于正确的加载顺序。覆盖的样式必须在原始样式的后面加载，否则结果就会出现错乱。</p></section>\n<section><h2>解决方案</h2><p>为了确保按需加载的情况下，样式的覆盖顺序也是正确的，一个可行的思路是使用 Webpack 中的 loader 功能。根据 Webpack 打包的原理，任何的非 JavaScript 代码，都需要通过合适的 loader 转化成 JavaScript 文件，最终被打包到 bundle 中。而不管 <code class=\"language-text\">babel-plugin-import</code> 插件如何处理 Ant Design 的样式加载，这些最终被引用的 LESS 文件，都需要经过一些 loader 最终处理成可执行的文件（一般需要用到的 loader 包括 <code class=\"language-text\">less-loader</code>，<code class=\"language-text\">css-loader</code> 和 <code class=\"language-text\">style-loader</code>）。</p><p>既然 Webpack 的打包已经保证了统一的处理入口，那么就可以考虑在 loader 这一层，将样式的覆盖处理掉。</p><p>示例代码如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> pattern <span class=\"token operator\">=</span> <span class=\"token regex\">/antd\\/lib\\/([^\\/]+)\\/style\\/index.less/</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">exports</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>content<span class=\"token comment\">/*, map, meta */</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/**\n   * 这里的 resourcePath 就是具体被使用的 LESS 文件的目录，详情可以参考 Webpack 文档：\n   * https://webpack.js.org/api/loaders/#thisresourcepath\n   */</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> resourcePath <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> match <span class=\"token operator\">=</span> pattern<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>resourcePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">/**\n   * 1. 如果不是 Antd 相关的 LESS 文件，直接忽略不处理\n   */</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>match<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> content<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> component <span class=\"token operator\">=</span> match<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">/**\n   * 2. 根据使用的 Component 组件，找到对应的覆盖样式文件，赋值给 customizedLessPath\n   */</span>\n  <span class=\"token keyword\">const</span> customizedLessPath <span class=\"token operator\">=</span> <span class=\"token function\">getCustomizedLessFile</span><span class=\"token punctuation\">(</span>component<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>customizedLessPath<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> content<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">/**\n   * 3. 如果找到了覆盖文件，就将覆盖文件插入到 LESS 的最后面，保证调用顺序\n   */</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>\n    content<span class=\"token punctuation\">,</span>\n    <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">@import \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>customizedLessPath<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\";</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>接下来，在 Webpack 中配置对应的 LESS 文件处理 loader，确保这个自定义的 loader 在 less-loader 的前面：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  test<span class=\"token punctuation\">:</span> <span class=\"token regex\">/\\.less$/</span><span class=\"token punctuation\">,</span>\n  use<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'postcss-loader'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      loader<span class=\"token punctuation\">:</span> <span class=\"token string\">'less-loader'</span><span class=\"token punctuation\">,</span>\n      options<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      loader<span class=\"token punctuation\">:</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path-to-custom-loader'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div><p>这样，假设 <code class=\"language-text\">babel-plugin-import</code> 插件插入了一段 Select 的 LESS 文件：</p><div class=\"gatsby-highlight\" data-language=\"less\"><pre class=\"language-less\"><code class=\"language-less\"><span class=\"token atrule\">@select-prefix-cls<span class=\"token punctuation\">:</span> ~'@</span><span class=\"token punctuation\">{</span>ant<span class=\"token operator\">-</span>prefix<span class=\"token punctuation\">}</span><span class=\"token operator\">-</span>select'<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span></code></pre></div><p>经过上面的自定义 loader 处理之后，就会变成：</p><div class=\"gatsby-highlight\" data-language=\"less\"><pre class=\"language-less\"><code class=\"language-less\"><span class=\"token atrule\">@select-prefix-cls<span class=\"token punctuation\">:</span> ~'@</span><span class=\"token punctuation\">{</span>ant<span class=\"token operator\">-</span>prefix<span class=\"token punctuation\">}</span><span class=\"token operator\">-</span>select'<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span>\n<span class=\"token variable\">@import</span> <span class=\"token string\">\"customized-less-path\"</span><span class=\"token punctuation\">;</span></code></pre></div><p>可以看到，自定义的 LESS 文件一定会在原始 LESS 文件的后面，从顺序上可以保证样式一定可以正确的被覆盖。剩下的事情，就交给 less-loader 及后续 loader 去处理就可以了。</p></section>\n<section><h2>延伸阅读</h2><p>关于 Webpack loader 的写法，可以参考 Webpack 官方的<a href=\"https://webpack.js.org/contribute/writing-a-loader/\">教学文档</a>。</p></section>","frontmatter":{"date":"2019-11-18","title":"Ant Design Style Overwrite","category":"JavaScript"}}},{"node":{"id":"265be941-4b2a-5bcb-b8e5-b5bb85a52bb5","html":"<p>在 JavaScript 的 DOM 事件中，可以通过 <code class=\"language-text\">.stopPropagation</code> 来阻止事件冒泡。比如，如果有如下的一个 DOM 结构：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>parent</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>child</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>同时有如下的 JavaScript 代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> parent <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'parent'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'child'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nparent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (child): capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (child): bubble'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nparent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): bubble'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>那么，点击 child 元素，console 中的输出的结果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">click(parent): capture\nclick(child): capture\nclick(child): bubble\nclick(parent): bubble</code></pre></div>\n<p>这里，代码有意保持输出顺序和回调函数注册顺序的一致性。如果在上面四个回调函数中依次加上 <code class=\"language-text\">event.stopPropagation()</code>，那么之后所有的内容将不会在继续输出。</p>\n<p>以上是关于 DOM 中冒泡和捕获事件处理的一般流程。这里，如果在一个 DOM 节点上注册了不止一个的事件回调函数，那么浏览器将按照事件注册的先后顺序，依次执行对应的回调函数。需要注意的一点是，<code class=\"language-text\">event.stopPropagation()</code> 是无法阻止同级回调函数被执行的。简单将上面的代码进行修改，可以得到如下的测试代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">parent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">stopPropagation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): first capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nparent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): second capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (child): capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>那么，在点击 child 元素的时候，可以得到如下的输出结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">click (parent): first capture\nclick (parent): second capture</code></pre></div>\n<p>parent 上的 click 回调函数都依次执行完毕了，而 child 上的部分则因为 <code class=\"language-text\">event.stopPropagation()</code> 没有被执行到。这里，如果希望连同层的其他回调函数也不要继续执行，可以改用 <code class=\"language-text\">event.stopImmediatePropagation()</code>，代码修改如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">parent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">stopImmediatePropagation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): first capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nparent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): second capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (child): capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>修改后的代码，执行效果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">click (parent): first capture</code></pre></div>\n<p>几点说明：</p>\n<ol>\n<li>React 的合成事件只有 <code class=\"language-text\">stopPropagation</code> 没有 <code class=\"language-text\">stopImmediatePropagation</code>，如果需要使用的话，可以用如下的方法调用真正的 DOM API：<code class=\"language-text\">.nativeEvent.stopImmediatePropagation</code>。这里 React 不需要 <code class=\"language-text\">stopImmediatePropagation</code> 的理由非常简单，因为在 JSX 中，每个事件在 Component 上只能绑定一个回调函数，因此 <code class=\"language-text\">stopImmediatePropagation</code> 是多余的；</li>\n<li>由于浏览器天然维护了一个 EventListener 的队列用于按顺序执行回调函数，<code class=\"language-text\">stopImmediatePropagation</code> 配合上回调函数的注销（<code class=\"language-text\">removeEventListener</code>），可以用于小成本实现一个 FIFO 的队列。示例代码如下：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">dom</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>key <span class=\"token operator\">!==</span> <span class=\"token string\">'Escape'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    event<span class=\"token punctuation\">.</span><span class=\"token function\">stopImmediatePropagation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">removeEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'keydown'</span><span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    dom<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'display'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'none'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  dom<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'display'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'block'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'keydown'</span><span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nArray<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelectorAll</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ul li'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>register<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>以上代码执行后，按下 ESC 键，将会依次将 <code class=\"language-text\">ul</code> 下的 <code class=\"language-text\">li</code> 元素一个一个的隐藏。</p>\n<ol start=\"3\">\n<li><code class=\"language-text\">stopImmediatePropagation</code> API 的浏览器支持比较好，在 IE 9 及以上的浏览器中都可以使用，参考 <a href=\"https://caniuse.com/#search=stopimmediatepropagation\">Can I Use</a>；</li>\n<li>更多关于这个 API 的介绍，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event/stopImmediatePropagation\">MDN</a>。</li>\n</ol>","frontmatter":{"date":"2019-11-17","title":"stopImmediatePropagation","category":"JavaScript"}}},{"node":{"id":"e3c0f3bd-e7cf-579e-8fb1-d24187f5acdb","html":"<p>Google Chrome 的 DevTools 本质上也是一个由 Web 技术编写的应用，在必要的时候，可以通过以下的方式打开 DevTools 的 DevTools：</p>\n<ol>\n<li>首先打开 DevTools；</li>\n<li>选择将 DevTools 在独立窗口中打开，然后按下 Cmd + Opt + I（Mac）或 Ctrl + Shift + I（Windows）</li>\n</ol>\n<p>这样，就可以打开 DevTools 的 DevTools 了。</p>\n<p>注：这里一定要选择将最开始的 DevTools 在独立窗口打开，然后再按 Cmd + Opt + I；否则对于嵌入在页面中的 DevTools 来说，按下上面这个组合键，会将 DevTools 收回，而不是打开 DevTools 的 DevTools。</p>\n<p>另一个稍微麻烦一些的方法是：</p>\n<ol>\n<li>打开一个 DevTools；</li>\n<li>在 Chrome 中打开：<a href=\"chrome://inspect\">chrome://inspect</a>；</li>\n<li>选择 Other，就可以找到刚才打开的 DevTools 了，点击 <code class=\"language-text\">inspect</code> 链接，就可以打开这个指定 DevTools 的 DevTools 了。</li>\n</ol>\n<p>一个可以在 DevTools 的 DevTools 中进行的操作，是查看和修改 DevTools 中记录的 snippets。对应的 API 分别是：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">InspectorFrontendHost<span class=\"token punctuation\">.</span><span class=\"token function\">getPreferences</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">_</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">.</span>scriptSnippets<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nInspectorFrontendHost<span class=\"token punctuation\">.</span><span class=\"token function\">setPreference</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'scriptSnippets'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>yourSnippets<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>关于通过代码来管理 Chrome DevTools 中的 snippets，可以参考 GitHub 上的这个<a href=\"https://github.com/bahmutov/code-snippets/issues/23\">讨论</a>。</p>\n<p>同时，Chrome DevTools 本身也是开源的，代码可以在 <a href=\"https://github.com/ChromeDevTools/devtools-frontend\">GitHub</a> 上找到。</p>","frontmatter":{"date":"2019-11-15","title":"DevTools of DevTools","category":"Chrome"}}},{"node":{"id":"17386daf-da8d-53b5-8e80-73d9d610875a","html":"<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">\b<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'incorrect statement'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'correct statement'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的这段代码，看上去两个 <code class=\"language-text\">if</code> 语句并无差别。但是在实际执行的过程中，却会发现，第一个 <code class=\"language-text\">if</code> 语句有语法报错，而第二个 <code class=\"language-text\">if</code> 语句却没有。TypeScript 给出的报错信息是：<code class=\"language-text\">Invalid character.(1127)</code>。</p>\n<p>“看上去”一样的代码，在解释器看来却非常不同。究其原因，是因为第一个 <code class=\"language-text\">if</code> 语句中，有一个“看不见”的字符：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\bif (true) {</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">charCodeAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>执行上面的这段代码，会看到在 console 中输出 8。这里，8 是 Backspace 的 ASCII 码编号。在很多的文本编辑器中，这类特殊字符并不会显示出来，但对于解释器来说，这个字符确实真是存在的。（当然，并不是所有的文本编辑器都不会显示，比如把上面的代码复制到 Chrome DevTools 中，就会看到一个 <code class=\"language-text\">🔴</code> 符号，用于表示这个看不见的 Backspace）</p>\n<p>这一类的特殊字符除了 Backspace 还有很多，比如 Unicode 中的零宽空格（U+200b）、左至右符号（U+200e）、右至左符号（U+200f）等。</p>","frontmatter":{"date":"2019-11-13","title":"Invisible Characters","category":"JavaScript"}}},{"node":{"id":"65cd384a-ec80-5942-bc9e-9ab8ad9814f5","html":"<p>Node.js 中的 <code class=\"language-text\">require</code> API 在加载 commonjs 模块的时候，会做两个事情：</p>\n<ol>\n<li>根据 Node.js 的算法，查找到对应的模块文件；</li>\n<li>加载查找到的模块文件并运行。</li>\n</ol>\n<p>这里，如果只是想执行第一步，但并不真的运行这个被找到的模块，可以使用 Node.js 提供的 <code class=\"language-text\">require.resolve</code> API。具体的调用示例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> modulePath <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>modulePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上面代码中，<code class=\"language-text\">modulePath</code> 是一个完整的文件路径，指向的位置就是 <code class=\"language-text\">some-package</code> 这个模块的 entry 文件（定义在 package.json 的 <code class=\"language-text\">main</code> 中）。默认情况下，这个 <code class=\"language-text\">require.resolve</code> 的查找路径是和 <code class=\"language-text\">require</code> API 一致的：在查找的时候，会从当前文件的目录开始，逐级往上查找 <code class=\"language-text\">node_modules</code> 目录下是否有需要的库。</p>\n<p>举例来说，假设有下面这样一个目录结构：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">A.js\nnode_modules\n|- some-package\n   |- index.js\n|- other-package\n   |- index.js\nutils\n|- B.js\n   node_modules\n   |- some-package\n      |- index.js</code></pre></div>\n<p>且，假设 A.js 的代码为：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./utils/B'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'A: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'A: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'other-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>B.js 的代码为：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'B: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'B: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'other-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>那么，输出的结果为：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">B: utils/node_modules/some-package/index.js\nB: node_modules/other-package/index.js\nA: node_modules/some-package/index.js\nA: node_modules/other-package/index.js</code></pre></div>\n<p>但有的时候，只是希望可以使用 Node.js 的查找算法，但是查找的目录位置，并不一定是从当前文件所在的目录开始的。这种时候，就需要用到 <code class=\"language-text\">require.resolve</code> 的第二个参数了：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  paths<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'where-to-start-searching'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'other-possible-search-location'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，<code class=\"language-text\">paths</code> 是一个数组，表示所有的搜索起始位置。Node.js 会依次以这些路径为起始点，查找各个层级往上的 node_modules 目录。一旦找到需要的库，就停止查找，否则就会一直往上直到根目录。到达根目录后，当前的查找就以失败告终。如果还有其他的查找路径，就会继续上面的操作，否则程序会抛出异常。</p>\n<p>第二个参数的一个实际应用场景如下：假设有一个 CLI 可以用于代理执行 Webpack 命令，这时候就需要首先通过 <code class=\"language-text\">require.resolve</code> 命令找出当前执行 CLI 命令的目录内，Webpack 库在什么位置。然后才可以用 <code class=\"language-text\">require</code> 命令去加载真正在项目中使用到的 Webpack 版本，而不是 CLI 内部可能依赖的一个 Webpack 版本。</p>\n<p>更多关于 <code class=\"language-text\">require.resolve</code> 命令的说明，可以参考官方的<a href=\"https://nodejs.org/api/modules.html#modules_require_resolve_request_options\">文档</a>。</p>","frontmatter":{"date":"2019-11-12","title":"Require Resolve","category":"Node.js"}}},{"node":{"id":"bdf22101-4989-5baa-9054-a528719b9619","html":"<p><a href=\"https://github.com/tc39/proposal-nullish-coalescing\">Nullish Coalescing</a> 当前在 TC39 Stage 3 的阶段，TypeScript 在 <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing\">3.7</a> 中也将这一功能引入了进来。（<a href=\"http://dict.cn/Coalesce\">Coalesce</a> 是“合并；联合；接合”的意思）</p>\n<p>Nullish Coalescing 的简单用法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>当 <code class=\"language-text\">foo</code> 的值是 <code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code> 的时候，<code class=\"language-text\">x</code> 的值由后面的 <code class=\"language-text\">bar()</code> 决定，否则 <code class=\"language-text\">x</code> 的值就是 <code class=\"language-text\">foo</code> 本身。这一行为，一般会被用于给变量赋初始值。在之前的 JavaScript / TypeScript 中，一般会这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num <span class=\"token operator\">||</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>但是，这样写有一个问题，就是当 <code class=\"language-text\">num</code> 的值是 <code class=\"language-text\">0</code> 的时候，最终的值依然是 <code class=\"language-text\">5</code> 而不是 <code class=\"language-text\">0</code>。这一行为很可能并不是开发者希望的。</p>\n<p>和 Optional Chaining 一样，Nullish Coalescing 只有在原值是 <code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code> 的时候，才进行操作；其他的 falsy 值，都会保持原样，并不会做特殊的处理（根据 <a href=\"https://github.com/tc39/proposal-nullish-coalescing/blob/master/README.md#overview-and-motivation\">Proposal</a> 中的说明，这两个规范将会在“何时处理”上保持一致）。这很大程度上减少了 JavaScript 在类型上导致隐藏问题的可能性。</p>\n<p>需要注意的一点是，这一行为和 JavaScript 中的默认参数是有一点不一样的。上面的代码如果改写成默认参数的形式：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那么，将会在 <code class=\"language-text\">getNumber(null)</code> 的时候产生行为上的分歧。使用 Nullish Coalescing 将会返回 <code class=\"language-text\">5</code>，也就是进行了默认值赋值；而默认参数的方案将会返回 <code class=\"language-text\">null</code>，因为默认参数只有在 <code class=\"language-text\">undefined</code> 的情况下才会进行默认值赋值操作。</p>\n<p>Optional Chaining 和 Nullish Coalescing 可以放在一起操作，确保值不存在的时候，有一个兜底的默认值可以给程序使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>bar<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token string\">'default'</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-11-11","title":"Nullish Coalescing","category":"TypeScript"}}},{"node":{"id":"d7ace064-8159-5fe0-ba4d-0b04683a001d","html":"<p>在 JavaScript 中，新的<a href=\"https://github.com/tc39/proposal-object-rest-spread\">规范</a>定义了 object rest spread 运算符，可以用于对象的解构。</p>\n<p>简单的用法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>除了这种解构同时赋值给新变量的情况，也可以通过解构运算，赋值给一个已有的变量：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">'old'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token string\">'value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里需要注意的一点是，解构加赋值的运算，必须要加上括号。下面的写法会报语法错误：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">'old'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token string\">'value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>会报错的原因是，前面的 <code class=\"language-text\">{ value } =</code>，如果不加上括号，会被当成一般的代码块（Block），而不是一个解构的对象（Object），因此解析语法树的时候，在 <code class=\"language-text\">=</code> 这里就报错了（<code class=\"language-text\">Uncaught SyntaxError: Unexpected token &#39;=&#39;</code>）。注：如果不加最后的 <code class=\"language-text\">;</code>，语法也是正确的。</p>\n<p>更多相关的相关介绍，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring\">MDN</a>。</p>","frontmatter":{"date":"2019-11-07","title":"Object Deconstructing without Declaration","category":"JavaScript"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}