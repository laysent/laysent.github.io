{"componentChunkName":"component---src-pages-til-js","path":"/til/","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"bdf22101-4989-5baa-9054-a528719b9619","html":"<p><a href=\"https://github.com/tc39/proposal-nullish-coalescing\">Nullish Coalescing</a> 当前在 TC39 Stage 3 的阶段，TypeScript 在 <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing\">3.7</a> 中也将这一功能引入了进来。（<a href=\"http://dict.cn/Coalesce\">Coalesce</a> 是“合并；联合；接合”的意思）</p>\n<p>Nullish Coalescing 的简单用法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>当 <code class=\"language-text\">foo</code> 的值是 <code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code> 的时候，<code class=\"language-text\">x</code> 的值由后面的 <code class=\"language-text\">bar()</code> 决定，否则 <code class=\"language-text\">x</code> 的值就是 <code class=\"language-text\">foo</code> 本身。这一行为，一般会被用于给变量赋初始值。在之前的 JavaScript / TypeScript 中，一般会这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num <span class=\"token operator\">||</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>但是，这样写有一个问题，就是当 <code class=\"language-text\">num</code> 的值是 <code class=\"language-text\">0</code> 的时候，最终的值依然是 <code class=\"language-text\">5</code> 而不是 <code class=\"language-text\">0</code>。这一行为很可能并不是开发者希望的。</p>\n<p>和 Optional Chaining 一样，Nullish Coalescing 只有在原值是 <code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code> 的时候，才进行操作；其他的 falsy 值，都会保持原样，并不会做特殊的处理（根据 <a href=\"https://github.com/tc39/proposal-nullish-coalescing/blob/master/README.md#overview-and-motivation\">Proposal</a> 中的说明，这两个规范将会在“何时处理”上保持一致）。这很大程度上减少了 JavaScript 在类型上导致隐藏问题的可能性。</p>\n<p>需要注意的一点是，这一行为和 JavaScript 中的默认参数是有一点不一样的。上面的代码如果改写成默认参数的形式：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那么，将会在 <code class=\"language-text\">getNumber(null)</code> 的时候产生行为上的分歧。使用 Nullish Coalescing 将会返回 <code class=\"language-text\">5</code>，也就是进行了默认值赋值；而默认参数的方案将会返回 <code class=\"language-text\">null</code>，因为默认参数只有在 <code class=\"language-text\">undefined</code> 的情况下才会进行默认值赋值操作。</p>\n<p>Optional Chaining 和 Nullish Coalescing 可以放在一起操作，确保值不存在的时候，有一个兜底的默认值可以给程序使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>bar<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token string\">'default'</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-11-11","title":"Nullish Coalescing","category":"TypeScript"}}},{"node":{"id":"d7ace064-8159-5fe0-ba4d-0b04683a001d","html":"<p>在 JavaScript 中，新的<a href=\"https://github.com/tc39/proposal-object-rest-spread\">规范</a>定义了 object rest spread 运算符，可以用于对象的解构。</p>\n<p>简单的用法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>除了这种解构同时赋值给新变量的情况，也可以通过解构运算，赋值给一个已有的变量：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">'old'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token string\">'value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里需要注意的一点是，解构加赋值的运算，必须要加上括号。下面的写法会报语法错误：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">'old'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token string\">'value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>会报错的原因是，前面的 <code class=\"language-text\">{ value } =</code>，如果不加上括号，会被当成一般的代码块（Block），而不是一个解构的对象（Object），因此解析语法树的时候，在 <code class=\"language-text\">=</code> 这里就报错了（<code class=\"language-text\">Uncaught SyntaxError: Unexpected token &#39;=&#39;</code>）。注：如果不加最后的 <code class=\"language-text\">;</code>，语法也是正确的。</p>\n<p>更多相关的相关介绍，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring\">MDN</a>。</p>","frontmatter":{"date":"2019-11-07","title":"Object Deconstructing without Declaration","category":"JavaScript"}}},{"node":{"id":"04dc3c68-fa9d-535f-94d9-f7a404f1d2dc","html":"<p>在 TC39 将 <a href=\"https://github.com/tc39/proposal-optional-chaining/\">Optional Chaining</a> 转移到 Stage 3 之后，TypeScript 在 3.7 版本中也带来了对应的 Optional Chaining 功能。总体上，TypeScript 的 Optional Chaining 功能和 JavaScript 的提案是保持一致的。总结来说，就是：</p>\n<blockquote>\n<p>如果属性值是 <code class=\"language-text\">undefined</code> 或者 <code class=\"language-text\">null</code>，就会直接返回 <code class=\"language-text\">undefined</code>，否则会进一步获取真实的属性值。</p>\n</blockquote>\n<p>在 <a href=\"https://www.typescriptlang.org/play/index.html\">TypeScript Playground</a> 中可以尝试一下这个新的功能。以下面这段 TypeScript 为例：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>bar<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>最终会被转译成下面的这段 JavaScript：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> _a<span class=\"token punctuation\">,</span> _b<span class=\"token punctuation\">,</span> _c<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_a <span class=\"token operator\">=</span> foo<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _a <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span>\n  <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">(</span>_b <span class=\"token operator\">=</span> _a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _c <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span>\n    <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span>\n    <span class=\"token function\">_c</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>_b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>几点简单的说明：</p>\n<ol>\n<li>即使值是 <code class=\"language-text\">null</code>，最终返回的结果也会是 <code class=\"language-text\">undefined</code>（上面代码中是 <code class=\"language-text\">void 0</code>，是等价的）；</li>\n<li>只有 <code class=\"language-text\">null</code> 和 <code class=\"language-text\">undefined</code> 的情况会被直接返回。这一点，和之前 <code class=\"language-text\">foo &amp;&amp; foo.bar</code> 这样的写法是有区别的。主要是 JavaScript 对哪些值是 falsy 的判断，范围会比 <code class=\"language-text\">null</code> &#x26; <code class=\"language-text\">undefined</code> 更广，还包括了 <code class=\"language-text\">NaN</code>，<code class=\"language-text\">0</code>，<code class=\"language-text\">false</code> 等；</li>\n<li>Optional Chaining 在函数调用中也是可以用的，写法是 <code class=\"language-text\">xx?.()</code>，如果不存在，函数不会调用，而是直接返回 <code class=\"language-text\">undefined</code>；</li>\n<li>Optional Chaining 也可以使用如下的写法：<code class=\"language-text\">foo?.[0]</code>， <code class=\"language-text\">foo?.[&#39;var-name&#39;]</code> 或 <code class=\"language-text\">foo?.[variableName]</code></li>\n</ol>\n<p>官方的发布介绍文档见<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#optional-chaining\">这里</a>。</p>","frontmatter":{"date":"2019-11-06","title":"Optional Chaining in TypeScript","category":"TypeScript"}}},{"node":{"id":"4c12371e-1261-52ed-8522-aacc2f3a7626","html":"<p><code class=\"language-text\">console.assert</code> API 可以用于判断某个条件是否满足，并在不满足的时候，在 Console 里打印出相关的数据。整体 API 和 <code class=\"language-text\">console.error</code> 比较类似，但是第一个参数是一个判断条件。整个调用，只会在第一个参数是 falsy 值的时候，才会将后面的数据打印出来。打印的方式和 <code class=\"language-text\">console.error</code> 类似，输出的是 error 信息。需要注意的一点是，根据 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Console/assert\">MDN</a> 的描述，在 Node.js 10 版本前，除了输出之外，还会抛出一个 <code class=\"language-text\">AssertionError</code>。这个行为是错误的，console API 不应该影响主流程的代码，Node.js 在 10 修复了问题。</p>\n<p>下面是一段示例代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'before'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'incorrect with error message'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'after'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出的结果是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">before\nincorrect with error message\nafter</code></pre></div>\n<p>其中，<code class=\"language-text\">incorrect with error message</code> 这一条，还会额外输出调用的堆栈信息，方便调试。</p>\n<p>总结来说，在代码中实现类似 Chrome 中 conditional breakpoint，使用 <code class=\"language-text\">console.assert</code> 是一个不错的选择：只在出现问题的时候打印必要的信息，可以尽可能的减少对 Console 输出的污染。</p>","frontmatter":{"date":"2019-11-05","title":"console.assert","category":"JavaScript"}}},{"node":{"id":"df525546-37d6-5170-90fd-2fe8e78bc734","html":"<p><code class=\"language-text\">console.trace</code> API 支持可选参数，输出的效果和 <code class=\"language-text\">console.log</code> / <code class=\"language-text\">console.info</code> 类似。但是除了输出参数指定的内容之外，还会连带将当前的调用堆栈一起输出。可以看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Console/trace\">MDN</a> 中给出的一个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">trace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出的结果类似：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">bar\nfoo\n&lt;anonymous&gt;</code></pre></div>\n<p>其中，<code class=\"language-text\">&lt;anonymous&gt;</code> 是因为 <code class=\"language-text\">foo</code> 函数是在 console 中直接运行的。当然，这个只能在调试阶段进行代码的检查。如果需要在线上环境，对可能出问题的地方收集调用堆栈信息，直接使用 <code class=\"language-text\">console.trace</code> 就不满足需求了。可以转而使用 Error 中的 stack 字段：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> error <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出结果类似：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">Error\n    at bar (&lt;anonymous&gt;:3:19)\n    at foo (&lt;anonymous&gt;:6:3)\n    at &lt;anonymous&gt;:9:1</code></pre></div>","frontmatter":{"date":"2019-11-04","title":"console.trace","category":"JavaScript"}}},{"node":{"id":"0e49e733-98a8-5e79-bcb5-c4ef0b27aaf8","html":"<p>在 Node.js 中，可以通过使用 Performance API 来对 <code class=\"language-text\">require</code> 模块的性能进行检测。这里的 Performance 模块，是 Node.js 根据 <a href=\"https://w3c.github.io/performance-timeline/\">W3C Performance Timeline 规范</a>，实现的一套和 Web 相同的 API 接口集合。一般的时间测量，可以通过 <code class=\"language-text\">Performance.mark</code> 和 <code class=\"language-text\">Performance.measure</code> 的组合来进行，使用的方法大体上和 Web 中一致（但是需要使用 <code class=\"language-text\">PerformanceObserver</code> 来获取测量的结果，这一点和 Web 不太相同，具体可以参考官方的<a href=\"https://nodejs.org/api/perf_hooks.html\">文档</a>）。</p>\n<p>和 Web 不同的是，在 Node.js 的 Performance 模块中，还提供了一个 <a href=\"https://nodejs.org/api/perf_hooks.html#perf_hooks_performance_timerify_fn\">timerify</a> 的接口，可以简便的对一个函数进行封装，从而测量出这个函数的实际调用时间。</p>\n<p>有了这个接口，就可以很容易的测量 Node.js 中加载模块的耗时了。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">,</span>\n  PerformanceObserver\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'perf_hooks'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> mod <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'module'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmod<span class=\"token punctuation\">.</span><span class=\"token class-name\">Module</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>require <span class=\"token operator\">=</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">timerify</span><span class=\"token punctuation\">(</span>mod<span class=\"token punctuation\">.</span><span class=\"token class-name\">Module</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>require<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> obs <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PerformanceObserver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">list</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> entries <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">getEntries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  fs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./profile.json'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>entries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  obs<span class=\"token punctuation\">.</span><span class=\"token function\">disconnect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobs<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  entryTypes<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'function'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Module.require'</span><span class=\"token punctuation\">,</span>\n  buffered<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里有几点可以说明一下：</p>\n<ol>\n<li><code class=\"language-text\">mod.Module.prototype.require</code> 被 <code class=\"language-text\">timerify</code> 之后，所有模块在 <code class=\"language-text\">require</code> 的时候，都会使用被 <code class=\"language-text\">timerify</code> 过的版本；</li>\n<li>PerformanceObserver 的作用是获取 entries 的结果；</li>\n<li><code class=\"language-text\">obs.disconnect</code> 用于解除连接，不再进行后续的接听；</li>\n<li><code class=\"language-text\">obs.observer</code> 设置 <code class=\"language-text\">entryTypes: [&#39;function&#39;]</code>，确保这里 <code class=\"language-text\">timerify</code> 的结果都可以被获取到；</li>\n<li><code class=\"language-text\">obs.observer</code> 中设置 <code class=\"language-text\">buffered: true</code>，确保 observer 的回调函数不会被立刻执行，而是用 <code class=\"language-text\">setImmediate</code> 延迟调用。这样的好处是，一次 <code class=\"language-text\">require</code> 后，该模块的调用时间和该模块内部调用子模块的耗时都会一次性通过回调函数返回。（注：默认这里的值是 <code class=\"language-text\">false</code>，见<a href=\"https://nodejs.org/docs/latest-v10.x/api/perf_hooks.html#perf_hooks_performanceobserver_observe_options\">文档</a>）;</li>\n<li>官方给出的示例，还 <code class=\"language-text\">timerify</code> 了 <code class=\"language-text\">require</code> 函数（见<a href=\"https://nodejs.org/api/perf_hooks.html#perf_hooks_measuring_how_long_it_takes_to_load_dependencies\">这里</a>），这样做会导致当前模块中 <code class=\"language-text\">require</code> 的调用，生成两份 Performance 数据（一份来自 <code class=\"language-text\">require</code>，一份来自 <code class=\"language-text\">Module.require</code>）。出于精简的考虑，上面的示例代码中去掉了对 <code class=\"language-text\">require</code> 函数的 <code class=\"language-text\">timerify</code>。</li>\n</ol>\n<p>在上面的示例代码中，最终得到的结果，存放在了一个 JSON 文件内，大体的格式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"0\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"required-module-name\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Module.require\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"entryType\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"startTime\"</span><span class=\"token operator\">:</span> <span class=\"token number\">7397.399892</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"duration\"</span><span class=\"token operator\">:</span> <span class=\"token number\">112.681678</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>这里，<code class=\"language-text\">0</code> 表示第一个参数的值，对于 <code class=\"language-text\">require</code> 来说就是具体引用的模块的名称/地址；<code class=\"language-text\">name</code> 表示是哪个函数的调用，在示例中就是被 <code class=\"language-text\">timerify</code> 过的 <code class=\"language-text\">Module.require</code> 函数；<code class=\"language-text\">entryType</code> 是固定的 <code class=\"language-text\">function</code>，因为这个值是通过 <code class=\"language-text\">timerify</code> 拿到的；<code class=\"language-text\">startTime</code> 和 <code class=\"language-text\">duration</code> 分别表示调用开始的时间以及实际调用的耗时。</p>","frontmatter":{"date":"2019-11-03","title":"Require Performance in Node.js","category":"Node.js"}}},{"node":{"id":"8851beea-d663-5eca-a70d-daacfb58475f","html":"<p>在 Houdini 实现的过程中（<a href=\"https://developers.google.com/web/updates/2016/05/houdini\">什么是 Houdini？</a>），Chrome 已经在 66 中已经实现了一部分 CSS 样式的 Typed Object Modal 支持（支持的列表可以参考<a href=\"https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/core/css/cssom/README.md\">这里</a>）。</p>\n<p>实现之后，在 JavaScript 中就可以通过 <code class=\"language-text\">window.CSS</code> 对象上的各类属性 API，生成指定类型的 CSS 属性值。看一个简单的例子：</p>\n<p>在以前的实现中，往往需要这么写代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> fontSize <span class=\"token operator\">=</span> <span class=\"token operator\">+</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>fontSize<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'px'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nelement<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>fontSize <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>fontSize <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">px</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\nelement<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>opacity <span class=\"token operator\">=</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这样写，会存在几个问题：</p>\n<ol>\n<li>读取和设置带单位数值的时候，需要在字符串和数字之间进行转化；</li>\n<li>CSS 的属性名称是用 <code class=\"language-text\">-</code> 连接的，但是在 <code class=\"language-text\">CSSStyleDeclaration</code> 中却需要写成小驼峰的形式（<code class=\"language-text\">font-size</code> 变成 <code class=\"language-text\">fontSize</code>）；</li>\n<li>如果设置违法的值，代码会默默失败，没有任何错误提示；</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">element<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>opacity <span class=\"token operator\">=</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// no error! not success!</span>\nelement<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>opacity <span class=\"token operator\">=</span> <span class=\"token string\">'?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// output: 0.1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>opacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol start=\"4\">\n<li>即使设置的属性值是数字，但是实际拿到的时候，值又变成了字符串</li>\n</ol>\n<p>如，上例中的 <code class=\"language-text\">element.style.opacity</code>，虽然设置的值是 <code class=\"language-text\">1</code>，但如果运行 <code class=\"language-text\">typeof element.style.opacity</code> 结果却是 <code class=\"language-text\">string</code></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">element<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>opacity <span class=\"token operator\">=</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// output: string</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> element<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>opacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果试图直接进行运算，则可能得不到预料中的结果。比如，下面的输出依然是 <code class=\"language-text\">0.1</code> 而不是 <code class=\"language-text\">0.6</code>，因为 <code class=\"language-text\">element.style.opacity += 0.5</code> 的结果是 <code class=\"language-text\">0.10.5</code>（字符串拼接），作为一个非法值，直接被浏览器抛弃了（见第三点）</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">element<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>opacity <span class=\"token operator\">=</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span>\nelement<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>opacity <span class=\"token operator\">+=</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// output: 0.1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>opacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>有了 CSS Typed Object Model 之后，代码可以改写成这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> fontSize <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'font-size'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\nelement<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'font-size'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">CSS</span><span class=\"token punctuation\">.</span><span class=\"token function\">px</span><span class=\"token punctuation\">(</span>fontSize <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nelement<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'opacity'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>不难看出，这样的写法，基本解决了上面提到的几个问题：</p>\n<ol>\n<li>读取和设置带单位数值的时候，不再需要手动进行字符串和数值的转化。<code class=\"language-text\">CSS.px</code> 这个函数可以将数值转化成一个带单位的对象，用于给 <code class=\"language-text\">attributeStyleMap</code> 赋值。另外，由于这个值 <code class=\"language-text\">toString</code> 之后就是类似 <code class=\"language-text\">16px</code> 的字符串，因此也可以直接给 <code class=\"language-text\">element.style.fontSize</code> 进行赋值。同时，从 <code class=\"language-text\">attributeStyleMap</code> 中拿到的数据，也是带单位的对象，对象中的 <code class=\"language-text\">value</code> 就是数值，<code class=\"language-text\">unit</code> 是字符串，表示单位，不再需要手动解析；</li>\n<li><code class=\"language-text\">attributeStyleMap</code> 的属性名称和 CSS 的属性名称是一致的，不需要像以前一样在 JavaScript 中手动改成小驼峰的写法；</li>\n<li>如果设置了违法的值，代码会报错：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  element<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'opacity'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>以上代码会输出报错：<code class=\"language-text\">TypeError: Failed to execute &#39;set&#39; on &#39;StylePropertyMap&#39;: Invalid type for property</code>。</p>\n<ol start=\"4\">\n<li>应该是数值的结果，拿到的时候也是数值，而不是字符串（因此数值计算也不会出错）：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">element<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'opacity'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// output: number</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> element<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'opacity'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>当然，这里如果这么些，结果依然是数字：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">element<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'opacity'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// output: number!</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> element<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'opacity'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>另外，使用 CSS Typed OM 还有一些其他额外的好处，比如，浏览器不需要序列化和反序列化结果，因此性能更好（一个简单的性能检测可以查看<a href=\"https://github.com/w3c/css-houdini-drafts/issues/634#issuecomment-366358609\">这里</a>，大概有 30% 左右的提升）。</p>\n<p>更多更详细关于 CSS Typed OM 的介绍，可以参考 Google 的这篇 <a href=\"https://developers.google.com/web/updates/2018/03/cssom\">Blog</a>。</p>\n<p>P.S. 目前，其他的浏览器支持情况依然不理想，可以参考 <a href=\"https://ishoudinireadyyet.com/\">Is Houdini ready yet?</a> 网站上最新的支持情况了解详情。就实际情况来看，可以在 Electron 3 （基于 Chrome 66，见<a href=\"https://electronjs.org/releases/stable?version=3&#x26;page=7\">这里</a>）或以上版本使用，但暂时不建议在 Web 项目中引入。</p>","frontmatter":{"date":"2019-10-30","title":"CSS Typed Object Model","category":"CSS"}}},{"node":{"id":"332fb33c-4a96-53f4-bc6b-152610186b51","html":"<p>Mobx 中，可以直接通过 <code class=\"language-text\">observable</code> 的方式来控制内部的 state，而不再使用 React 自带的 state 功能。一般的写法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> observer <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'mobx-react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> observable <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'mobx'</span><span class=\"token punctuation\">;</span>\n\n@observer\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  @observable num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">onClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Clicked: </span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样写的优势在于，可以将何时渲染的判断交给了 Mobx 去处理，不用手动去处理。</p>\n<p>对于需要用到 <code class=\"language-text\">observable</code> 组合数据的情况，可以使用 <code class=\"language-text\">computed</code> 来生成一个新的 <code class=\"language-text\">observable</code> 值，也可以直接使用 getter 函数。以下的两个方案在效果上是等价的：</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\">@observer\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  @observable num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">onClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">isMany</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num <span class=\"token operator\">></span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        Clicked </span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>isMany <span class=\"token operator\">?</span> <span class=\"token string\">'many'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'few'</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\"> times\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> observable<span class=\"token punctuation\">,</span> computed <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'mobx'</span><span class=\"token punctuation\">;</span>\n\n@observer\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  @observable num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">onClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  @computed\n  <span class=\"token keyword\">get</span> <span class=\"token function\">isMany</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num <span class=\"token operator\">></span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        Clicked </span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>isMany <span class=\"token operator\">?</span> <span class=\"token string\">'many'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'few'</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\"> times\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>之所以两者是等价的，理由很简单。在执行 render 函数的时候，Mobx 注意到 <code class=\"language-text\">this.isMany</code> 被使用了，而在调用这个 getter 函数的时候，实际使用到了 <code class=\"language-text\">this.num</code> 这个 observable。因此，当 <code class=\"language-text\">this.num</code> 发生了变化之后，Mobx 知道需要重新调用 render 函数进行绘制。而对于使用了 computed 的情况来说，情况会更简单一些，<code class=\"language-text\">this.num</code> 这个 observable 的变化触发了 <code class=\"language-text\">this.isMany</code> 的重新计算，最终在 <code class=\"language-text\">this.isMany</code> 值变化之后触发了 render 函数的重新计算。</p>\n<p>然而需要注意的一点是，两者只是在效果上等价。在实际运算过程中，computed 的方案有两个优势：</p>\n<ol>\n<li>代码看上去更清晰。render 是因为 computed 的数据触发的，这一点在代码上可以很容易的看出来；而第一种方案，是否触发 getter 函数，其实需要多思考一下才能确定；</li>\n<li>实际执行效率更高。使用 getter 的方案，由于 render 函数实际上是和 <code class=\"language-text\">this.num</code> 这个 observable 进行关联的，因此哪怕 <code class=\"language-text\">this.isMany</code> 这个 getter 函数没有发生值的变化，只要 <code class=\"language-text\">this.num</code> 变了，render 函数都需要被执行；而对于使用 computed 的情况，因为 render 是和 <code class=\"language-text\">this.isMany</code> 进行关联的，实际 <code class=\"language-text\">this.isMany</code> 没有变化的时候，是不需要触发重绘的。换句话说，前者 getter 的方案，在 <code class=\"language-text\">this.num</code> 从 1 涨到 6 的过程中，一共触发了五次重新渲染；而后者 <code class=\"language-text\">computed</code> 的方案，只触发了一次重新渲染（当 <code class=\"language-text\">this.num = 6</code> 的时候）</li>\n</ol>\n<p>针对第二点，Mobx 的 GitHub issue 中作者也有相关的说明，见<a href=\"https://github.com/mobxjs/mobx/issues/161#issuecomment-196744152\">这里</a>。</p>","frontmatter":{"date":"2019-10-29","title":"computed and getter in Mobx","category":"JavaScript"}}},{"node":{"id":"15786218-7294-5212-8a5c-878f74283838","html":"<p>在 Node.js 中，可以通过 <code class=\"language-text\">os</code> 模块的 <code class=\"language-text\">networkInterfaces</code> API 来获取当前机器的 IP 数据。返回的结果类似于 <code class=\"language-text\">ifconfig</code> 或 <code class=\"language-text\">ipconfig</code> 命令。</p>\n<p>以获取当前主机的 IPv4 地址为例，可以写类似如下的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getIPAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> interfaces <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'os'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">networkInterfaces</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> results <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span>interfaces<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">flat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token keyword\">interface</span></span> <span class=\"token operator\">=></span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">.</span>family <span class=\"token operator\">===</span> <span class=\"token string\">'IPv4'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token keyword\">interface</span></span> <span class=\"token operator\">=></span> <span class=\"token operator\">!</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">.</span>internal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>results<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> results<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>address<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>简单的说明如下：</p>\n<ul>\n<li><code class=\"language-text\">internal</code> 用于表示当前的地址是否是本地回环地址或是其他外部无法访问的地址（例：127.0.0.1）；</li>\n<li><code class=\"language-text\">family</code> 用于表示当前地址的类型，将会是 <code class=\"language-text\">IPv4</code> 或 <code class=\"language-text\">IPv6</code> 中的一种；</li>\n<li><code class=\"language-text\">address</code> 用于表示当前的 IP 地址；</li>\n<li><code class=\"language-text\">os.networkInterfaces</code> 的返回是一个对象，key 用于表示 network interface，比如常见的 <code class=\"language-text\">lo</code> 或者 <code class=\"language-text\">eth0</code> 等。</li>\n</ul>\n<p>更多的返回数据及解释，可以参考<a href=\"https://nodejs.org/api/os.html#os_os_networkinterfaces\">官方文档</a>。</p>","frontmatter":{"date":"2019-10-28","title":"Get Current IP Address","category":"JavaScript"}}},{"node":{"id":"9476da5c-4afa-59a0-8cca-d1690d1b4bc0","html":"<p>在一个网站中，并不是所有的页面都希望被搜索引擎的爬虫收录。为此，可以通过一些特殊的 meta 信息，来调节搜索引擎爬虫的行为。</p>\n<section><h2>nofollow</h2><p>使用方法如下：</p><div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>robots<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>nofollow<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></code></pre></div><p>或者，针对页面上某一个具体的链接，也可以加上 <code class=\"language-text\">nofollow</code> 的标记：</p><div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>some-link-to-backend-login-page<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>nofollow<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></code></pre></div><p>有了 <code class=\"language-text\">nofollow</code> 的标记，搜索引擎的爬虫就不会做进一步的爬取操作了。对于第一种写法，当前页面内所有的链接地址爬虫都不会再去访问了；对于第二种写法，则是这个指定的链接在本次爬取中不会被访问（如果其他地方有引用，且没有加上 <code class=\"language-text\">nofollow</code> 的标记，搜索引擎依然可能会去访问这个页面）。</p><p>一些常见的使用场景：付费访问的页面、不被信任的页面（比如一些留言板快）等。</p></section>\n<section><h2>noindex</h2><p>如果希望爬虫不要将当前页面的访问结果存储到数据库中用于未来搜索结果的展示，可以使用 <code class=\"language-text\">noindex</code> 标记。用法如下：</p><div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>robots<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>noindex<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></code></pre></div><p>一些常见的使用场景：后台登陆页面、感谢页面（SEO 的价值不大）或是一些内容动态的页面。</p></section>\n<section><h2>noindex nofollow</h2><p>对于既不希望爬虫进一步访问，也不希望结果被收录的页面，可以将两者都加上：</p><div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>robots<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>noindex nofollow<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></code></pre></div></section>","frontmatter":{"date":"2019-10-24","title":"noindex & nofollow","category":"SEO"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}