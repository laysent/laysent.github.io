{"componentChunkName":"component---src-templates-til-js","path":"/til/2019-05-03_restore-source-map","result":{"data":{"markdownRemark":{"id":"951e3d2b-04c7-59ef-b089-9512c23b864d","html":"<p>如果拿到了一份带有 source map 的 JavaScript 代码，那么理论上就可以通过这份 source map 去尽可能的还原出原始的文件内容。</p>\n<p>首先，source map 本质上是一个 JSON 文件。在其中，<code class=\"language-text\">sourceContent</code> 数组就记录了所有源文件的纯文本内容，而这些文件的文件路径及文件名则存放在了 <code class=\"language-text\">sources</code> 数组中。两者相互对应，理论上来说参照这两者的数据，就可以将源文件还原到原始的目录下。</p>\n<p>然而，Webpack 的打包结果，文件的路径名称都带上了 <code class=\"language-text\">webpack:///</code> 的前缀。在实际处理的过程中，可以直接使用已有的库，比如 <a href=\"https://github.com/alexkuz/restore-source-tree\"><code class=\"language-text\">restore-source-tree</code></a>。</p>\n<p>这个库因为已经比较老了，对 Webpack 3/4 等新版本的支持存在问题。在原库合并 PR 之前，可以先使用改进过的版本 <a href=\"https://github.com/laysent/restore-source-tree\"><code class=\"language-text\">restore-source-tree</code></a>。</p>\n<p>这个修改过的版本，除了修复对新版 Webpack 编译结果的支持外，也加入了 glob 的支持，可以更方便的进行批量 source map 还原。</p>\n<p>参考代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">restore-source-tree -o output_folder path/to/source-maps/*.map</code></pre></div>\n<p>最终生成的文件会存放在 output_folder 下。</p>","frontmatter":{"title":"restore source map","category":"JavaScript","date":"2019-05-03"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"time":"2019-05-03","title":"restore source map","previous":{"time":"2019-05-02","title":"webpack dynamic import"},"next":{"time":"2019-05-04","title":"css backdrop filter"}}}}