{"componentChunkName":"component---src-templates-til-per-month-js","path":"/til/2019/09","webpackCompilationHash":"e6ece375915cc981625d","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"cc87e192-33ff-5323-a2fd-b51bba483606","html":"<p>在编写 Bash 脚本的过程中，难免会遇到一些单纯用 Linux 命令很难实现的功能，比如，希望将一个文件的内容作为 JSON 的一个字段，并通过 <code class=\"language-text\">curl</code> 将这个 JSON 数据发送给服务器。如果单纯使用 Linux 的命令来拼接这个 JSON 字符串，在转意上会遇到很大的问题。但其实同样的需求，在 JavaScript 中可以通过一行命令完成：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> text<span class=\"token punctuation\">:</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>对于这样的情况，如果正好环境中有 Node.js（比如基于 Node 的 Docker 环境），就可以很方便的通过直接调用 Node 来处理这部分的需求。</p>\n<p>需要用到 <code class=\"language-text\">node.js</code> 内建的参数 <code class=\"language-text\">-e</code> 或 <code class=\"language-text\">-p</code>。</p>\n<p>对于 <code class=\"language-text\">-e</code> 这个参数（或 <code class=\"language-text\">--eval</code>），Node 会执行参数后面的字符串。类似于 <code class=\"language-text\">node file.js</code> 可以让 Node.js 执行 file.js 这个文件，<code class=\"language-text\">node -e &quot;script&quot;</code> 可以让 Node.js 执行 <code class=\"language-text\">script</code> 这串语句。需要注意的几点：</p>\n<ol>\n<li>Windows 的 CMD 不能使用单引号，只能使用双引号；Powershell 的的话，两者都是支持的；</li>\n<li><code class=\"language-text\">-e</code> 指令并不会将执行的结果输出到终端，因而如果需要 Bash 中能够用变量保存运行结果的话，需要额外使用 <code class=\"language-text\">console.log</code> 将结果输出到 stdout，然后再由 Bash 传递给需要赋值的变量。</li>\n</ol>\n<p>综上所述，上面这个 JSON 序列化的需求，就可以写成下面的这种形式：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">node -e <span class=\"token string\">\"console.log(JSON.stringify({ text: fs.readFileSync(file, 'utf8') }))\"</span></code></pre></div>\n<p>显然，对于需要赋值的情况，每次都加上 console.log 去输出结果比较的繁琐。Node.js 为此提供了另外一个可用的参数 <code class=\"language-text\">-p</code>。这个参数的表现形式和 <code class=\"language-text\">-e</code> 几乎是一样的，唯一的区别是，<code class=\"language-text\">-p</code> 会将结果默认输出到 stdout 中，不需要额外套一层 console.log 来完成这个操作。<code class=\"language-text\">-p</code> 也可以写作 <code class=\"language-text\">--print</code>。</p>\n<p>下面用一个例子来说明两者的区别：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token variable\"><span class=\"token variable\">$(</span>node -e <span class=\"token string\">\"true\"</span><span class=\"token variable\">)</span></span></code></pre></div>\n<p>上面这个命令运行的结果将输出空字符串；而下面这个命令，则会在终端输出 <code class=\"language-text\">true</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token variable\"><span class=\"token variable\">$(</span>node -p <span class=\"token string\">\"true\"</span><span class=\"token variable\">)</span></span></code></pre></div>\n<p>如此一来，上面的例子可以进一步转化为：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">node -p <span class=\"token string\">\"JSON.stringify({ text: fs.readFileSync(file, 'utf8') })\"</span></code></pre></div>\n<p>配合 <code class=\"language-text\">curl</code> 最终的命令大体上如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -X POST \\\n  -H <span class=\"token string\">\"Content-Type: application/json\"</span> \\\n  <span class=\"token variable\">$URL</span> \\\n  --data-binary \\\n    <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>node -p 'JSON.stringify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>text:fs.readFileSync<span class=\"token punctuation\">(</span><span class=\"token string\">\"filepath\"</span>,<span class=\"token string\">\"utf8\"</span><span class=\"token variable\">)</span></span>})')\"</span></code></pre></div>","frontmatter":{"date":"2019-09-03","title":"Eval Script via Nodejs","category":"Node.js"}}},{"node":{"id":"50775b1d-7fc1-5e13-9eb0-5ff1ab27876e","html":"<p>根据 TSLint 官方给出的建议，TypeScript 项目的代码，现在也推荐使用 ESLint 来进行代码规范的检查。</p>\n<p>在具体使用的时候，需要在 <code class=\"language-text\">.eslintrc</code> 中增加如下部分的设置：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"parser\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"@typescript-eslint/parser\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"@typescript-eslint\"</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"parserOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"ecmaVersion\"</span><span class=\"token operator\">:</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"sourceType\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"module\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"project\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./tsconfig.json\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"ecmaFeatures\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"jsx\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>其中，需要用到 <code class=\"language-text\">typescript-eslint</code> 这个库来帮助 ESLint 解析代码（<a href=\"https://github.com/typescript-eslint/typescript-eslint\">GitHub</a>）。</p>\n<p>然而，在实际使用 ESLint 来检查 TypeScript 代码的时候，需要额外注意一个细节：</p>\n<p>根据<a href=\"https://github.com/typescript-eslint/typescript-eslint/issues/355#issuecomment-473353680\">这里</a>给出的解释，ESLint 默认情况下并不会检查非 <code class=\"language-text\">.js</code> 和 <code class=\"language-text\">.jsx</code> 结尾的文件。也就是说，如果 <code class=\"language-text\">src</code> 目录下有以下几个文件：<code class=\"language-text\">src/index.js</code>，<code class=\"language-text\">src/app.tsx</code>，<code class=\"language-text\">src/utils.ts</code>，那么在运行命令 <code class=\"language-text\">eslint src</code> 的时候，只有 <code class=\"language-text\">src/index.js</code> 会被检查，剩下的两个会直接被忽略。</p>\n<p>需要检查 TypeScript 的代码，需要手动在调用 <code class=\"language-text\">eslint</code> 命令行的时候加上 <code class=\"language-text\">--ext</code> 参数，如：<code class=\"language-text\">--ext js,jsx,ts,tsx</code>。</p>\n<p>当然，如果给 ESLint 手动指定需要检查的文件，或是通过 <code class=\"language-text\">lint-staged</code> 工具在 Git 签入的时候对 TypeScript 文件进行检查，这些情况下都是不需要额外指定 <code class=\"language-text\">--ext</code> 参数的，ESLint 可以正确处理 TypeScript 的代码。</p>","frontmatter":{"date":"2019-09-02","title":"ESlint for TypeScript","category":"Tool"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"startInMonth":"2019-09-01","endInMonth":"2019-09-31","time":"2019-09","previous":"2019-08","next":null}}}