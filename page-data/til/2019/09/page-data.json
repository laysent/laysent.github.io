{"componentChunkName":"component---src-templates-til-per-month-js","path":"/til/2019/09","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"d2c713ba-83c1-5c25-8d75-4bb1aece6f6b","html":"<p>浏览器提供了 <code class=\"language-text\">performance</code> 用于测量 JavaScript 的一些运行效率，并在浏览器的对应位置（如 Chrome 的 Performance Tab）生成火焰图，可以方便的查看程序调用栈的执行效率。简单的操作如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getMarkName</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">mark: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">beginMark</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">mark</span><span class=\"token punctuation\">(</span><span class=\"token function\">getMarkName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">endMark</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> markName <span class=\"token operator\">=</span> <span class=\"token function\">getMarkName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    performance<span class=\"token punctuation\">.</span><span class=\"token function\">measure</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> markName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果 markName 无法被找到（也就是 beginMark 函数没有被调用）</span>\n    <span class=\"token comment\">// 那么程序在 performance.measure 的时候会报错</span>\n    <span class=\"token comment\">// 这里无需将报错抛出，直接吞掉就可以了</span>\n  <span class=\"token punctuation\">}</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">clearMarks</span><span class=\"token punctuation\">(</span>markName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">clearMeasure</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">beginMark</span><span class=\"token punctuation\">(</span><span class=\"token string\">'label name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 需要进行的操作</span>\n  <span class=\"token function\">endMark</span><span class=\"token punctuation\">(</span><span class=\"token string\">'label name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>具体来说，通过 <code class=\"language-text\">performance.mark</code> 函数标记一个点，然后在需要测量的程序执行完成之后，通过 <code class=\"language-text\">performance.measure</code> 来计算当前和最初 mark 的点之间的运行时间。最终，这一段结果会在 Chrome 的 Performance Timings 中形成对应的火焰图数据。</p>\n<p><code class=\"language-text\">performance.measure</code> 也支持三个参数的调用，三个参数分别是 label 的名称，起始 mark 的名称以及终止 mark 的名称。如果省略最后一个参数，那么终止的时间点就是当前 <code class=\"language-text\">performance.measure</code> 调用的时间点。</p>\n<p>最后，通过 <code class=\"language-text\">performance.clearMarks</code> 及 <code class=\"language-text\">performance.clearMeasure</code> 删除标记，清理不必要的内存使用。</p>\n<p>更多的介绍，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance\">MDN</a> 的文档。React 中也使用了类似的技术用于在 Performance 中生成每个 Component 渲染花费的时间，相关的代码可以参考 <a href=\"https://github.com/facebook/react/blob/50addf4c0e411e351de7290c8c60ec775c25c8c4/packages/react-reconciler/src/ReactDebugFiberPerf.js#L80\">ReactDebugFiberPerf.js</a>。</p>","frontmatter":{"date":"2019-09-30","title":"Performance Measure","category":"JavaScript"}}},{"node":{"id":"27ff91be-e0ae-5169-a594-b6e813c36527","html":"<p>JavaScript 中提供了 <code class=\"language-text\">devicemotion</code> 事件，可以用于监听设备各个方向上受到的力（加速度）。有了这个事件，就可以用于判断当前用户是否在进行类似“摇一摇”之类的操作，方便开发基于特定交互的一些功能。</p>\n<p>具体来说，<code class=\"language-text\">devicemotion</code> 事件会提供 <code class=\"language-text\">accelerationIncludingGravity</code> 数据，作为一个对象分别提供 <code class=\"language-text\">x</code>，<code class=\"language-text\">y</code> 和 <code class=\"language-text\">z</code> 三个方向上的加速度。通过不同时间点上加速度值的不同，就可以判断当前用户是否在进行摇晃手机的操作了。</p>\n<p>使用 <code class=\"language-text\">devicemotion</code> 的示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>accelerationIncludingGravity<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// do stuff here</span>\n<span class=\"token punctuation\">}</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'devicemotion'</span><span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>判断是否在摇晃手机，简单来说，只需要判断当前的各方向加速度之差，是否有至少两个超过了给定的阈值。<a href=\"https://github.com/alexgibson/shake.js\">shake.js</a> 中就使用了这样的方法来判断当前用户是否在摇晃手机，具体的代码可以参考<a href=\"https://github.com/alexgibson/shake.js/blob/d232eee7a5f31e9fd37aa79aa83f1f206035ccc9/shake.js#L104\">源码</a>。</p>\n<p><code class=\"language-text\">devicemotion</code> 更多的信息，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/devicemotion_event\">MDN</a>。</p>","frontmatter":{"date":"2019-09-29","title":"Mobile Shake","category":"JavaScript"}}},{"node":{"id":"c2ac584c-7986-51ff-af03-f2ebb8edf03d","html":"<p>在 Webpack 的编译过程中，可以通过 <code class=\"language-text\">devtool</code> 的配置选项选择以什么样的形式输出 SourceMap。Webpack 提供了非常多的选择方案，不同的选项可以达到的效果是不一样的，也会极大的影响最终编译的时间。Webpack 的官方<a href=\"https://webpack.js.org/configuration/devtool/\">文档</a>，从编译时间、重编译时间（针对 Watch 下的修改重编译）以及最终的使用效果三个纬度，给出了各个配置选项的实际效果。（中文版文档在<a href=\"https://webpack.docschina.org/configuration/devtool/\">这里</a>）</p>\n<p>一般情况下：生产环境最终的打包，建议使用 <code class=\"language-text\">source-map</code> 作为配置。这种配置会将 SourceMap 文件打包到另外一个独立的文件中，线上代码不会暴露源文件，同时提供了最精细的代码映射关系，方便线上代码的调试和问题定位。当然，这种配置的缺点也非常明显，就是构建过程比较花费时间，因此一般只建议在最终要上线的版本中使用这种配置。</p>\n<p>对于开发环境 Watch 模式下打包 Hot Reload 的版本，建议使用 <code class=\"language-text\">eval-source-map</code> 或者 <code class=\"language-text\">cheap-module-eval-source-map</code>。这两种模式，都会将代码用 <code class=\"language-text\">eval</code> 函数包裹起来，重编译的速度比较快，区别主要在于 SourceMap 的生成方案。前者会生成高品质的 SourceMap，因而初次构建的速度会比较慢，但是提供了行和列的映射；后者只提供了行层面的代码映射，因此会更加快一些，但是断点的效果会略打折扣（无法提供到列的映射关系）。</p>\n<p>更多的类型以及各种情况的说明，可以参考官方文档（链接在上面给出）。</p>","frontmatter":{"date":"2019-09-27","title":"SourceMap in Webpack","category":"Build"}}},{"node":{"id":"57f77e04-3b60-51bb-8fbf-1b73e3c87fb7","html":"<p>优化的第一步，是知道瓶颈在哪里。</p>\n<p>在针对 Webpack 编译速度优化的过程中，知道哪些 loader / plugin 运行耗费了很多时间就显得非常重要了。</p>\n<p>Speed Measure Plugin 是一款针对 Webpack 的插件，只需要一些非常简单的操作，插件就可以在已有配置的基础上，给 Webpack 的打包过程增加必要的计时功能，同时清晰的列举出各个 loader / plugin 在本次编译中的耗时情况。Plugin 的文档在<a href=\"https://github.com/stephencookdev/speed-measure-webpack-plugin#readme\">这里</a>。</p>\n<p>简单来说，只需要在原有的配置基础上，这么额外包一层 Speed Measure Plugin 就可以了：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> SpeedMeasurePlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"speed-measure-webpack-plugin\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> smp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SpeedMeasurePlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> disable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> smp<span class=\"token punctuation\">.</span><span class=\"token function\">wrap</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，<code class=\"language-text\">disable: false</code> 表示需要 Speed Measure Plugin 记录时间，这也是默认的值，可以不传。如果赋值是 <code class=\"language-text\">true</code>，那么就会告知 Speed Measure Plugin 不要做任何处理，结果等同于没有使用 Speed Measure Plugin。如果需要经常对 Webpack 的打包进行优化，可以将 Speed Measure Plugin 的代码写入到库中，并通过环境变量等方法在打包的时候开启或关闭这个记录的功能。</p>","frontmatter":{"date":"2019-09-26","title":"Webpack Speed Measure","category":"Build"}}},{"node":{"id":"783fc4da-adbf-5fd4-93e3-a9f67e54aa99","html":"<p><code class=\"language-text\">mochawesome</code> 是为 Mocha 提供的一个 Report 库，可以用于生成不错的 HTML 报告（见 <a href=\"https://www.npmjs.com/package/mochawesome\">npm</a>）。库本身提供了一个 <code class=\"language-text\">addContext</code> 的 API，可以用于在运行 Test 的时候，存入额外的信息到 Context 中，最终在生成 HTML 报告的时候，将这部分 Context 信息写入对应的测试用例内。</p>\n<p>参考代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> addContext <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mochawesome/addContext'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test suite'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'unit test'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addContext</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'content'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// or</span>\n    <span class=\"token function\">addContext</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      title<span class=\"token punctuation\">:</span> <span class=\"token string\">'title'</span><span class=\"token punctuation\">,</span>\n      value<span class=\"token punctuation\">:</span> <span class=\"token string\">'value or object'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>几点说明：</p>\n<ol>\n<li>在 <code class=\"language-text\">beforeEach</code> 或 <code class=\"language-text\">afterEach</code> 的钩子内调用 <code class=\"language-text\">addContext</code> 也是允许的；</li>\n<li>如果给定的第二个参数是 URL 或是一个图片的话，<code class=\"language-text\">mochawesome</code> 可以有相对应的展示；</li>\n<li>记得 <code class=\"language-text\">it</code> 函数的第二个参数不要使用箭头函数，否则 <code class=\"language-text\">this</code> 的指向会有问题</li>\n</ol>\n<p>然而，在 Cypress 中如果试图直接使用上述方法运行代码，会发现并不能成功。最终生成的报告内并没有对应的 context 信息。其原因在于，Cypress 在运行的过程中，原本被赋值的 <code class=\"language-text\">context</code> 属性被覆盖掉了，导致虽然进行了 <code class=\"language-text\">addContext</code> 的赋值，但是最终的结果中并没有保留这部分数据。</p>\n<p>一个可行的解决方案是，在 <code class=\"language-text\">test:after:run</code> 事件中再进行赋值，保证结果生效。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> addContext <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mochawesome/addContext'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nCypress<span class=\"token punctuation\">.</span>Commands<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'addContext'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">content</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  cy<span class=\"token punctuation\">.</span><span class=\"token function\">once</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test:after:run'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">test</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> test <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>几点说明：</p>\n<ol>\n<li>因为 <code class=\"language-text\">addContext</code> API 本质上就是往 <code class=\"language-text\">test</code> 对象上写 context 数据，而 Cypress 的 API 正好提供了 test 对象，因而第一个参数不需要传 <code class=\"language-text\">this</code>，直接将 test 以合适的方法传入就可以了；</li>\n<li>上面的代码定义了一个 Cypress 的命令方便各个地方调用，类似的代码改成一个普通的函数也是可以的；</li>\n<li>需要用 <code class=\"language-text\">cy.once</code> 保证这个代码只会被调用一次，这样其他的测试用例中不会有类似的数据被写入</li>\n</ol>","frontmatter":{"date":"2019-09-25","title":"Add Context in Mochawesome Report","category":"Cypress"}}},{"node":{"id":"1b9a898d-4d6f-5201-8c9a-05733edf90ee","html":"<p>在用 React 处理业务的过程中，经常会遇到这样的场景：某一个 UI 需要等待网络请求来展示，在等待的过程中，需要显示 Loading 界面，并在请求完成后，显示真正的 UI。这种情况，和按需加载模块的行为非常类似。既然 React.Suspense + React.lazy 可以组合用于按需加载模块时候的 UI 展示，那么是否可以使用同样的组合来完成类似等待网络请求的 UI 显示呢？答案是肯定的。下面给出一个示例代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">time</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fakeFetch</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">\"finished!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> Component <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">fakeFetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">text</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">default</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>text<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"App\"</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>React<span class=\"token punctuation\">.</span>Suspense fallback<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>loading<span class=\"token operator\">...</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello World<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>Component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>React<span class=\"token punctuation\">.</span>Suspense<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如此一来，在 Promise 没有返回的时候，组件会显示 <code class=\"language-text\">&lt;div&gt;loading...&lt;/div&gt;</code>。而等到 Promise resolve 之后，就会显示真正的 UI。</p>\n<p>几点说明：</p>\n<ol>\n<li><code class=\"language-text\">React.lazy</code> 本身是为 <code class=\"language-text\">import()</code> 设计的，所以在 Promise 返回的时候，需要将组件放到 <code class=\"language-text\">default</code> 属性下面，保持和 <code class=\"language-text\">import()</code> 的行为一致；</li>\n<li><code class=\"language-text\">React.Suspense</code> 和 <code class=\"language-text\">React.lazy</code> 的组合，本质上内部是使用了 <code class=\"language-text\">throw</code> + <code class=\"language-text\">componentDidCatch</code> 的方式进行实现的，因而如果不使用 <code class=\"language-text\">React.lazy</code>，直接在组件内 <code class=\"language-text\">throw Promise</code>，也可以达到类似的效果：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fakeFetch</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">fn</span> <span class=\"token operator\">=></span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"finished!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> data <span class=\"token operator\">=</span> <span class=\"token string\">\"before\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Component</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data <span class=\"token operator\">===</span> <span class=\"token string\">\"before\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token function\">fakeFetch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newData</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      data <span class=\"token operator\">=</span> newData<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"App\"</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>React<span class=\"token punctuation\">.</span>Suspense fallback<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>loading<span class=\"token operator\">...</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello World<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>Component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>React<span class=\"token punctuation\">.</span>Suspense<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-09-24","title":"Suspense & Lazy in React","category":"JavaScript"}}},{"node":{"id":"6e987333-0e0f-57fb-8f42-eaa464ad5564","html":"<p>一般情况下，只有当用户有操作的情况下，在一个 tick 里，JavaScript 通过 <code class=\"language-text\">window.open</code> 或是 <code class=\"language-text\">&lt;a target=&quot;_blank&quot;&gt;</code> HTML 元素直接 <code class=\"language-text\">click</code> 打开新的窗口才能正常弹出。如果一旦涉及到异步的操作，弹框就会默认被浏览器阻止，无法正常显示。</p>\n<p>这样设计的初衷，是为了防止前端随意弹框，影响到用户正常的体验。然而，在某些情况下，用户操作后需要经过网络请求，返回结果后才知道应该如何展示弹框。这种情况下，简单的 <code class=\"language-text\">fetch().then(() =&gt; window.open())</code> 肯定是不行的。需要一些 Hack 的方案，如下。</p>\n<p>在用户进行了操作之后，首先先打开一个新的窗口，等到异步操作返回之后，再通过 JavaScript 修改这个窗口的地址，从而达到异步打开窗口的目的。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">element<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onclick</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> win <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 模拟异步操作</span>\n  <span class=\"token keyword\">await</span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  win<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> <span class=\"token string\">'actual location'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这样操作可能的问题及解决方法：</p>\n<ol>\n<li>如果在异步的过程中本窗口被关闭了，就会留下一个空白的新窗口。因而，需要监听 <code class=\"language-text\">beforeunload</code> 事件，以保证必要时候可以关闭新打开的窗口；</li>\n<li>如果异步的时间比较长，打开一个空白的窗口用户体验较差（打开后默认会获得焦点）。这种情况下，可以打开一个静态的页面，展示一个 loading 的 UI 以告诉用户当前正在进行的操作。待异步操作完成，再通过 postMessage 等方式通知窗口进行页面的跳转。</li>\n</ol>","frontmatter":{"date":"2019-09-23","title":"Open Window Async","category":"JavaScript"}}},{"node":{"id":"f512f692-4d3c-5bbc-9056-f9b0b5e9a702","html":"<p>在实际的开发过程中，经常有多分支并发操作的情况，比如：</p>\n<ol>\n<li>PC 软件需要维护多个版本，在新的版本分支上开发新功能，同时维护旧的版本以修复问题；</li>\n<li>针对 Gerrit 这类只允许单 commit 迁入的工具，一个版本开发多个功能，可能需要分成多个分支同时进行</li>\n</ol>\n<p>这种情况下，在版本间切换往往有两个常见的方式：</p>\n<ol>\n<li>将当前的代码 stash 后，切换分支，进行对应的处理，处理完了再回到原来的分支 <code class=\"language-text\">git stash pop</code> 继续原先的开发工作；</li>\n<li>直接 <code class=\"language-text\">git clone</code> 一个新的仓库，在上面完成必要的工作</li>\n</ol>\n<p>第一种方案的问题主要是，切换多次的话，很容易搞不清楚当前分支下还有哪些是 stash 的，管理起来有点麻烦。有时候方便起见，也会直接将当前的内容 commit 到分支上，再进行切换。考虑到 git hook 的存在，commit 可能还需要加上 <code class=\"language-text\">--no-verify</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> <span class=\"token function\">add</span> -A <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> commit -m <span class=\"token string\">\"wip\"</span> --no-verify</code></pre></div>\n<p>第二种方案的问题主要是，多个文件仓库重复下载了多次 <code class=\"language-text\">.git</code> 目录，在一些大型项目中，这里会导致大量的硬盘空间被浪费。</p>\n<p>Git 在 2.5 版本中提供了 worktree 的功能，用于解决这一痛点。在一个 Git 项目中，只需要执行如下的命令，就可以新创建一个文件仓库：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree <span class=\"token function\">add</span> -b new-branch-name /path/to/folder origin/branch/name</code></pre></div>\n<p>新创建的文件仓库被放在 <code class=\"language-text\">/path/to/folder</code> 中，使用的仓库名称是 <code class=\"language-text\">new-branch-name</code>，基于 <code class=\"language-text\">origin</code> 上的 <code class=\"language-text\">branch/name</code>。如果只需要使用一个已经存在的分支，可以简化成：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree <span class=\"token function\">add</span> /path/to/folder local/branch/name</code></pre></div>\n<p>之后，在 <code class=\"language-text\">/path/to/folder</code> 中就可以进行常规的开发了。值得一提的是，原 Git 目录下的 Hook 文件也会一并同步到新的工作目录下，可以直接使用。通过查看目录下的文件，不难发现 Git 的同步方式。事实上，在 WorkTree 目录下，并没有一个 <code class=\"language-text\">.git</code> 目录，取而代之的，只有一个 <code class=\"language-text\">.git</code> 文件，里面标注了真正的 <code class=\"language-text\">.git</code> 目录应该去那里查找。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">gitdir: /path/to/actual/.git/worktrees/name</code></pre></div>\n<p>也正因为如此，WorkTree 下所有的 Git 配置都是同步的。</p>\n<p>如果需要查看当前的 Git 中到底有多少个 WorkTree，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree list</code></pre></div>\n<p>命令会列出所有 WorkTree 的目录以及当前使用的分支名称。</p>\n<p>在开发完成后，如果希望删除 WorkTree，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree remove /path/to/folder</code></pre></div>\n<p>删除完成后，可以通过 <code class=\"language-text\">git worktree list</code> 来检查是否真的被删除了。</p>\n<p>延伸阅读：</p>\n<ul>\n<li><a href=\"https://git-scm.com/docs/git-worktree\">官方文档</a></li>\n<li><a href=\"https://spin.atomicobject.com/2016/06/26/parallelize-development-git-worktrees/\">Parallelize Development Using Git Worktrees</a></li>\n<li><a href=\"https://www.saltycrane.com/blog/2017/05/git-worktree-notes/\">git worktree notes</a></li>\n</ul>","frontmatter":{"date":"2019-09-22","title":"Git Worktree","category":"Git"}}},{"node":{"id":"03867888-4df4-54ab-af0a-3ea92ffb495f","html":"<p>在 React 的开发中，需要在 Component 的 render 函数或是 Functional Component 的函数中，返回一个定义好的 JSX 内容，用于表示具体需要渲染出来的 UI 样式。Babel 或 TypeScript 会在编译时将这个对象转化成一个 JavaScript 可以理解的一般函数调用（具体调用的函数根据库的不同可能存在差异，对于 React 来说就是 <code class=\"language-text\">React.createElement</code> 函数，对于 Preact 来说则是 <code class=\"language-text\">h</code> 函数）。这个函数会在运行时被执行，并返回一个普通的 Object。React 拿到这个 Object 之后，就可以根据其中的内容来渲染出对应的 UI（根据具体执行的环境，这个步骤可能通过 React-DOM 或 React Native 来完成）。</p>\n<p>既然 JSX 的部分会被编译成普通的函数调用，并在运行时被反复执行，这里必然会有一些性能上的损耗。</p>\n<p>而在实际的开发中，存在着很多的组件，实际需要返回的 JSX 是固定不变的。比如说：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在上面这个例子中，实际上条件的第一种结果，返回的 JSX 是一个固定的值。手动的优化可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> loadingComponent <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> loadingComponent<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样，每次当 <code class=\"language-text\">loading = true</code> 的时候，都会直接返回 <code class=\"language-text\">loadingComponent</code>，而不需要反复执行 <code class=\"language-text\">React.createElement(Loading)</code> 这个函数去拿到最终的返回 Object。除了在运行时减少了重复计算，节省了时间和内存开销（这个在 re-render 非常频繁的时候有一定的优势），另一个好处是，React 可以通过比较返回的结果知道 Object 并没有发生变化，从而直接结束渲染的流程，不再进行接下来更深层次的渲染。</p>\n<p>这部分的操作，其实可以交给编译器去完成。Babel 有一个插件 <code class=\"language-text\">@babel/plugin-transform-react-constant-elements</code> 可以拿来做这方面的优化，具体的使用方式以及可能存在的问题可以参考<a href=\"https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements/\">文档</a>。</p>\n<p>当然，上面的优化依然存在小的瑕疵：因为把创建 Object 的操作提到了初始化的时候就直接进行了，如果存在大量类似的优化，会导致 JavaScript 初始运行的速度被减慢。大量的 Object 被事先创建了出来，而实际上这部分内容都远还没有到需要用的时候。一个更极致的优化可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> loadingComponent<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>loadingComponent<span class=\"token punctuation\">)</span> loadingComponent <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> loadingComponent<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这部分的操作就不是 Babel 插件原生支持的了。</p>\n<p>从目前的实际情况来看，生成 JSX 对应 Object 拖慢初始化的例子暂时还不存在（毕竟 <code class=\"language-text\">React.createElement</code> 的执行速度并不是非常慢，而且一个项目中的 JSX 数量也不会非常庞大）。如果有必要，可以 <a href=\"https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-react-constant-elements\">GitHub</a> 上提出 PR，按照类似上面提到的方式进行进一步的优化。</p>","frontmatter":{"date":"2019-09-19","title":"Babel JSX Improvement","category":"Build"}}},{"node":{"id":"36872891-c5a0-57ab-a5f7-a569c2473f52","html":"<p>在判断一个 DOM 节点是否包含另一个节点的时候，常常用到 <code class=\"language-text\">contains</code> 这个 API。在实际的使用从过程中，也经常会遇到这样的情况，需要判断 A 是否包含 B，返回是 <code class=\"language-text\">false</code>，但经过排查，发现其实 A 和 B 就是同一个节点。这种情况下，光用 <code class=\"language-text\">contains</code> API 就有点不够用了。同时，也暴露了这个 API 本身能力的局限性。</p>\n<p>在 DOM Level 3 的<a href=\"https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-compareDocumentPosition\">规范</a>中，定义了一个新的 API，<code class=\"language-text\">compareDocumentPosition</code>。相比于 <code class=\"language-text\">contains</code>，<code class=\"language-text\">compareDocumentPosition</code> 提供了更强大的判断结果。</p>\n<p><code class=\"language-text\">compareDocumentPosition</code> 这个 API 比较后会返回一个数字，通过二进制位的比较，可以用于判断两个节点之间的关系。假设调用的函数为 <code class=\"language-text\">A.compareDocumentPosition(B)</code>，那么返回值具体支持的类型如下：</p>\n<table>\n<thead>\n<tr>\n<th>常量名</th>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code></td>\n<td>1</td>\n<td>不在一个文档中</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_PRECEDING</code></td>\n<td>2</td>\n<td>B 在 A 之前</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_FOLLOWING</code></td>\n<td>4</td>\n<td>B 在 A 之后</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_CONTAINS</code></td>\n<td>8</td>\n<td>B 包含 A</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_CONTAINED_BY</code></td>\n<td>16</td>\n<td>A 包含 B</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code></td>\n<td>32</td>\n<td>A 和 B 的位置关系取决于具体的实现方式（不由规范确定）</td>\n</tr>\n</tbody>\n</table>\n<p>这里之所以使用二进制位表示位置关系，一个很重要的原因就是：API 有可能会一次性返回多个结果。举个例子，假设 <code class=\"language-text\">A.contains(B)</code> 返回 <code class=\"language-text\">true</code>。那么，在调用 <code class=\"language-text\">A.compareDocumentPosition(B)</code> 的时候，返回值是 <code class=\"language-text\">20</code>，也就是 <code class=\"language-text\">Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY</code> 的结果。换句话说，B 元素在文档中的位置在 A 的后面，同时 B 也是 A 的一个子元素。</p>\n<p>这里，<code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code> 表示两个节点不再同一个文档中，有几种可能的情况：</p>\n<ol>\n<li>A 和 B 中某一个存在于 iframe 中，因而两者不属于同一个文档（<code class=\"language-text\">A.ownerDocument !== B.ownerDocument</code>）；</li>\n<li>A 和 B 中某一个元素被删除了（或没有插入到 DOM 中），导致两者不属于同一个文档（可以通过 <code class=\"language-text\">A.parentElement</code> 和 <code class=\"language-text\">B.parentElement</code> 判断是否被删除，被删后就没有父元素了）</li>\n</ol>\n<p>另外，<code class=\"language-text\">DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code> 有两种情况：</p>\n<ol>\n<li>A 和 B 没有任何相同的 container，这种情况和 <code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code> 是等价的。换句话说，当有 <code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code> 的时候，一定同时有 <code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code>；</li>\n<li>A 和 B 是同一个元素的两个属性值，这种情况下，谁先谁后是由具体实现决定的。比如，<code class=\"language-text\">Element.attributes</code> 返回一个 <code class=\"language-text\">NamedNodeMap</code>。根据<a href=\"https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1780488922\">规范</a> 的定义，<code class=\"language-text\">NamedNodeMap</code> 不维护一个具体的顺序，但同时提供使用 index 访问的 API。也就是说，<code class=\"language-text\">Element.attributes</code> 中的任意两个字段，是没有定义上的先后之分的（虽然可能通过不同的下标获取到）。具体来说：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// div = &lt;div id=\"id\" class=\"class>&lt;/div></span>\n<span class=\"token keyword\">const</span> attributes <span class=\"token operator\">=</span> div<span class=\"token punctuation\">.</span>attributes<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> attributes<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareDocumentPosition</span><span class=\"token punctuation\">(</span>attributes<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// result = 36</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，<code class=\"language-text\">compareDocumentPosition</code> 返回的结果是 <code class=\"language-text\">36</code>，即 <code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING</code>。因此，在实际使用 API 的时候，有必要检查是否有 <code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code> 这一位，如果有的话，其他的结果都可以忽略不计了。</p>\n<p>另外，如果 A 和 B 是同一个元素，那么返回的结果将是 <code class=\"language-text\">0</code>，因为 A 和 B 的关系不属于上面列出的任何一种情况。同时，也不难发现，只有当 A 和 B 是同一个元素的时候，才会出现返回值是 0 的情况。</p>","frontmatter":{"date":"2019-09-18","title":"compareDocumentPosition","category":"JavaScript"}}},{"node":{"id":"e67d176b-9712-599d-a833-f4bdbec4db4c","html":"<p>默认情况下，使用 <code class=\"language-text\">git pull</code> 拉取最新代码的时候，Git 会触发 <code class=\"language-text\">git merge</code> 来进行远端代码和本地代码的合并。如果两份代码之间没有冲突，那么 Merge 行为可以进行 Fast Forward，最终的结果是比较“干净”的 Commit；然而，如果 Fast Forward 无法进行，那么最终的显示效果，是 git 的历史中会多出一条 Merge 的 commit。</p>\n<p>在绝大多数情况下，这类 Merge commit 都是多余的。这种时候，一般会建议使用 <code class=\"language-text\">git pull --rebase</code> 命令来拉取代码。这样，拿到最新代码后，Git 会使用 rebase 而不是 merge 来进行远端代码和本地代码的合并（关于 Merge 和 Rebase 的一些讨论，可以参考 Atlassian 的<a href=\"https://www.atlassian.com/git/tutorials/merging-vs-rebasing\">文章</a>）。</p>\n<p>当然，每次都这么写会比较繁琐。一个简单的方法，是通过 Shell 进行下面的 Git 配置：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> config --global pull.rebase <span class=\"token boolean\">true</span></code></pre></div>\n<p>或者，等价的，可以在 <code class=\"language-text\">~/.gitconfig</code> 文件中，增加如下的配置信息：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[pull]\n  rebase = true</code></pre></div>\n<p>（针对 Git 版本小于 1.7.9 的情况，配置可以参考<a href=\"https://coderwall.com/p/tnoiug/rebase-by-default-when-doing-git-pull\">这里</a>）</p>\n<p>如此一来，<code class=\"language-text\">git pull</code> 的默认行为就会从 merge 变成 rebase。</p>\n<p>在这种情况下，如果希望使用 merge 的行为，可以写 <code class=\"language-text\">git pull --no-rebase</code>。</p>","frontmatter":{"date":"2019-09-17","title":"Git Pull Rebase","category":"Git"}}},{"node":{"id":"94771edf-9925-57ce-9664-d4ad9901aa9c","html":"<p>现在 Web 端的视频播放，大多采用基于 <a href=\"https://en.wikipedia.org/wiki/HTTP_Live_Streaming\">HLS</a> 或是 <a href=\"https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP\">MPEG Dash</a> 的方案，将视频内容分解成一系列小型 HTTP 文件片段，每段都包含很短长度的可播放片段，由前端逐个拉取片段并播放，最终形成完整的播放视频。</p>\n<p>对于一些云存储网站来说，也可以通过类似的方案来为用户提供下载服务。在分片下载文件的过程中，服务商可以对下载的用户进行校验。同时，由于需要分段下载内容并拼接，避免了单一 URL 造成盗链等问题。然而，一个用户体验的问题是，这种形式的下载如何可以给用户一个更好的用户体验：显然不能将分段的下载内容直接呈现给用户，用户也不应该关心这些分片的内容；如果要等到前端将所有内容下载完成并拼接后再呈现给客户，那么在文件较大的时候会让用户等待很久，用户体验不佳。</p>\n<p>这时候，就可以用到 Service Worker 的 Proxy 功能了，可以在前端进行拼接数据的过程中，给用户等同于一般下载文件的体验。</p>\n<p>大致的流程代码如下：</p>\n<p>首先，需要在 Service Worker 和 Main 线程见建立一个通信机制。比如，可以选择使用 MessageChannel。在 Main 线程创建一个 MessageChannel，然后将 Channel 发送给 Service Worker。之后两者通过这个 Channel 进行数据的沟通（主要是 Main 将下载好的文件片段发送给 Service Worker）。</p>\n<p>接着，在 Service Worker 端的 MessageChannel 收到新的数据之后，创建一个 ReadableStream 并将数据写入这个 Stream。</p>\n<p>最后，Main 会通过 JavaScript 访问一个不存在的下载链接，里面应该包含一个 ID，用于指明需要的文件具体是哪一个（主要是考虑到多个文件同时下载的情况）。Service Worker 通过 fetch 事件拦截这个请求，并通过 URL 中的 ID 找到对应的 ReadableStream，并将这个 Stream 作为 Response 返回。这样，在浏览器的下载页面就可以看到该文件正在被下载。和原生的下载体验一致，这里也可以看到下载的名称、当前的速度、剩余的时间等信息。</p>\n<p>如此，一个完整的流程就走完了。前端下载文件分片，将分片数据发送给 Service Worker，Service Worker 收到数据之后，将数据写入到 ReadableStream 中去；同时，这个 ReadableStream 以 Response 的形式返回给 Main 线程，将这个拼接中的文件逐步下载到本地。</p>\n<p>Fetch 事件的代理代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">self<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onfetch</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> url <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 跳过一般的请求</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isDownloadUrl</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> event<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> headers <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Headers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  headers<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Content-Type'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'application/octet-stream; charset=UTF-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 获取 URL 中的 ID 数据</span>\n  <span class=\"token comment\">// 相当于 Main 线程通过 URL 传递参数给 Service Worker，用于表示想要下载的具体数据</span>\n  <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token function\">getDownloadFileID</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> streamInfo <span class=\"token operator\">=</span> streamMapping<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>streamInfo<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 没有找到数据的情况，返回 404</span>\n    <span class=\"token keyword\">return</span> event<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Response</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Not Found'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      headers<span class=\"token punctuation\">,</span>\n      status<span class=\"token punctuation\">:</span> <span class=\"token number\">404</span><span class=\"token punctuation\">,</span>\n      statusText<span class=\"token punctuation\">:</span> <span class=\"token string\">'Not Found'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> filename <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> streamInfo<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// Content-Disposition 中的 filename 必须是 US-ASCII</span>\n  <span class=\"token comment\">// http://tools.ietf.org/html/rfc2183#section-2.3</span>\n  <span class=\"token keyword\">const</span> asciiName <span class=\"token operator\">=</span> filename<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/[^\\x20-\\x7e\\xa0-\\xff]/g</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 通过 filename*=UTF-8''xxx 这样的方式，可以让浏览器使用 UTF-8 的文件名</span>\n  <span class=\"token keyword\">const</span> encodedName <span class=\"token operator\">=</span> <span class=\"token function\">encodeURIComponent</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/['()]/g</span><span class=\"token punctuation\">,</span> escape<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/\\*/g</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"%2A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  headers<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">'Content-Disposition'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">attachment; filename=\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>asciiName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\"; filename*=UTF-8''</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>encodedName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  headers<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Content-Length'</span><span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>streamInfo<span class=\"token punctuation\">.</span>filesize<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  headers<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">'X-Content-Type-Options'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'nosniff'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 将 Service Worker 中的 stream 作为 Response 返回</span>\n  <span class=\"token comment\">// 只要 Stream 没有完结，浏览器的下载行为就会继续，直到 Stream 停止</span>\n  <span class=\"token keyword\">return</span> event<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Response</span><span class=\"token punctuation\">(</span>streamInfo<span class=\"token punctuation\">.</span>stream<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    headers\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>关于上面代码的两个延伸阅读：</p>\n<ol>\n<li>虽然 Content-Disposition 默认只能写 ASCII 的文件名，但是 UTF-8 的文件名也是可以设置的。关于 <code class=\"language-text\">filename*=UTF-8&#39;&#39;xxx</code> 这种设置方案，在 <a href=\"https://stackoverflow.com/questions/93551/how-to-encode-the-filename-parameter-of-content-disposition-header-in-http\">StackOverflow</a> 上有相关讨论</li>\n<li><code class=\"language-text\">X-COntent-Type-Options</code> 设置为 <code class=\"language-text\">nosniff</code> 可以阻止浏览器的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#MIME_sniffing\">MIME 类型嗅探</a>，更多讨论可以参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options\">MDN</a></li>\n</ol>\n<p>创建和使用 Stream 的代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> stream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReadableStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      <span class=\"token function-variable function\">start</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">controller</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token function-variable function\">pull</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">controller</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 当从 Stream 获取数据的时候，返回一个 Promise</span>\n          <span class=\"token comment\">// 并在 onUpdate 赋值，等待 Main 线程的数据</span>\n          <span class=\"token comment\">// 当 Main 线程传递新数据之后，调用这里的 onUpdate 函数，将 data 传入</span>\n          <span class=\"token comment\">// 接下来通过 FileReader 读取数据，转化成 Uint8Array，放入 Stream 中</span>\n          <span class=\"token comment\">// 在清除 onUpdate 函数，等待下一次 Pull</span>\n          streamInfo<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onUpdate</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">data<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">const</span> reader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileReader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            reader<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onload</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> target <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n              <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>streamInfo<span class=\"token punctuation\">.</span>stream<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                controller<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint8Array</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                streamInfo<span class=\"token punctuation\">.</span>onUpdate <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            reader<span class=\"token punctuation\">.</span><span class=\"token function\">readAsArrayBuffer</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>从 Main 获取数据并更新给 Stream 的代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">self<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onmessage</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> ports <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> event<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>portA <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> portB <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ports<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 根据消息类型，选择创建一个新的 stream 或是往一个已经创建的 stream 中写入数据</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'create'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">getStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">stream</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        streamInfo<span class=\"token punctuation\">[</span>data<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n          filesize<span class=\"token punctuation\">:</span> data<span class=\"token punctuation\">.</span>filesize<span class=\"token punctuation\">,</span>\n          filename<span class=\"token punctuation\">:</span> data<span class=\"token punctuation\">.</span>filename<span class=\"token punctuation\">,</span>\n          stream\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'insert'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      portB<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onmessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> chunk <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>streamInfo<span class=\"token punctuation\">[</span>data<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>onUpdate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          streamInfo<span class=\"token punctuation\">[</span>data<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">onUpdate</span><span class=\"token punctuation\">(</span>chunk<span class=\"token punctuation\">,</span> resolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 等待 onUpdate API 创建...</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">waitUntil</span><span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><a href=\"https://www.myairbridge.com/en/\">MyAirBridge</a> 网站使用了类似上面提到的技术来下载中的文件内容。Service Worker 的代码参考<a href=\"https://www.myairbridge.com/media/js_compiled/sw-download-10bfedd.js\">这里</a>。</p>","frontmatter":{"date":"2019-09-16","title":"Download Chunk via ServiceWorker","category":"JavaScript"}}},{"node":{"id":"4728f0b5-54c6-5426-bf7a-4f6ed51ae6b6","html":"<p>在 Web 环境中，一般对内容的存储都是依托于 Cookie 或是 LocalStorage 进行的（个别会使用 IndexDB）。其实，在早些时候，Web 曾推出过一个 FileSystem 的标准（已经废弃），用于将数据直接存储到本地的沙盒环境中，方便日后的使用。这个 API 目前只有 Chrome 进行了实现。</p>\n<p><a href=\"https://www.html5rocks.com/en/tutorials/file/filesystem/\">这篇文章</a> 针对 FileSystem API 做了详细的介绍。<a href=\"https://github.com/summera/chromestore.js\">这个 GitHub 仓库</a> 则在 FileSystem 原生 API 的基础上，进行了二次封装。（注：第一个链接给出的文章，部分代码有误，可能无法正常运行。实际使用过程中，可以参考第二个链接给出的 GitHub 仓库中的相关代码进行调整）</p>\n<p>假设，需要实现一个分片的文件下载功能，即文件被服务器分割成很多块，通过 JavaScript 依次下载这些内容，再在本地拼接后提交给用户。这里，考虑到文件可能非常大，如果只是存储在内存中，一旦用户刷新页面或是遇到其他问题，已经下载的内容就都失效了，只能重新再来一次。这种情况下，可以考虑使用 FileSystem API 将分片的文件内容下载后先存放在本地的沙盒文件中，等到全部下载完成之后，再将拼接好的内容提交给用户。</p>\n<p>下面给出一个实例代码，用以介绍 FileSystem API 的可能使用方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/**\n * 实际中 Chrome 给出的 API 只用 window.webkitRequestFileSystem\n */</span>\n<span class=\"token keyword\">const</span> requestFileSystem <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>requestFileSystem <span class=\"token operator\">||</span>\n  window<span class=\"token punctuation\">.</span>webkitRequestFileSystem<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 下载 Link 并保存文件为 filename\n * 只是示例代码，实际的可行方案请参考 file-saver 的实现\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">download</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">link<span class=\"token punctuation\">,</span> filename</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  a<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> link<span class=\"token punctuation\">;</span>\n  a<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> <span class=\"token string\">'_blank'</span><span class=\"token punctuation\">;</span>\n  a<span class=\"token punctuation\">.</span>download <span class=\"token operator\">=</span> filename<span class=\"token punctuation\">;</span>\n  a<span class=\"token punctuation\">.</span><span class=\"token function\">click</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">blob<span class=\"token punctuation\">,</span> filename</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">errorHandler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fs</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/**\n     * 获取名为 filename 的文件，{ create: true } 表示如果文件不存在，就创建一个\n     * fileEntry 中包含的 API 可以用于对这个文件进行操作\n     */</span>\n    fs<span class=\"token punctuation\">.</span>root<span class=\"token punctuation\">.</span><span class=\"token function\">getFile</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> create<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">fileEntry</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      fileEntry<span class=\"token punctuation\">.</span><span class=\"token function\">createWriter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">writer</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">/**\n         * 指定文件的写入位置在当前文件内容的末尾\n         */</span>\n        writer<span class=\"token punctuation\">.</span><span class=\"token function\">seek</span><span class=\"token punctuation\">(</span>writer<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        writer<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onwriteend</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">/**\n           * FileSystem 中的文件，可以通过类似如下的 Link 获取到：\n           * filesystem:https://xxx.com/persistent/filename\n           * 具体的 URL 地址通过 `fileEntry.toURL()` 获取\n           */</span>\n          <span class=\"token keyword\">const</span> url <span class=\"token operator\">=</span> fileEntry<span class=\"token punctuation\">.</span><span class=\"token function\">toURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">download</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        writer<span class=\"token punctuation\">.</span>onerror <span class=\"token operator\">=</span> console<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">;</span>\n        writer<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>blob<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> errorHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> errorHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">/**\n   * 对于 PERSISTENT 存储的文件，需要事先通过浏览器询问权限\n   * 声明需要使用的大小为 blob.size\n   * 第二个参数是 success callback，在成功后调用，可以在这里进行文件读写\n   * 第三个参数是 error callback，用于处理报错\n   */</span>\n  navigator<span class=\"token punctuation\">.</span>webkitPersistentStorage<span class=\"token punctuation\">.</span><span class=\"token function\">requestQuota</span><span class=\"token punctuation\">(</span>\n    blob<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">,</span>\n    <span class=\"token parameter\">grantedBytes</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">/**\n       * 以 PERSISTENT 的方式，写入 grantedBytes 这么多的内容\n       * 允许写入会执行 handler，否则会执行 errorHandler\n       */</span>\n      <span class=\"token function\">requestFileSystem</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span><span class=\"token constant\">PERSISTENT</span><span class=\"token punctuation\">,</span> grantedBytes<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">,</span> errorHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    console<span class=\"token punctuation\">.</span>error\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * 示例代码的调用，将 hello world 写入到 output.txt 文件中\n */</span>\n<span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Blob</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'hello world'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> type<span class=\"token punctuation\">:</span> <span class=\"token string\">'text/plain'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'output.txt'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>上面这个例子，展示了如何将 Blob / File 写入到本地沙盒的文件中（例子中写入到了 <code class=\"language-text\">output.txt</code> 文件内）。有几点需要注意：</p>\n<ol>\n<li>文件是写入到沙盒环境中的，因而虽然 <code class=\"language-text\">fileEntry.fullPath</code> 的值是 <code class=\"language-text\">/output.txt</code>，并不代表真的可以在根目录下找到 output.txt 文件</li>\n<li><code class=\"language-text\">window.PERSISTENT</code> 和 <code class=\"language-text\">window.TEMPORARY</code> 是两种可能的存储方式。如果是 <code class=\"language-text\">PERSISTENT</code> 的，那么需要用户授权（也就是 <code class=\"language-text\">requestQuota</code> 做的事情）且清理需要程序或用户手动执行；如果是 <code class=\"language-text\">TEMPORARY</code> 类型的存储方式，那么浏览器可能会在某些情况下自动清理文件（比如，当空间不够的时候）</li>\n<li>通过 <code class=\"language-text\">fileEntry.toURL</code> API 可以拿到当前文件存储对应的 URL 地址，进而可以通过常规手段将这个内容下载到本地</li>\n<li>代码中的 <code class=\"language-text\">errorHandler</code> 函数写的比较粗糙，更丰富的 Error Handler 写法，可以参考 <a href=\"https://github.com/summera/chromestore.js/blob/e0981728534a28ce0a2cf80ed54d9f9f90279943/chromestore.js#L16\">chromestore.js</a> 中的代码</li>\n</ol>\n<p><a href=\"https://www.myairbridge.com/en/\">MyAirBridge</a> 网站可能使用了类似上面提到的技术来存储下载中的文件内容。</p>","frontmatter":{"date":"2019-09-12","title":"Save file in Chrome","category":"Chrome"}}},{"node":{"id":"d4408543-25fa-5b4e-87b3-b44c3a3b0228","html":"<p>针对某些语言（如<a href=\"https://zh.wikipedia.org/wiki/%E9%98%BF%E6%8B%89%E4%BC%AF%E6%96%87%E5%AD%97\">阿拉伯文字</a>或<a href=\"https://zh.wikipedia.org/wiki/%E5%B8%8C%E4%BC%AF%E6%9D%A5%E5%AD%97%E6%AF%8D\">希伯来文字</a>），文字的排列顺序是从右往左，而不是一般的从左往右排列。因此，如果有两种语言同时出现在一个文档中，那么就有可能一个段落，同时有从左往右书写的文字以及从右往左书写的文字。这种两类文字混排的情况，就是双向文稿（Bidirectional Text）。</p>\n<p>针对这种情况，HTML 提供了一个特殊的元素 <code class=\"language-text\">bdo</code>，用于处理文档中特殊的文字流排列。这里 <code class=\"language-text\">bdo</code> 的全称是 <strong>B</strong>i<strong>d</strong>irectional Text <strong>O</strong>verride。举例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n  This is Text Left to Right\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bdo</span> <span class=\"token attr-name\">dir</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>rtl<span class=\"token punctuation\">\"</span></span><span class=\"token style-attr language-css\"><span class=\"token attr-name\"> <span class=\"token attr-name\">style</span></span><span class=\"token punctuation\">=\"</span><span class=\"token attr-value\"><span class=\"token property\">color</span><span class=\"token punctuation\">:</span>red</span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Right to Left part<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bdo</span><span class=\"token punctuation\">></span></span>.\n  Rest of the world.\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>展示效果如下：</p>\n<p>\n  This is Text Left to Right\n  <bdo dir=\"rtl\" style=\"color:red\">Right to Left part</bdo>.\n  Rest of the world.\n</p>\n<p><code class=\"language-text\">dir</code> 这个属性，可以用于设置当前文字应该显示的方向，可用的属性包括 <code class=\"language-text\">ltr</code>，<code class=\"language-text\">rtl</code> 和 <code class=\"language-text\">auto</code> 三种。需要注意的是，<code class=\"language-text\">dir</code> 这个参数，是针对 <code class=\"language-text\">bdo</code> 元素的，如果写在其他元素上，并不能起到同样的效果。比如，<code class=\"language-text\">&lt;span dir=&quot;rtl&quot;&gt;Hi&lt;/span&gt;</code> 并不会让 <code class=\"language-text\">Hi</code> 显示为 <code class=\"language-text\">iH</code>。</p>\n<p>更多内容，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo\">MDN</a></p>","frontmatter":{"date":"2019-09-11","title":"BDO Element","category":"HTML"}}},{"node":{"id":"f7451aff-6ab3-5bdd-8b2b-72f907953d51","html":"<p>JavaScript 提供了 copy 事件，可以针对一般的复制动作进行一些额外的操作。比如，一些网站出于版本的考虑，可能会禁止拷贝；或者，一些网站允许拷贝，但是会希望在拷贝的内容后面加上一些版权的声明。这些操作，都可以通过 copy 事件进行处理。</p>\n<p>举例来说，如果希望禁止网站上内容的拷贝，可以写：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'copy'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">preventDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在上面的代码中，通过 <code class=\"language-text\">event.preventDefault</code> API 的调用，可以组织浏览器默认的复制行为。这样，即使用户进行了复制，实际上剪贴板也不会被更新。</p>\n<p>第二个例子，假设希望在复制的内容后面加上额外的数据，可以写：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'copy'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> selection <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getSelection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> text <span class=\"token operator\">=</span> selection<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  event<span class=\"token punctuation\">.</span>clipboardData<span class=\"token punctuation\">.</span><span class=\"token function\">setData</span><span class=\"token punctuation\">(</span><span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">,</span> text <span class=\"token operator\">+</span> <span class=\"token string\">'\\nExtra Text at Bottom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">preventDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>需要注意几点：</p>\n<ol>\n<li><code class=\"language-text\">setData</code> 的第一个参数是数据的格式，支持的类型可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/types\">MDN</a>，主要就是 <a href=\"https://en.wikipedia.org/wiki/MIME\">MIME</a> 类型，一般纯文本可以使用 <code class=\"language-text\">text/plain</code></li>\n<li>在调用 <code class=\"language-text\">setData</code> 之后，需要调用 <code class=\"language-text\">event.preventDefault</code> 才能保证设置成功，否则最终复制出来的依然是原始的文案</li>\n</ol>\n<p>最后，需要说明的一点是：出于测试或者其他目的，JavaScript 也支持创建一个 ClipboardEvent 并发送给监听的元素，如：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'copy'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'copy event triggered'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  event<span class=\"token punctuation\">.</span>clipboardData<span class=\"token punctuation\">.</span><span class=\"token function\">setData</span><span class=\"token punctuation\">(</span><span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'hello world'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">preventDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> event <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClipboardEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">'copy'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> clipboardData<span class=\"token punctuation\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DataTransfer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">dispatchEvent</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>那么，回调函数可以正常执行（Console 可以看到输出），但是 event 内尝试设置 Clipboard 的数据并不会成功。</p>\n<p>总体上来说，浏览器端提供的 Copy 事件，只能获取/修改浏览器内发生的剪贴板复制操作；对于用户本身剪贴板操作内有的数据是无法读取的，在非用户触发的情况下，剪贴板的数据也是无法直接被修改的。</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent\">延伸阅读</a>。</p>","frontmatter":{"date":"2019-09-10","title":"Clipboard Event","category":"JavaScript"}}},{"node":{"id":"f6537ed2-3963-51f7-ab53-09216b37cac3","html":"<p>Cypress 没有提供原生的上传文件支持，如果需要在 E2E 测试中进行文件上传的测试工作，最简单的方式就是自己写一个自定义的 Command。参考代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">Cypress<span class=\"token punctuation\">.</span>Commands<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'uploadFile'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> prevSubject<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span>subject<span class=\"token punctuation\">,</span> fixtureFileName<span class=\"token punctuation\">,</span> mimeType <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> cy<span class=\"token punctuation\">.</span><span class=\"token function\">fixture</span><span class=\"token punctuation\">(</span>fixtureFileName<span class=\"token punctuation\">,</span> <span class=\"token string\">'base64'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>Cypress<span class=\"token punctuation\">.</span>Blob<span class=\"token punctuation\">.</span>base64StringToBlob<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">blob</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">const</span> el <span class=\"token operator\">=</span> subject<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">const</span> nameSegments <span class=\"token operator\">=</span> fixtureFileName<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> nameSegments<span class=\"token punctuation\">[</span>nameSegments<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">const</span> testFile <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>blob<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> type<span class=\"token punctuation\">:</span> mimeType <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">const</span> dataTransfer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DataTransfer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          dataTransfer<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>testFile<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n          <span class=\"token keyword\">const</span> setter <span class=\"token operator\">=</span>\n            Object<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertyDescriptor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HTMLInputElement</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">,</span> <span class=\"token string\">'files'</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">.</span>set<span class=\"token punctuation\">;</span>\n          <span class=\"token function\">setter</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> dataTransfer<span class=\"token punctuation\">.</span>files<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n          <span class=\"token keyword\">const</span> event <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Event</span><span class=\"token punctuation\">(</span><span class=\"token string\">'change'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> bubbles<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          el<span class=\"token punctuation\">.</span><span class=\"token function\">dispatchEvent</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">return</span> subject<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>代码的解释如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">cy<span class=\"token punctuation\">.</span><span class=\"token function\">fixture</span><span class=\"token punctuation\">(</span>fixtureFileName<span class=\"token punctuation\">,</span> <span class=\"token string\">'base64'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><a href=\"https://docs.cypress.io/api/commands/fixture.html#Syntax\">fixture</a> 是 Cypress 提供的原生 API，可以读取 <code class=\"language-text\">cypress/fixture</code> 目录下的指定文件（文件名为 <code class=\"language-text\">fixtureFileName</code>）。上面这个 API 指定了文件需要以 Base64 的方式读取出来。</p>\n<p><code class=\"language-text\">Cypress.Blob.base64StringToBlob</code> 这一步顾名思义，就是将 Base64 字符串转化成对应的 Blob 类型。</p>\n<p>剩下的代码，就是用 JavaScript 的方式模拟一个文件上传事件。其中，需要先将文件从 Blob 转换成 File（这里涉及到可能的 mime type 检查）；然后，创建一个 DataTransfer 对象，把文件放进去，再赋值给 input（这里需要说明的是，React 组件会对 input 的属性做一层 proxy，因此直接使用 <code class=\"language-text\">input.files = dataTransfer.files</code> 这样的写法，调用的是 React 的方法而不是真正 DOM 的方法。按上面代码中的方法获取到真正的 setter，然后调用可以绕过去）。最后，在创建一个 Change 事件，传递给 input 组件，触发即可。</p>\n<p>当然，简单起见，可以直接使用现成的库：<code class=\"language-text\">cypress-file-upload</code>。GitHub 地址见<a href=\"https://github.com/abramenal/cypress-file-upload\">这里</a>。</p>","frontmatter":{"date":"2019-09-09","title":"Cypress Upload File","category":"Cypress"}}},{"node":{"id":"3e1e3f9f-24b8-5288-b813-dd0ea2b1e2d4","html":"<p>Cypress 默认提供了 <code class=\"language-text\">spec</code> reporter，在 CLI 运行的时候，会将结果输出到 stdout 中。同时，如果使用编程的方法直接调用 <code class=\"language-text\">Cypress.run</code> API，会以 Promise 的方式将运行的结果返回，程序可以从运行结果中，将主要的运行数据给读取出来。然而，不论是哪一种方案，都不能非常直观的将运行结果展示出来。以下介绍如何在 Cypress 中引入 <a href=\"https://adamgruber.github.io/mochawesome/\">Mochawesome</a> reporter，用于生成直观的 HTML 报告。</p>\n<p>需要事先说明的是，虽然 Cypress 是建立在 Mocha 的基础上，且 Mochawesome 是 Mocha 中非常流行的报告生成方案，但是直接使用 Mochawesome 在 Cypress 中生成报表还是有问题的。主要的原因在于，Cypress 调整了测试的行为，自 3.0 版本开始，每一个测试用例（spec）都是单独运行的。因此，原生的 Mochawesome 无法直接生成一个包含所有测试用例的完整报告。为此，需要借助一些额外的工具。</p>\n<p>首先，在项目需要用到 <code class=\"language-text\">mocha</code> 和 <code class=\"language-text\">mochawesome</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">yarn</span> <span class=\"token function\">add</span> mocha mochawesome</code></pre></div>\n<p>另外需要两个额外的包，分别是 <code class=\"language-text\">mochawesome-merge</code> 和 <code class=\"language-text\">mochawesome-report-generator</code>。可以通过 yarn 或 npm 安装到工作目录中，也可以通过 npx 在需要的时候直接使用。这里，<code class=\"language-text\">mochawesome-merge</code> 将用于将所有的测试用例运行结果进行合并的，然后用 <code class=\"language-text\">mochawesome-report-generator</code> 包生成统一的完整报告。</p>\n<p>接下来，\b修改 <code class=\"language-text\">cypress.json</code> 配置文件如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"reporter\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"mochawesome\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"reporterOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"reportDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"cypress/results\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"overwrite\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"html\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"json\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>配置完成，再运行 Cypress，会在 <code class=\"language-text\">cypress/results</code> 目录下生成一批 JSON 文件（如 <code class=\"language-text\">mochawesome.json</code>，<code class=\"language-text\">mochawesome_001.json</code>，……）。</p>\n<p>有了这批生成的 JSON 报告，就可以使用 <code class=\"language-text\">mochawesome-merge</code> 命令，将这些 JSON 文件打包成一个完整的 JSON 报告。CLI 命令如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">npx mochawesome-merge --reportDir cypress/results <span class=\"token operator\">></span> mochawesome.json</code></pre></div>\n<p>生成了完整的 JSON 文件之后，可以通过 <code class=\"language-text\">mochawesome-report-generator</code> 生成需要的 HTML 报告：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">npx mochawesome-report-generator mochawesome.json</code></pre></div>\n<p>当然，如果需要以编程的方式来执行上面的生成报告过程，可以参考下面的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> cypress <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'cypress'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> merge <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mochawesome-merge'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> generator <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mochawesome-report-generator'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">generate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">await</span> cypress<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> report <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> reportDir<span class=\"token punctuation\">:</span> <span class=\"token string\">'cypress/results'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> htmlReports <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> generator<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>report<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    reportFilename<span class=\"token punctuation\">:</span> <span class=\"token string\">'report.html'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// cdn 的命令可以在生成 HTML 报告的时候不额外生成 JavaScript/CSS 文件</span>\n    <span class=\"token comment\">// 这些静态文件会走 CDN (unpkg)</span>\n    <span class=\"token comment\">// 这样，只需要保存一个 HTML 文件就可以了，方便存储</span>\n    cdn<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// report 就是 HTML 报告文件生成的路径</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>report<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> htmlReports<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">generate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>更多的参数使用可以参考项目的源代码。</p>\n<p>需要注意的一点是，生成 Report 之前需要确认 <code class=\"language-text\">cypress/results</code> 目录是否是干净的空目录。如果目录中仍然包含上一次运行的结果，那么最终合并报告的时候，两次运行的结果会叠加在一起，最终导致报告中包含多次运行的内容。一般在 Docker 中运行的话不会有这个问题，但是在本地跑的时候需要注意清理工作。</p>","frontmatter":{"date":"2019-09-08","title":"cypress reporter","category":"Cypress"}}},{"node":{"id":"d7305a3b-e734-5c22-8369-4d8f478a7346","html":"<p>Docker 的运行环境因为一般只安装了运行程序需要的最小依赖集，因而存在各种限制。有时候需要查看日志，或是分析一些数据，直接在 Docker 中查看日志文件并不是非常方便。</p>\n<p>这个时候，可以通过 <code class=\"language-text\">docker cp</code> 命令将文件从 Docker 中拷贝出来，在外部环境中通过合适的工具直接分析。</p>\n<p><code class=\"language-text\">docker cp</code> 的使用步骤如下：</p>\n<ol>\n<li><code class=\"language-text\">docker container ls</code> 查看当前正在运行的 container，找到其中的 Container ID</li>\n<li>运行 <code class=\"language-text\">docker cp &lt;containerId&gt;:/path/in/container /host/path</code> 将数据拷贝出来</li>\n</ol>","frontmatter":{"date":"2019-09-06","title":"Copy out of Docker","category":"Docker"}}},{"node":{"id":"03a25784-6757-5c28-9084-94b5270eb170","html":"<p>前端项目，总免不了写一些操作 URL 中 query string 的 API 代码，比如读取当前 URL 中的 query 数据，或是根据一个 Object 对象拼接出一个 query string，等等。</p>\n<p>其实，现代浏览器中已经提供了 <code class=\"language-text\">URLSearchParams</code> 类，可以大大简化这部分的操作，也无需再自己维护一个 <code class=\"language-text\">qs</code> 或是类似的包了。</p>\n<p>以下介绍如何通过 <code class=\"language-text\">URLSearchParams</code> 实现 <code class=\"language-text\">qs.stringify</code> 和 <code class=\"language-text\">qs.parse</code> API 的方法：</p>\n<p><code class=\"language-text\">qs.parse</code> 的方法比较简单，只需要将字符串传递给 <code class=\"language-text\">URLSearchParams</code> 并创建实例就可以了，实例本身自带了 iterator，也提供 <code class=\"language-text\">get</code>，<code class=\"language-text\">keys</code> 等 API 能很方便的获取需要的数据。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> searchParams <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">URLSearchParams</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">.</span>search<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> param <span class=\"token keyword\">of</span> searchParams<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> param<span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>需要注意的一点是，不论参数传入的字符串是否以 <code class=\"language-text\">?</code> 字符开头，<code class=\"language-text\">URLSearchParams</code> 都默认可以正确处理，不需要像 <code class=\"language-text\">qs</code> 包一样显示的指明给定的字符串是否有 <code class=\"language-text\">?</code> 开头（<code class=\"language-text\">ignoreQueryPrefix</code>）。</p>\n<p>要实现 <code class=\"language-text\">qs.stringify</code> 的功能也不难，<code class=\"language-text\">URLSearchParams</code> 的构造器支持传入一个数组或一个对象，也提供了 <code class=\"language-text\">append</code> API 可以将 key value 一组一组的加入到对象中，最后只要使用 <code class=\"language-text\">toString</code> 拼接出一个完整的字符串就可以了：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// result in: `a=b`</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">URLSearchParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token string\">'b'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// result in: `c=d&amp;e=f`</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">URLSearchParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'d'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'e'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'f'</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>注意，<code class=\"language-text\">toString</code> 方法得到的字符串，最开头并没有带上 <code class=\"language-text\">?</code> 字符，如果有需要的话，可以自行加上。</p>\n<p>综上，下面的等式是成立的（假定 <code class=\"language-text\">location.search</code> 不是一个空字符串）：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">location<span class=\"token punctuation\">.</span>search <span class=\"token operator\">===</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">?</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">URLSearchParams</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">.</span>search<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span></code></pre></div>\n<p>当然，<code class=\"language-text\">URLSearchParams</code> 在某些场景下还是不能替换 <code class=\"language-text\">qs</code> 之类的库，比如：</p>\n<ol>\n<li>项目需要支持老浏览器，如 IE 时。<code class=\"language-text\">URLSearchParams</code> 的浏览器支持情况见：<a href=\"https://caniuse.com/#search=URLSearchParams\">CanIUse</a>，总体来说，现代的浏览器都已经支持了，但是 IE 完全没有。</li>\n<li>需要使用一些比较冷门的解析功能时，如 <code class=\"language-text\">qs</code> 提供了很多复杂的解析方案（详情见<a href=\"https://www.npmjs.com/package/qs\">文档</a>）</li>\n</ol>\n<p>但总体来说，绝大部分的应用场景下，<code class=\"language-text\">URLSearchParams</code> 都可以轻松应对，不需要额外的库进行志愿了。</p>\n<p>更多关于 <code class=\"language-text\">URLSearchParams</code> 的介绍，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\">MDN</a>，<a href=\"https://developers.google.com/web/updates/2016/01/urlsearchparams?hl=en\">Easy URL Manipulation with URLSearchParams</a> 或 <a href=\"https://url.spec.whatwg.org/#urlsearchparams\">WHATWG Spec</a>。</p>","frontmatter":{"date":"2019-09-05","title":"URLSearchParams","category":"JavaScript"}}},{"node":{"id":"97d07229-1f07-5e5a-9835-184c70c8c6a7","html":"<p>CSS 中有一些属性选择器，不常见，但是偶尔有一些小众的需求，实现起来会很方便。特别是在进行 Cypress 开发的时候，直接使用 JavaScript 查找元素比较困难，但是有了这些属性选择器，就可以很方便的通过 jQuery 的 API 进行元素的定位了。</p>\n<p>属性选择器和一些可能的应用场景，列举如下：</p>\n<section><h2>attr</h2><p>表示带有以 <code class=\"language-text\">attr</code> 命名的属性元素。这个选择器不关心属性具体的值，只要有，就会被选中。一些常见的应用场景包括：</p><ul>\n<li>选择一些没有值的属性，比如 <code class=\"language-text\">&lt;input disabled /&gt;</code> 可以通过 <code class=\"language-text\">input[disabled]</code> 进行选择；</li>\n<li>选择一些带有属性的元素，属性具体的值并不关心。这种情况中，带有某种属性往往表示这类元素同属于一个类型组件，如一组列表中的每个元素，都会有一个子节点上带有 <code class=\"language-text\">title</code> 属性以显示 tooltip，此时就可以通过类似 <code class=\"language-text\">ul li [title]</code> 的方式，将这些文字都选出来，或是进行进一步的选择。</li>\n</ul></section>\n<section><h2>attr=value</h2><p>表示带有以 <code class=\"language-text\">attr</code> 命名的属性，并且该属性的值是 <code class=\"language-text\">value</code>。这个的应用场景比较常见，一般的属性选择都会使用这个方案。值得注意的一点是，由于 CSS 选择器权重的关系，以下两个 CSS 定义是有不同优先级的：</p><div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">#id</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">[id=id]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> blue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>最终的元素 <code class=\"language-text\">&lt;p id=&quot;id&quot;&gt;Hello World&lt;/p&gt;</code> 显示颜色是红色，而不是蓝色。因为属性选择器的优先级比 id 选择器要低，即使两者表达的意思是一样的。</p></section>\n<section><h2>attr^=prefix</h2><p>这个选择器可以将所有以 <code class=\"language-text\">prefix</code> 开头的 <code class=\"language-text\">attr</code> 属性所在的元素都选出来。<code class=\"language-text\">^</code> 表示开头，这一点和正则表达式中的表述语义是类似的。可以设想这样一个应用场景：</p><p>在某个页面上，可能要根据一组数据显示对应的表单数据。因为每个表单中的输入项都需要一个 label + input 的组合，因而每个 input 可能需要给一个独一无二的 ID（方便 label 上加上 <code class=\"language-text\">for</code> 以绑定两者）。这时候，一个简单的做法，是给每一个表单中固定的输入项，取一个固定的前缀，再加上这个数据本身的 id 值，最终生成一个独一无二的 ID，防止重复。比如，数据 <code class=\"language-text\">{ id: 1, name: &#39;John&#39; }</code> 生成的名字 input 可能为：<code class=\"language-text\">&lt;input id=&quot;user-name-1&quot; /&gt;</code>。</p><p>针对这种情况，如果希望一次性选出所有这些 input，就可以使用属性选择器：<code class=\"language-text\">[id^=user-name]</code>。</p></section>\n<section><h2>attr|=prefix</h2><p>上面的这个例子，也可以用这个属性选择器来进行改写：<code class=\"language-text\">[id|=user-name]</code>。两者都可以定义属性的前缀用于查找元素，但是区别在于，<code class=\"language-text\">|=</code> 的选择器规定的前缀之后一定跟着一个 <code class=\"language-text\">-</code> 字符。因此，<code class=\"language-text\">[id|=user-name]</code> 可以选出 <code class=\"language-text\">&lt;input id=&quot;user-name-1&quot; /&gt;</code> 但是不能选出 <code class=\"language-text\">&lt;input id=&quot;user-name_1&quot; /&gt;</code>。这一点是和上面这个选择器最大的不同。当然，这个选择器最大的应用场景其实还是在选择 <code class=\"language-text\">lang</code> 上，比如将当前页面中所有英文的部分选择出来：<code class=\"language-text\">[lang|=en]</code>，此时，无论是 <code class=\"language-text\">&lt;p lang=&quot;en-US&quot;&gt;Color&lt;/p&gt;</code> 还是 <code class=\"language-text\">&lt;p lang=&quot;en-GB&quot;&gt;Colour&lt;/p&gt;</code> 都可以被正确的选择出来。</p></section>\n<section><h2>attr$=suffix</h2><p>这个选择器可以将所有以 <code class=\"language-text\">suffix</code> 结尾的 <code class=\"language-text\">attr</code> 属性所在的元素都选出来。<code class=\"language-text\">$</code> 表示结尾，这一点和正则表达式中的表述语义是类似的。一个可能的例子是：在 Ant Design 中，<a href=\"https://ant.design/components/icon/\">Icon</a> 组件会根据当前网页的语言，显示 <code class=\"language-text\">aria-label=&quot;icon: right&quot;</code> 或 <code class=\"language-text\">aria-label=&quot;图标: right&quot;</code>。如果要根据当前选择的语言去分别创建选择器，会有一些麻烦，这时候可以考虑直接使用 <code class=\"language-text\">[aria-label$=right]</code> 来进行选择。</p></section>\n<section><h2>attr*=keyword</h2><p>这个选择器可以将所有 <code class=\"language-text\">attr</code> 中带有 <code class=\"language-text\">keyword</code> 字段的元素都选出来。暂时没有遇到什么实际的应用场景，但是可以考虑用作属性的文案检查器。比如，原先的产品名字叫 AAA，但是后期业务调整，名字改成了 BBB，那么下面的 CSS 就可以将所有还没有改过来的元素都标注出来：</p><div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">[class*=AAA], [aria-label*=AAA]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div></section>\n<section><h2>参考文档</h2><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\">MDN</a></p></section>","frontmatter":{"date":"2019-09-04","title":"CSS Attribute Selector","category":"CSS"}}},{"node":{"id":"c1119f9b-baa9-5f9c-924d-331dee578810","html":"<p>在编写 Bash 脚本的过程中，难免会遇到一些单纯用 Linux 命令很难实现的功能，比如，希望将一个文件的内容作为 JSON 的一个字段，并通过 <code class=\"language-text\">curl</code> 将这个 JSON 数据发送给服务器。如果单纯使用 Linux 的命令来拼接这个 JSON 字符串，在转意上会遇到很大的问题。但其实同样的需求，在 JavaScript 中可以通过一行命令完成：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> text<span class=\"token punctuation\">:</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>对于这样的情况，如果正好环境中有 Node.js（比如基于 Node 的 Docker 环境），就可以很方便的通过直接调用 Node 来处理这部分的需求。</p>\n<p>需要用到 <code class=\"language-text\">node.js</code> 内建的参数 <code class=\"language-text\">-e</code> 或 <code class=\"language-text\">-p</code>。</p>\n<p>对于 <code class=\"language-text\">-e</code> 这个参数（或 <code class=\"language-text\">--eval</code>），Node 会执行参数后面的字符串。类似于 <code class=\"language-text\">node file.js</code> 可以让 Node.js 执行 file.js 这个文件，<code class=\"language-text\">node -e &quot;script&quot;</code> 可以让 Node.js 执行 <code class=\"language-text\">script</code> 这串语句。需要注意的几点：</p>\n<ol>\n<li>Windows 的 CMD 不能使用单引号，只能使用双引号；Powershell 的的话，两者都是支持的；</li>\n<li><code class=\"language-text\">-e</code> 指令并不会将执行的结果输出到终端，因而如果需要 Bash 中能够用变量保存运行结果的话，需要额外使用 <code class=\"language-text\">console.log</code> 将结果输出到 stdout，然后再由 Bash 传递给需要赋值的变量。</li>\n</ol>\n<p>综上所述，上面这个 JSON 序列化的需求，就可以写成下面的这种形式：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">node -e <span class=\"token string\">\"console.log(JSON.stringify({ text: fs.readFileSync(file, 'utf8') }))\"</span></code></pre></div>\n<p>显然，对于需要赋值的情况，每次都加上 console.log 去输出结果比较的繁琐。Node.js 为此提供了另外一个可用的参数 <code class=\"language-text\">-p</code>。这个参数的表现形式和 <code class=\"language-text\">-e</code> 几乎是一样的，唯一的区别是，<code class=\"language-text\">-p</code> 会将结果默认输出到 stdout 中，不需要额外套一层 console.log 来完成这个操作。<code class=\"language-text\">-p</code> 也可以写作 <code class=\"language-text\">--print</code>。</p>\n<p>下面用一个例子来说明两者的区别：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\"><span class=\"token variable\">$(</span>node -e <span class=\"token string\">\"true\"</span><span class=\"token variable\">)</span></span></code></pre></div>\n<p>上面这个命令运行的结果将输出空字符串；而下面这个命令，则会在终端输出 <code class=\"language-text\">true</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\"><span class=\"token variable\">$(</span>node -p <span class=\"token string\">\"true\"</span><span class=\"token variable\">)</span></span></code></pre></div>\n<p>如此一来，上面的例子可以进一步转化为：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">node -p <span class=\"token string\">\"JSON.stringify({ text: fs.readFileSync(file, 'utf8') })\"</span></code></pre></div>\n<p>配合 <code class=\"language-text\">curl</code> 最终的命令大体上如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -X POST <span class=\"token punctuation\">\\</span>\n  -H <span class=\"token string\">\"Content-Type: application/json\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token variable\">$URL</span> <span class=\"token punctuation\">\\</span>\n  --data-binary <span class=\"token punctuation\">\\</span>\n    <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>node -p 'JSON.stringify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>text:fs.readFileSync<span class=\"token punctuation\">(</span><span class=\"token string\">\"filepath\"</span>,<span class=\"token string\">\"utf8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token variable\">)</span></span>')\"</span></code></pre></div>","frontmatter":{"date":"2019-09-03","title":"Eval Script via Nodejs","category":"Node.js"}}},{"node":{"id":"f1d289ff-b50b-514b-8f84-9dd651b7627f","html":"<p>根据 TSLint 官方给出的建议，TypeScript 项目的代码，现在也推荐使用 ESLint 来进行代码规范的检查。</p>\n<p>在具体使用的时候，需要在 <code class=\"language-text\">.eslintrc</code> 中增加如下部分的设置：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"parser\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"@typescript-eslint/parser\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"@typescript-eslint\"</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"parserOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"ecmaVersion\"</span><span class=\"token operator\">:</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"sourceType\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"module\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"project\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./tsconfig.json\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"ecmaFeatures\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"jsx\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>其中，需要用到 <code class=\"language-text\">typescript-eslint</code> 这个库来帮助 ESLint 解析代码（<a href=\"https://github.com/typescript-eslint/typescript-eslint\">GitHub</a>）。</p>\n<p>然而，在实际使用 ESLint 来检查 TypeScript 代码的时候，需要额外注意一个细节：</p>\n<p>根据<a href=\"https://github.com/typescript-eslint/typescript-eslint/issues/355#issuecomment-473353680\">这里</a>给出的解释，ESLint 默认情况下并不会检查非 <code class=\"language-text\">.js</code> 和 <code class=\"language-text\">.jsx</code> 结尾的文件。也就是说，如果 <code class=\"language-text\">src</code> 目录下有以下几个文件：<code class=\"language-text\">src/index.js</code>，<code class=\"language-text\">src/app.tsx</code>，<code class=\"language-text\">src/utils.ts</code>，那么在运行命令 <code class=\"language-text\">eslint src</code> 的时候，只有 <code class=\"language-text\">src/index.js</code> 会被检查，剩下的两个会直接被忽略。</p>\n<p>需要检查 TypeScript 的代码，需要手动在调用 <code class=\"language-text\">eslint</code> 命令行的时候加上 <code class=\"language-text\">--ext</code> 参数，如：<code class=\"language-text\">--ext js,jsx,ts,tsx</code>。</p>\n<p>当然，如果给 ESLint 手动指定需要检查的文件，或是通过 <code class=\"language-text\">lint-staged</code> 工具在 Git 签入的时候对 TypeScript 文件进行检查，这些情况下都是不需要额外指定 <code class=\"language-text\">--ext</code> 参数的，ESLint 可以正确处理 TypeScript 的代码。</p>","frontmatter":{"date":"2019-09-02","title":"ESlint for TypeScript","category":"Tool"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"startInMonth":"2019-09-01","endInMonth":"2019-09-31","time":"2019-09","previous":"2019-08","next":"2019-10"}}}