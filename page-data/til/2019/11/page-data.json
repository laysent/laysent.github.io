{"componentChunkName":"component---src-templates-til-per-month-js","path":"/til/2019/11","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"bdf22101-4989-5baa-9054-a528719b9619","html":"<p><a href=\"https://github.com/tc39/proposal-nullish-coalescing\">Nullish Coalescing</a> 当前在 TC39 Stage 3 的阶段，TypeScript 在 <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing\">3.7</a> 中也将这一功能引入了进来。（<a href=\"http://dict.cn/Coalesce\">Coalesce</a> 是“合并；联合；接合”的意思）</p>\n<p>Nullish Coalescing 的简单用法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>当 <code class=\"language-text\">foo</code> 的值是 <code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code> 的时候，<code class=\"language-text\">x</code> 的值由后面的 <code class=\"language-text\">bar()</code> 决定，否则 <code class=\"language-text\">x</code> 的值就是 <code class=\"language-text\">foo</code> 本身。这一行为，一般会被用于给变量赋初始值。在之前的 JavaScript / TypeScript 中，一般会这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num <span class=\"token operator\">||</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>但是，这样写有一个问题，就是当 <code class=\"language-text\">num</code> 的值是 <code class=\"language-text\">0</code> 的时候，最终的值依然是 <code class=\"language-text\">5</code> 而不是 <code class=\"language-text\">0</code>。这一行为很可能并不是开发者希望的。</p>\n<p>和 Optional Chaining 一样，Nullish Coalescing 只有在原值是 <code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code> 的时候，才进行操作；其他的 falsy 值，都会保持原样，并不会做特殊的处理（根据 <a href=\"https://github.com/tc39/proposal-nullish-coalescing/blob/master/README.md#overview-and-motivation\">Proposal</a> 中的说明，这两个规范将会在“何时处理”上保持一致）。这很大程度上减少了 JavaScript 在类型上导致隐藏问题的可能性。</p>\n<p>需要注意的一点是，这一行为和 JavaScript 中的默认参数是有一点不一样的。上面的代码如果改写成默认参数的形式：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那么，将会在 <code class=\"language-text\">getNumber(null)</code> 的时候产生行为上的分歧。使用 Nullish Coalescing 将会返回 <code class=\"language-text\">5</code>，也就是进行了默认值赋值；而默认参数的方案将会返回 <code class=\"language-text\">null</code>，因为默认参数只有在 <code class=\"language-text\">undefined</code> 的情况下才会进行默认值赋值操作。</p>\n<p>Optional Chaining 和 Nullish Coalescing 可以放在一起操作，确保值不存在的时候，有一个兜底的默认值可以给程序使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>bar<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token string\">'default'</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-11-11","title":"Nullish Coalescing","category":"TypeScript"}}},{"node":{"id":"d7ace064-8159-5fe0-ba4d-0b04683a001d","html":"<p>在 JavaScript 中，新的<a href=\"https://github.com/tc39/proposal-object-rest-spread\">规范</a>定义了 object rest spread 运算符，可以用于对象的解构。</p>\n<p>简单的用法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>除了这种解构同时赋值给新变量的情况，也可以通过解构运算，赋值给一个已有的变量：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">'old'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token string\">'value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里需要注意的一点是，解构加赋值的运算，必须要加上括号。下面的写法会报语法错误：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">'old'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token string\">'value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>会报错的原因是，前面的 <code class=\"language-text\">{ value } =</code>，如果不加上括号，会被当成一般的代码块（Block），而不是一个解构的对象（Object），因此解析语法树的时候，在 <code class=\"language-text\">=</code> 这里就报错了（<code class=\"language-text\">Uncaught SyntaxError: Unexpected token &#39;=&#39;</code>）。注：如果不加最后的 <code class=\"language-text\">;</code>，语法也是正确的。</p>\n<p>更多相关的相关介绍，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring\">MDN</a>。</p>","frontmatter":{"date":"2019-11-07","title":"Object Deconstructing without Declaration","category":"JavaScript"}}},{"node":{"id":"04dc3c68-fa9d-535f-94d9-f7a404f1d2dc","html":"<p>在 TC39 将 <a href=\"https://github.com/tc39/proposal-optional-chaining/\">Optional Chaining</a> 转移到 Stage 3 之后，TypeScript 在 3.7 版本中也带来了对应的 Optional Chaining 功能。总体上，TypeScript 的 Optional Chaining 功能和 JavaScript 的提案是保持一致的。总结来说，就是：</p>\n<blockquote>\n<p>如果属性值是 <code class=\"language-text\">undefined</code> 或者 <code class=\"language-text\">null</code>，就会直接返回 <code class=\"language-text\">undefined</code>，否则会进一步获取真实的属性值。</p>\n</blockquote>\n<p>在 <a href=\"https://www.typescriptlang.org/play/index.html\">TypeScript Playground</a> 中可以尝试一下这个新的功能。以下面这段 TypeScript 为例：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>bar<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>最终会被转译成下面的这段 JavaScript：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> _a<span class=\"token punctuation\">,</span> _b<span class=\"token punctuation\">,</span> _c<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_a <span class=\"token operator\">=</span> foo<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _a <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span>\n  <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">(</span>_b <span class=\"token operator\">=</span> _a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _c <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span>\n    <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span>\n    <span class=\"token function\">_c</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>_b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>几点简单的说明：</p>\n<ol>\n<li>即使值是 <code class=\"language-text\">null</code>，最终返回的结果也会是 <code class=\"language-text\">undefined</code>（上面代码中是 <code class=\"language-text\">void 0</code>，是等价的）；</li>\n<li>只有 <code class=\"language-text\">null</code> 和 <code class=\"language-text\">undefined</code> 的情况会被直接返回。这一点，和之前 <code class=\"language-text\">foo &amp;&amp; foo.bar</code> 这样的写法是有区别的。主要是 JavaScript 对哪些值是 falsy 的判断，范围会比 <code class=\"language-text\">null</code> &#x26; <code class=\"language-text\">undefined</code> 更广，还包括了 <code class=\"language-text\">NaN</code>，<code class=\"language-text\">0</code>，<code class=\"language-text\">false</code> 等；</li>\n<li>Optional Chaining 在函数调用中也是可以用的，写法是 <code class=\"language-text\">xx?.()</code>，如果不存在，函数不会调用，而是直接返回 <code class=\"language-text\">undefined</code>；</li>\n<li>Optional Chaining 也可以使用如下的写法：<code class=\"language-text\">foo?.[0]</code>， <code class=\"language-text\">foo?.[&#39;var-name&#39;]</code> 或 <code class=\"language-text\">foo?.[variableName]</code></li>\n</ol>\n<p>官方的发布介绍文档见<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#optional-chaining\">这里</a>。</p>","frontmatter":{"date":"2019-11-06","title":"Optional Chaining in TypeScript","category":"TypeScript"}}},{"node":{"id":"4c12371e-1261-52ed-8522-aacc2f3a7626","html":"<p><code class=\"language-text\">console.assert</code> API 可以用于判断某个条件是否满足，并在不满足的时候，在 Console 里打印出相关的数据。整体 API 和 <code class=\"language-text\">console.error</code> 比较类似，但是第一个参数是一个判断条件。整个调用，只会在第一个参数是 falsy 值的时候，才会将后面的数据打印出来。打印的方式和 <code class=\"language-text\">console.error</code> 类似，输出的是 error 信息。需要注意的一点是，根据 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Console/assert\">MDN</a> 的描述，在 Node.js 10 版本前，除了输出之外，还会抛出一个 <code class=\"language-text\">AssertionError</code>。这个行为是错误的，console API 不应该影响主流程的代码，Node.js 在 10 修复了问题。</p>\n<p>下面是一段示例代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'before'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'incorrect with error message'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'after'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出的结果是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">before\nincorrect with error message\nafter</code></pre></div>\n<p>其中，<code class=\"language-text\">incorrect with error message</code> 这一条，还会额外输出调用的堆栈信息，方便调试。</p>\n<p>总结来说，在代码中实现类似 Chrome 中 conditional breakpoint，使用 <code class=\"language-text\">console.assert</code> 是一个不错的选择：只在出现问题的时候打印必要的信息，可以尽可能的减少对 Console 输出的污染。</p>","frontmatter":{"date":"2019-11-05","title":"console.assert","category":"JavaScript"}}},{"node":{"id":"df525546-37d6-5170-90fd-2fe8e78bc734","html":"<p><code class=\"language-text\">console.trace</code> API 支持可选参数，输出的效果和 <code class=\"language-text\">console.log</code> / <code class=\"language-text\">console.info</code> 类似。但是除了输出参数指定的内容之外，还会连带将当前的调用堆栈一起输出。可以看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Console/trace\">MDN</a> 中给出的一个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">trace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出的结果类似：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">bar\nfoo\n&lt;anonymous&gt;</code></pre></div>\n<p>其中，<code class=\"language-text\">&lt;anonymous&gt;</code> 是因为 <code class=\"language-text\">foo</code> 函数是在 console 中直接运行的。当然，这个只能在调试阶段进行代码的检查。如果需要在线上环境，对可能出问题的地方收集调用堆栈信息，直接使用 <code class=\"language-text\">console.trace</code> 就不满足需求了。可以转而使用 Error 中的 stack 字段：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> error <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出结果类似：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">Error\n    at bar (&lt;anonymous&gt;:3:19)\n    at foo (&lt;anonymous&gt;:6:3)\n    at &lt;anonymous&gt;:9:1</code></pre></div>","frontmatter":{"date":"2019-11-04","title":"console.trace","category":"JavaScript"}}},{"node":{"id":"0e49e733-98a8-5e79-bcb5-c4ef0b27aaf8","html":"<p>在 Node.js 中，可以通过使用 Performance API 来对 <code class=\"language-text\">require</code> 模块的性能进行检测。这里的 Performance 模块，是 Node.js 根据 <a href=\"https://w3c.github.io/performance-timeline/\">W3C Performance Timeline 规范</a>，实现的一套和 Web 相同的 API 接口集合。一般的时间测量，可以通过 <code class=\"language-text\">Performance.mark</code> 和 <code class=\"language-text\">Performance.measure</code> 的组合来进行，使用的方法大体上和 Web 中一致（但是需要使用 <code class=\"language-text\">PerformanceObserver</code> 来获取测量的结果，这一点和 Web 不太相同，具体可以参考官方的<a href=\"https://nodejs.org/api/perf_hooks.html\">文档</a>）。</p>\n<p>和 Web 不同的是，在 Node.js 的 Performance 模块中，还提供了一个 <a href=\"https://nodejs.org/api/perf_hooks.html#perf_hooks_performance_timerify_fn\">timerify</a> 的接口，可以简便的对一个函数进行封装，从而测量出这个函数的实际调用时间。</p>\n<p>有了这个接口，就可以很容易的测量 Node.js 中加载模块的耗时了。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">,</span>\n  PerformanceObserver\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'perf_hooks'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> mod <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'module'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmod<span class=\"token punctuation\">.</span><span class=\"token class-name\">Module</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>require <span class=\"token operator\">=</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">timerify</span><span class=\"token punctuation\">(</span>mod<span class=\"token punctuation\">.</span><span class=\"token class-name\">Module</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>require<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> obs <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PerformanceObserver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">list</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> entries <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">getEntries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  fs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./profile.json'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>entries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  obs<span class=\"token punctuation\">.</span><span class=\"token function\">disconnect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobs<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  entryTypes<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'function'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Module.require'</span><span class=\"token punctuation\">,</span>\n  buffered<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里有几点可以说明一下：</p>\n<ol>\n<li><code class=\"language-text\">mod.Module.prototype.require</code> 被 <code class=\"language-text\">timerify</code> 之后，所有模块在 <code class=\"language-text\">require</code> 的时候，都会使用被 <code class=\"language-text\">timerify</code> 过的版本；</li>\n<li>PerformanceObserver 的作用是获取 entries 的结果；</li>\n<li><code class=\"language-text\">obs.disconnect</code> 用于解除连接，不再进行后续的接听；</li>\n<li><code class=\"language-text\">obs.observer</code> 设置 <code class=\"language-text\">entryTypes: [&#39;function&#39;]</code>，确保这里 <code class=\"language-text\">timerify</code> 的结果都可以被获取到；</li>\n<li><code class=\"language-text\">obs.observer</code> 中设置 <code class=\"language-text\">buffered: true</code>，确保 observer 的回调函数不会被立刻执行，而是用 <code class=\"language-text\">setImmediate</code> 延迟调用。这样的好处是，一次 <code class=\"language-text\">require</code> 后，该模块的调用时间和该模块内部调用子模块的耗时都会一次性通过回调函数返回。（注：默认这里的值是 <code class=\"language-text\">false</code>，见<a href=\"https://nodejs.org/docs/latest-v10.x/api/perf_hooks.html#perf_hooks_performanceobserver_observe_options\">文档</a>）;</li>\n<li>官方给出的示例，还 <code class=\"language-text\">timerify</code> 了 <code class=\"language-text\">require</code> 函数（见<a href=\"https://nodejs.org/api/perf_hooks.html#perf_hooks_measuring_how_long_it_takes_to_load_dependencies\">这里</a>），这样做会导致当前模块中 <code class=\"language-text\">require</code> 的调用，生成两份 Performance 数据（一份来自 <code class=\"language-text\">require</code>，一份来自 <code class=\"language-text\">Module.require</code>）。出于精简的考虑，上面的示例代码中去掉了对 <code class=\"language-text\">require</code> 函数的 <code class=\"language-text\">timerify</code>。</li>\n</ol>\n<p>在上面的示例代码中，最终得到的结果，存放在了一个 JSON 文件内，大体的格式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"0\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"required-module-name\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Module.require\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"entryType\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"startTime\"</span><span class=\"token operator\">:</span> <span class=\"token number\">7397.399892</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"duration\"</span><span class=\"token operator\">:</span> <span class=\"token number\">112.681678</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>这里，<code class=\"language-text\">0</code> 表示第一个参数的值，对于 <code class=\"language-text\">require</code> 来说就是具体引用的模块的名称/地址；<code class=\"language-text\">name</code> 表示是哪个函数的调用，在示例中就是被 <code class=\"language-text\">timerify</code> 过的 <code class=\"language-text\">Module.require</code> 函数；<code class=\"language-text\">entryType</code> 是固定的 <code class=\"language-text\">function</code>，因为这个值是通过 <code class=\"language-text\">timerify</code> 拿到的；<code class=\"language-text\">startTime</code> 和 <code class=\"language-text\">duration</code> 分别表示调用开始的时间以及实际调用的耗时。</p>","frontmatter":{"date":"2019-11-03","title":"Require Performance in Node.js","category":"Node.js"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"startInMonth":"2019-11-01","endInMonth":"2019-11-31","time":"2019-11","previous":"2019-10","next":null}}}