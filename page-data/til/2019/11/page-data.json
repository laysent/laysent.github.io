{"componentChunkName":"component---src-templates-til-per-month-js","path":"/til/2019/11","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"4c12371e-1261-52ed-8522-aacc2f3a7626","html":"<p><code class=\"language-text\">console.assert</code> API 可以用于判断某个条件是否满足，并在不满足的时候，在 Console 里打印出相关的数据。整体 API 和 <code class=\"language-text\">console.error</code> 比较类似，但是第一个参数是一个判断条件。整个调用，只会在第一个参数是 falsy 值的时候，才会将后面的数据打印出来。打印的方式和 <code class=\"language-text\">console.error</code> 类似，输出的是 error 信息。需要注意的一点是，根据 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Console/assert\">MDN</a> 的描述，在 Node.js 10 版本前，除了输出之外，还会抛出一个 <code class=\"language-text\">AssertionError</code>。这个行为是错误的，console API 不应该影响主流程的代码，Node.js 在 10 修复了问题。</p>\n<p>下面是一段示例代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'before'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'incorrect with error message'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'after'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出的结果是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">before\nincorrect with error message\nafter</code></pre></div>\n<p>其中，<code class=\"language-text\">incorrect with error message</code> 这一条，还会额外输出调用的堆栈信息，方便调试。</p>\n<p>总结来说，在代码中实现类似 Chrome 中 conditional breakpoint，使用 <code class=\"language-text\">console.assert</code> 是一个不错的选择：只在出现问题的时候打印必要的信息，可以尽可能的减少对 Console 输出的污染。</p>","frontmatter":{"date":"2019-11-05","title":"console.assert","category":"JavaScript"}}},{"node":{"id":"df525546-37d6-5170-90fd-2fe8e78bc734","html":"<p><code class=\"language-text\">console.trace</code> API 支持可选参数，输出的效果和 <code class=\"language-text\">console.log</code> / <code class=\"language-text\">console.info</code> 类似。但是除了输出参数指定的内容之外，还会连带将当前的调用堆栈一起输出。可以看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Console/trace\">MDN</a> 中给出的一个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">trace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出的结果类似：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">bar\nfoo\n&lt;anonymous&gt;</code></pre></div>\n<p>其中，<code class=\"language-text\">&lt;anonymous&gt;</code> 是因为 <code class=\"language-text\">foo</code> 函数是在 console 中直接运行的。当然，这个只能在调试阶段进行代码的检查。如果需要在线上环境，对可能出问题的地方收集调用堆栈信息，直接使用 <code class=\"language-text\">console.trace</code> 就不满足需求了。可以转而使用 Error 中的 stack 字段：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> error <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出结果类似：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">Error\n    at bar (&lt;anonymous&gt;:3:19)\n    at foo (&lt;anonymous&gt;:6:3)\n    at &lt;anonymous&gt;:9:1</code></pre></div>","frontmatter":{"date":"2019-11-04","title":"console.trace","category":"JavaScript"}}},{"node":{"id":"0e49e733-98a8-5e79-bcb5-c4ef0b27aaf8","html":"<p>在 Node.js 中，可以通过使用 Performance API 来对 <code class=\"language-text\">require</code> 模块的性能进行检测。这里的 Performance 模块，是 Node.js 根据 <a href=\"https://w3c.github.io/performance-timeline/\">W3C Performance Timeline 规范</a>，实现的一套和 Web 相同的 API 接口集合。一般的时间测量，可以通过 <code class=\"language-text\">Performance.mark</code> 和 <code class=\"language-text\">Performance.measure</code> 的组合来进行，使用的方法大体上和 Web 中一致（但是需要使用 <code class=\"language-text\">PerformanceObserver</code> 来获取测量的结果，这一点和 Web 不太相同，具体可以参考官方的<a href=\"https://nodejs.org/api/perf_hooks.html\">文档</a>）。</p>\n<p>和 Web 不同的是，在 Node.js 的 Performance 模块中，还提供了一个 <a href=\"https://nodejs.org/api/perf_hooks.html#perf_hooks_performance_timerify_fn\">timerify</a> 的接口，可以简便的对一个函数进行封装，从而测量出这个函数的实际调用时间。</p>\n<p>有了这个接口，就可以很容易的测量 Node.js 中加载模块的耗时了。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">,</span>\n  PerformanceObserver\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'perf_hooks'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> mod <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'module'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmod<span class=\"token punctuation\">.</span><span class=\"token class-name\">Module</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>require <span class=\"token operator\">=</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">timerify</span><span class=\"token punctuation\">(</span>mod<span class=\"token punctuation\">.</span><span class=\"token class-name\">Module</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>require<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> obs <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PerformanceObserver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">list</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> entries <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">getEntries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  fs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./profile.json'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>entries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  obs<span class=\"token punctuation\">.</span><span class=\"token function\">disconnect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobs<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  entryTypes<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'function'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Module.require'</span><span class=\"token punctuation\">,</span>\n  buffered<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里有几点可以说明一下：</p>\n<ol>\n<li><code class=\"language-text\">mod.Module.prototype.require</code> 被 <code class=\"language-text\">timerify</code> 之后，所有模块在 <code class=\"language-text\">require</code> 的时候，都会使用被 <code class=\"language-text\">timerify</code> 过的版本；</li>\n<li>PerformanceObserver 的作用是获取 entries 的结果；</li>\n<li><code class=\"language-text\">obs.disconnect</code> 用于解除连接，不再进行后续的接听；</li>\n<li><code class=\"language-text\">obs.observer</code> 设置 <code class=\"language-text\">entryTypes: [&#39;function&#39;]</code>，确保这里 <code class=\"language-text\">timerify</code> 的结果都可以被获取到；</li>\n<li><code class=\"language-text\">obs.observer</code> 中设置 <code class=\"language-text\">buffered: true</code>，确保 observer 的回调函数不会被立刻执行，而是用 <code class=\"language-text\">setImmediate</code> 延迟调用。这样的好处是，一次 <code class=\"language-text\">require</code> 后，该模块的调用时间和该模块内部调用子模块的耗时都会一次性通过回调函数返回。（注：默认这里的值是 <code class=\"language-text\">false</code>，见<a href=\"https://nodejs.org/docs/latest-v10.x/api/perf_hooks.html#perf_hooks_performanceobserver_observe_options\">文档</a>）;</li>\n<li>官方给出的示例，还 <code class=\"language-text\">timerify</code> 了 <code class=\"language-text\">require</code> 函数（见<a href=\"https://nodejs.org/api/perf_hooks.html#perf_hooks_measuring_how_long_it_takes_to_load_dependencies\">这里</a>），这样做会导致当前模块中 <code class=\"language-text\">require</code> 的调用，生成两份 Performance 数据（一份来自 <code class=\"language-text\">require</code>，一份来自 <code class=\"language-text\">Module.require</code>）。出于精简的考虑，上面的示例代码中去掉了对 <code class=\"language-text\">require</code> 函数的 <code class=\"language-text\">timerify</code>。</li>\n</ol>\n<p>在上面的示例代码中，最终得到的结果，存放在了一个 JSON 文件内，大体的格式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"0\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"required-module-name\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Module.require\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"entryType\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"startTime\"</span><span class=\"token operator\">:</span> <span class=\"token number\">7397.399892</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"duration\"</span><span class=\"token operator\">:</span> <span class=\"token number\">112.681678</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>这里，<code class=\"language-text\">0</code> 表示第一个参数的值，对于 <code class=\"language-text\">require</code> 来说就是具体引用的模块的名称/地址；<code class=\"language-text\">name</code> 表示是哪个函数的调用，在示例中就是被 <code class=\"language-text\">timerify</code> 过的 <code class=\"language-text\">Module.require</code> 函数；<code class=\"language-text\">entryType</code> 是固定的 <code class=\"language-text\">function</code>，因为这个值是通过 <code class=\"language-text\">timerify</code> 拿到的；<code class=\"language-text\">startTime</code> 和 <code class=\"language-text\">duration</code> 分别表示调用开始的时间以及实际调用的耗时。</p>","frontmatter":{"date":"2019-11-03","title":"Require Performance in Node.js","category":"Node.js"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"startInMonth":"2019-11-01","endInMonth":"2019-11-31","time":"2019-11","previous":"2019-10","next":null}}}