{"componentChunkName":"component---src-templates-til-per-month-js","path":"/til/2019/11","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"c366bb01-a2f9-54c4-ac76-8013cd32b800","html":"<p>在使用了 <a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin\">mini-css-extract-plugin</a> 的项目中，有时会遇到如下的 Warning 输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in chunk styles [mini-css-extract-plugin]\nConflicting order between:\n* css xxx/css-loader/dist/cjs.js!./e1.css\n* css xxx/css-loader/dist/cjs.js!./e2.css\n* css xxx/css-loader/dist/cjs.js!./e3.css</code></pre></div>\n<section><h2>tl;dr</h2><p>上面这段 Warning 的实际含义是：</p><blockquote>\n<p>由于没法找到最合适的解，plugin 被迫使用了相对最优的解，将 <code class=\"language-text\">e1.css</code> 放到了编译产物中。在某些 chunk group 中，<code class=\"language-text\">e2.css</code> 或 <code class=\"language-text\">e3.css</code> 这两个文件引用位置在 <code class=\"language-text\">e1.css</code> 之前；而在 plugin 将 <code class=\"language-text\">e1.css</code> 加入编译产物的时候，<code class=\"language-text\">e2.css</code> 和 <code class=\"language-text\">e3.css</code> 还没有被添加。</p>\n</blockquote><p>换句话说，如果 <code class=\"language-text\">e1.css</code> 本来的用途是覆盖 <code class=\"language-text\">e2.css</code> 的内容，且覆盖依靠的是同优先级下 CSS 定义出现的先后顺序，那么在 plugin 编译完成之后，这个覆盖就会失效。</p></section>\n<section><h2>造成 Warning 的例子</h2><p>以下通过一个直观的例子来说明 plugin 在何时可能会输出上述 Warning：</p><p>假设有两个文件 <code class=\"language-text\">entry1.js</code>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token string\">'./e1.css'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'./e2.css'</span><span class=\"token punctuation\">;</span></code></pre></div><p><code class=\"language-text\">entry2.js</code>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token string\">'./e2.css'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'./e1.css'</span><span class=\"token punctuation\">;</span></code></pre></div><p>且 Webpack 配置了需要将 <code class=\"language-text\">e1.css</code> 和 <code class=\"language-text\">e2.css</code> 打包到同一个文件中。如果 plugin 选择将 <code class=\"language-text\">e1.css</code> 放在 <code class=\"language-text\">e2.css</code> 的前面，那么就不满足 <code class=\"language-text\">entry2.js</code> 的使用顺序；反之则不满足 <code class=\"language-text\">entry1.js</code> 的。正是在这样的“矛盾”情况下，plugin 输出了一个 Warning，并选择了一个相对最优的解。</p></section>\n<section><h2>更好的 Warning</h2><p>上面提到的 mini-css-extract-plugin Warning 并不是非常直观，也很难知道具体是哪一个 chunk group 出现了问题。新提交的 PR <a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/pull/465\">#465</a> 以及 <a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/pull/468\">#468</a> 对此做了优化。优化后的输出类似：</p><div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in chunk styles [mini-css-extract-plugin]\nConflicting order. Following module has been added:\n * css xxx!./e1.css\ndespite it was not able to fulfill desired ordering with these modules:\n * css xxx!./e2.css\n   - couldn&#39;t fulfill desired order of chunk group(s) entry2\n   - while fulfilling desired order of chunk group(s) entry1</code></pre></div><p>根据 Warning 的提示，只需要观察 entry2 中对应的代码，就可以找到不满足的引入顺序了。</p></section>\n<section><h2>是否需要关心</h2><p>这个 Warning 是否需要关注，取决于 CSS 在项目中是如何被使用的：只要在项目的使用过程中，没有 CSS 是通过加载的顺序进行优先级覆盖的，那么就可以忽略 plugin 给出的 Warning；反之，如果有这样的情况，则一定需要根据 Warning 修正输出，防止编译导致的意外。</p><p>当然，最保险的做法是启用 CSS Module，从源头上保证各个模块间的 CSS 是不会相互覆盖的。</p></section>\n<section><h2>代码分析</h2><p>以下从这个 Warning 入手，分析 plugin 是如何从 modules 生成最终的打包产物的。</p><p>观察 mini-css-extract-plugin 的源代码，不难找到这个 Warning 的具体输出<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L494\">代码</a>。接下来，将针对这段代码所在的 <code class=\"language-text\">renderContentAsset</code> 进行分析，了解 plugin 生成打包产物的算法。</p><p>首先观察 <code class=\"language-text\">renderContentAsset</code> 函数最开始的<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L416\">比较语句</a>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> chunkGroup<span class=\"token punctuation\">.</span>getModuleIndex2 <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>这里，<code class=\"language-text\">chunkGroup.getModuleIndex2</code> 是 Webpack 4 中的 API，在之前的版本中不存在（Webpack 3 及之前使用的是 <a href=\"https://github.com/webpack-contrib/extract-text-webpack-plugin\">extract-text-webpack-plugin</a>）。接下来，重点关心 Webpack 4 对应的代码段。</p><p>首先看 <code class=\"language-text\">moduleDependencies</code> 变量的初始化（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L418\">源码</a>）：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> moduleDependencies <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span>modules<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p><code class=\"language-text\">moduleDependencies</code> 为每一个 module 都定义了一个对应的空 Set（具体 Set 内的值会在后续填充）。</p><p>接下来看 <code class=\"language-text\">modulesByChunkGroup</code> 变量的定义（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L423\">源码</a>）：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> modulesByChunkGroup <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>chunk<span class=\"token punctuation\">.</span>groupsIterable<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">cg</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">return</span> sortedModules<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>可以看到，<code class=\"language-text\">modulesByChunkGroup</code> 本质上，是将所有的 chunk group（<code class=\"language-text\">chunk.groupsIterable</code>）转化成了对应的 <code class=\"language-text\">sortedModules</code>。这里 <code class=\"language-text\">sortedModules</code> 变量的定义为（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L424-L434\">源码</a>）：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> sortedModules <span class=\"token operator\">=</span> modules\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      module<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">,</span>\n      index<span class=\"token punctuation\">:</span> cg<span class=\"token punctuation\">.</span><span class=\"token function\">getModuleIndex2</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// eslint-disable-next-line no-undefined</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>index <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> b<span class=\"token punctuation\">.</span>index <span class=\"token operator\">-</span> a<span class=\"token punctuation\">.</span>index<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>简单来说，做了几件事情：</p><ol>\n<li>将 <code class=\"language-text\">modules</code> 中不属于当前 chunk group（<code class=\"language-text\">cg</code>）的部分剔除，对应的是 <code class=\"language-text\">.filter((item) =&gt; item.index !== undefined)</code>；</li>\n<li>根据 module 在 chunk group 中实际出现的位置，按从后往前进行排序，对应的是 <code class=\"language-text\">.sort((a, b) =&gt; b.index - a.index)</code></li>\n</ol><p>这里，越是先出现的 module 在最终的 <code class=\"language-text\">sortedModules</code> 数组中排的越靠后。换句话说，出现在数组最后的一个 module，没有任何前置的依赖（在该 chunk group 中，这个 module 是第一个被引入的）；而理论上来说，数组的第一个 module 依赖了数组后面的所有 modules（从 CSS 的角度来说，这个模块出现在最后。在所有选择器优先级一样的前提下，这个 module 理论上可以对之前所有的 module 进行覆盖）。这里采用倒叙的方式组织数组，是为了后续可以方便的使用 <code class=\"language-text\">Array.prototype.pop</code> 函数去获取当前没有依赖的 module。</p><p>接下来，<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L436-L442\">代码</a>对 <code class=\"language-text\">sortedModules</code> 变量值进行了填充：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> sortedModules<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> moduleDependencies<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>sortedModules<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> sortedModules<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>sortedModules<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>如上所述，<code class=\"language-text\">sortedModules</code> 中后出现的 module 是先出现 module 的依赖。这里的 <code class=\"language-text\">moduleDependencies</code> 变量记录了各个 module 的所有依赖（不仅仅是当前 chunk group 的依赖，所有 chunk group 的依赖最终都会被写入到这个 Set 中），其中 key 是各个 module，而对应的 value 则是一个 Set，Set 中的每个元素都是当前这个 module 的依赖。</p><p>之后定义了 <code class=\"language-text\">usedModules</code> 和 <code class=\"language-text\">unusedModulesFilter</code> 函数（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L448-L450\">源码</a>），目的是为了判断某一个 module 是否已经被当前的 plugin 使用了。</p><p>接下来的<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L452-L455\">代码</a>需要确保所有的 modules 都会根据某个具体的算法在最终的编译产物中被使用到。这里判断的方法就是 <code class=\"language-text\">usedModules</code> 是否包含了 <code class=\"language-text\">modules</code> 中所有的内容。</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>usedModules<span class=\"token punctuation\">.</span>size <span class=\"token operator\">&lt;</span> modules<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> success <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> bestMatch<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> bestMatchDeps<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>至此，准备工作都做完了。接下来就是核心的部分：如何在各个 chunk group 中选取合适的 module，依次放到最终生成的 CSS 文件中。<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L458-L484\">代码</a>如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> list <span class=\"token keyword\">of</span> modulesByChunkGroup<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// skip and remove already added modules</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> usedModules<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">[</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    list<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// skip empty lists</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> module <span class=\"token operator\">=</span> list<span class=\"token punctuation\">[</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> deps <span class=\"token operator\">=</span> moduleDependencies<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// determine dependencies that are not yet included</span>\n    <span class=\"token keyword\">const</span> failedDeps <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>unusedModulesFilter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// store best match for fallback behavior</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>bestMatchDeps <span class=\"token operator\">||</span> bestMatchDeps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> failedDeps<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      bestMatch <span class=\"token operator\">=</span> list<span class=\"token punctuation\">;</span>\n      bestMatchDeps <span class=\"token operator\">=</span> failedDeps<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>failedDeps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// use this module and remove it from list</span>\n      usedModules<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      success <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>理想情况下，两个 CSS module 在最终编译产物中的先后顺序，应该和这两个 CSS module 在某一个 chunk group 中的先后顺序是一致的。如果顺序上无法保证一致，那么应该尽可能将不一致的情况降到最低。mini-css-extract-plugin 就是遵循这一个原则来对 module 进行排序的。在每一次的选取步骤中，算法都会依次遍历每一个 chunk group，做下面几个事情：</p><ol>\n<li>拿到当前该 chunk group 中没有依赖的那个 CSS module（<code class=\"language-text\">const module = list[list.length - 1];</code>）；</li>\n<li>判断这个拿到的 CSS module 是否有前置的依赖还没有被放到最终产物中去（<code class=\"language-text\">const failedDeps = Array.from(deps).filter(unusedModulesFilter)</code>）;</li>\n<li>如果没有前置依赖了，那么这个 CSS module 就可以被“安全”的放到当前的编译产物中去（<code class=\"language-text\">if (failedDeps.length === 0) {</code> 对应的部分）；</li>\n<li>如果有不满足的前置依赖，那么就去寻找不满足情况最少的一个（<code class=\"language-text\">bestMatchDeps.length &gt; failedDeps.length</code>），然后记下来（<code class=\"language-text\">bestMatchDeps = failedDeps;</code>）</li>\n</ol><p>如果找到了没有前置依赖的 module，代码就直接 break，跳到下一次 while 循环中去了；如果没有找到完美匹配的情况，就会进入接下来的<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L486-L507\">代码</a>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no module found => there is a conflict</span>\n  <span class=\"token comment\">// use list with fewest failed deps</span>\n  <span class=\"token comment\">// and emit a warning</span>\n  <span class=\"token keyword\">const</span> fallbackModule <span class=\"token operator\">=</span> bestMatch<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>ignoreOrder<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    compilation<span class=\"token punctuation\">.</span>warnings<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>\n        <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">chunk </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>chunk<span class=\"token punctuation\">.</span>name <span class=\"token operator\">||</span> chunk<span class=\"token punctuation\">.</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> [</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>pluginName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">]\\n</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token operator\">+</span>\n          <span class=\"token string\">'Conflicting order between:\\n'</span> <span class=\"token operator\">+</span>\n          <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"> * </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>fallbackModule<span class=\"token punctuation\">.</span><span class=\"token function\">readableIdentifier</span><span class=\"token punctuation\">(</span>\n            requestShortener\n          <span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\\n</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token operator\">+</span>\n          <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>bestMatchDeps\n            <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"> * </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">readableIdentifier</span><span class=\"token punctuation\">(</span>requestShortener<span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  usedModules<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>fallbackModule<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>上面代码中的 <code class=\"language-text\">bestMatch</code> 就是对应了最佳情况时候 modules 排序的数组，这里 <code class=\"language-text\">fallbackModule = bestMatch.pop()</code> 就可以拿到当前这个最佳情况的 chunk group 中，没有依赖的那个 CSS module。和之前代码中 <code class=\"language-text\">module = list[list.length - 1]</code> 拿到的数据是一样的。</p><p>同时，<code class=\"language-text\">bestMatchDeps</code> 对应的就是上面代码里的 <code class=\"language-text\">failedDeps</code> 数组，表示的是当前这个 <code class=\"language-text\">fallbackModule</code> 被选中时，有哪些该 module 的前置依赖并没有被事先放到编译产物中去。</p><p>接下来就是向 Webpack 输出 Warning 的代码了。再来看下面这段 Warning：</p><div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in chunk styles [mini-css-extract-plugin]\nConflicting order between:\n* css xxx/css-loader/dist/cjs.js!./e1.css\n* css xxx/css-loader/dist/cjs.js!./e2.css\n* css xxx/css-loader/dist/cjs.js!./e3.css</code></pre></div><p>可知道，具体的含义是：由于没法找到最合适的解，plugin 被迫使用了相对最优的解，将 <code class=\"language-text\">e1.css</code> 放到了编译产物中。在某些 chunk group 中，<code class=\"language-text\">e2.css</code> 或 <code class=\"language-text\">e3.css</code> 这两个文件引用位置在 <code class=\"language-text\">e1.css</code> 之前；而在 plugin 将 <code class=\"language-text\">e1.css</code> 加入编译产物的时候，<code class=\"language-text\">e2.css</code> 和 <code class=\"language-text\">e3.css</code> 还没有被添加。</p></section>","frontmatter":{"date":"2019-11-28","title":"Conflicting order in mini-css-extract-plugin","category":"Build"}}},{"node":{"id":"4932e15d-274d-516f-988d-6f70cc3496f0","html":"<p>Chunk Group 是 Webpack 4 中新产生的一个概念。</p>\n<p>在 Webpack 中，一个文件/资源在打包时就是一个 module，一些 module 被打包到一起，生成一个 chunk。在原来的 Webpack 中，chunk 之间的依赖是一种父子关系：如果一个 chunk 有父 chunk，那么就可以认定，在这个 chunk 被加载的时候，至少其一个父 chunk 已经被加载了。在这种假设下，Webpack 可以对 chunk 进行一些优化，比如：如果一个 chunk 中的某个 module 被所有父 chunk 使用了，那么这个 module 就可以从 chunk 中删除（因为在加载 chunk 的时候，至少有一个父 chunk 已经被加载了，故这个 module 肯定已经存在了）。</p>\n<p>然而，这种父子关系的模式，并不利于 chunk 的拆分：在 CommonsChunkPlugin 中，如果一个 chunk 被拆分了出来，那么这个 chunk 会被“当作”是原来 chunk 的父 chunk 进行处理。这种父子关系其实是不正确的，因此也会影响到其他一些优化的进行。</p>\n<p>因此，在 Webpack 4 中，引入了 chunk group 的概念，目的就是修正这一概念。</p>\n<p>一个 chunk group，顾名思义，就是一组 chunk 的集合。一个 Webpack 的加载入口、或是一个异步加载点就是一个 chunk group，这个 group 中所有的 chunk 都是可以被并行加载的。同时，一个 chunk 也可以归属于多个不同的 chunk group。有了 chunk group 的概念，在通过 SplitChunksPlugin 进行拆分的时候，只需要将拆出来的 chunk 划分到对应的各个 chunk group 中去，就可以保证正常的使用了。</p>\n<p>参考文档见<a href=\"https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366\">这里</a>。</p>","frontmatter":{"date":"2019-11-27","title":"Chunk Group","category":"Build"}}},{"node":{"id":"7dc217cf-0b7c-5c89-bffe-de976e7fdcfd","html":"<p><code class=\"language-text\">Node.isEqualNode</code> 可以用于比较当前节点（Node）和指定节点是否是相同的。和 <code class=\"language-text\">Node.isSameNode</code> 不同，<code class=\"language-text\">.isEqualNode</code> API 并不需要两个被比较的节点是同一个。只需要满足以下的条件，两个节点就会被认为是相同的：</p>\n<ol>\n<li>两个节点的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\">nodeType</a> 是相同的；</li>\n<li>（省略非 Element 比较的情况，具体细节可以参考 <a href=\"https://dom.spec.whatwg.org/#concept-node-equals\">DOM 规范</a>）；</li>\n<li>如果节点是 element 的话，那么对 <code class=\"language-text\">A.isEqualNode(B)</code> 来说，A 中所有的属性，都可以在 B 上找到相同的值（反之亦然）；</li>\n<li>两个节点应该有等长的 <code class=\"language-text\">children</code>；</li>\n<li>两个节点的 <code class=\"language-text\">children</code> 的每个相同位置上的值都是相同的（递归调用 <code class=\"language-text\">isEqualNode</code> 的定义）。</li>\n</ol>\n<p>这里需要说明的几点是：</p>\n<ol>\n<li>在属性判断的时候，并不需要关心顺序：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> second <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> className <span class=\"token operator\">=</span> <span class=\"token string\">'className'</span><span class=\"token punctuation\">;</span>\n\nfirst<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span>\nfirst<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> className<span class=\"token punctuation\">;</span>\n\nsecond<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> className<span class=\"token punctuation\">;</span>\nsecond<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// first: &lt;div id=\"id\" className=\"className\">&lt;/div></span>\n<span class=\"token comment\">// second: &lt;div className=\"className\" id=\"id\">&lt;/div></span>\nfirst<span class=\"token punctuation\">.</span><span class=\"token function\">isEqualNode</span><span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => true</span></code></pre></div>\n<ol start=\"2\">\n<li>属性的判断是直接对值进行比较的，因此 <code class=\"language-text\">style</code> 的顺序不同会造成结果的不同：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> second <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfirst<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>display <span class=\"token operator\">=</span> <span class=\"token string\">'block'</span><span class=\"token punctuation\">;</span>\nfirst<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">;</span>\n\nsecond<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">;</span>\nsecond<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>display <span class=\"token operator\">=</span> <span class=\"token string\">'block'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// first: &lt;div style=\"display:block;color:red\">&lt;/div></span>\n<span class=\"token comment\">// second: &lt;div style=\"color:red;display:block\">&lt;/div></span>\nfirst<span class=\"token punctuation\">.</span><span class=\"token function\">isEqualNode</span><span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span></code></pre></div>\n<ol start=\"3\">\n<li>属性的比较是顺序无关的，但是 <code class=\"language-text\">children</code> 的比较是顺序相关的：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> second <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> childA <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> childB <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfirst<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>childA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfirst<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>childB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsecond<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>childB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsecond<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>childA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfirst<span class=\"token punctuation\">.</span><span class=\"token function\">isEqualNode</span><span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span></code></pre></div>\n<ol start=\"4\">\n<li>Node 是 Element 的“父类”，除了一般的 DOM 节点之外，节点上的 attributes，节点中的 comment 等也是 Node。这些节点也有 <code class=\"language-text\">isEqualNode</code> API 可以用于比较。对于一般的 Element 来说，可以简单的认为类型，属性和子节点一样，<code class=\"language-text\">isEqualNode</code> 就会返回 <code class=\"language-text\">true</code>。</li>\n</ol>\n<p>原始的比较算法，可以参考 <a href=\"https://dom.spec.whatwg.org/#concept-node-equals\">DOM 规范</a>；MDN 的介绍在<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/isEqualNode\">这里</a>。</p>","frontmatter":{"date":"2019-11-26","title":"isEqualNode","category":"JavaScript"}}},{"node":{"id":"1de0a311-e54d-5928-bcf7-eccaae105279","html":"<p><code class=\"language-text\">Node.isSameNode</code> 这个 API 的作用，是判断另一个 Node 节点和当前节点是否是相同的。举例来说：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n\na<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => true</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span></code></pre></div>\n<p>因为在一个同一个 document 中，一个 Node 实际只有一个引用，因此 <code class=\"language-text\">.isSameNode</code> API 的实际效果其实和 <code class=\"language-text\">==</code> 或 <code class=\"language-text\">===</code> 运算是一致的。简单来说，上面的代码，可以等价于：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">a <span class=\"token operator\">===</span> c<span class=\"token punctuation\">;</span> <span class=\"token comment\">// => true</span>\na <span class=\"token operator\">===</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span></code></pre></div>\n<p>在 <a href=\"https://dom.spec.whatwg.org/#dom-node-issamenode-othernode-othernode\">DOM (Living Standard) 规范</a>中，也可以看到相关的注释，说明 <code class=\"language-text\">.isSameNode</code> 本质上只是因为历史原因而给出的 <code class=\"language-text\">===</code> 的别名（alias）。</p>\n<p>然而在某些有限的场景下，<code class=\"language-text\">.isSameNode</code> 依然有发挥的应用场景，目前可以想到的有以下几点：</p>\n<ol>\n<li>在节点相关算法（如 Diff 算法）中作为抽象方法直接使用。比如，在 <a href=\"https://github.com/patrick-steele-idem/morphdom\">morphdom</a> 中，就使用了 <code class=\"language-text\">.isSameNode</code> 这个 API 来比较两个节点是否相同，从而节省比较的次数(<a href=\"https://github.com/patrick-steele-idem/morphdom/blob/56f330fa0fa6df9e51eeeaaae5894e24f30edb7c/src/morphdom.js#L237\">源码</a>)。根据 morphdom 给出的<a href=\"https://github.com/patrick-steele-idem/morphdom/blob/e4a34d934b24bb5aad1fcbc6222ed21bcdb5e56d/docs/virtual-dom.md#L23\">文档</a>可以看到，morphdom 的算法也支持对 virtual dom 进行比较，只需要 virtual dom 也对节点实现了相应的 <code class=\"language-text\">.isSameNode</code> API，就有可能可以在比较的时候节省一定的计算次数。这里，<code class=\"language-text\">.isSameNode</code> 在 morphdom 中就被作为抽象方法使用了，算法本身并不在意真正在 diff 的对象是真实的 DOM 还是 virtual DOM，只要节点实现了符合要求的 API，算法就可以正确的进行。</li>\n<li>通过重写方法来达到“代理节点”的功能。现在大多数的 UI 库，都通过声明式的方式来定义组件。在这种情况下，开发者并不需要显示的写出在何时通过何种方式创建或更新一个节点，只需要写出 <code class=\"language-text\">state =&gt; UI</code> 这样的映射函数，UI 库就会在 state 更新后，通过映射函数去得到新的 UI 组件，然后通过 diff 算法去计算得到需要修改的部分，最终将必要的部分进行更新。在这种情况下，就没有办法通过 <code class=\"language-text\">===</code> 去比较两个节点是否相同了，因为流程上是需要通过新的 state 生成节点，然后再和已有的 Node 进行比较。这种情况下，通过改写 <code class=\"language-text\">.isSameNode</code> 就可以达到人为控制的目的。</li>\n</ol>\n<p>举一个 <a href=\"https://github.com/choojs/nanocomponent\">nanocomponent</a> 中提到的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> html <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nanohtml'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> el1 <span class=\"token operator\">=</span> html<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>pink is the best&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> el2 <span class=\"token operator\">=</span> html<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>blue is the best&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 对 el1 进行代理操作</span>\n<span class=\"token keyword\">const</span> proxy <span class=\"token operator\">=</span> html<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\nproxy<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">isSameNode</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">targetNode</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>targetNode <span class=\"token operator\">===</span> el1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nel1<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// true</span>\nel1<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// false</span>\nproxy<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nproxy<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<p>虽然 <code class=\"language-text\">proxy</code> 和 <code class=\"language-text\">el1</code> 并不是真的一样的两个节点，但是因为对 <code class=\"language-text\">isSameNode</code> 进行了改写，因而在 diff 算法中，两个节点会被当作是一致的。这有助于节省比较的次数。</p>\n<p><code class=\"language-text\">.isSameNode</code> API 的支持情况，可以查看 <a href=\"https://caniuse.com/#search=isSameNode\">Can I Use</a>；文档可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/isSameNode\">MDN</a>。</p>","frontmatter":{"date":"2019-11-25","title":"isSameNode","category":"JavaScript"}}},{"node":{"id":"d4f2cc35-174d-5e24-86fa-274d23e4c9a1","html":"<p>在 TypeScript 编译过程中，可能会遇到如下的报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">Exported variable &lt;variable name&gt; has or is using private name &lt;private name&gt;</code></pre></div>\n<p>这一报错只会出现在开启了 declaration 输出之后。开启的方式是编译时增加 <code class=\"language-text\">--declaration</code>，或者在 tsconfig.json 中加入：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"declaration\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>出现这一报错的原因是，最终被使用的某一个类型，引用到了某一个没有被公开（export）的类型。简单的例子如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">B</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">type</span> Props <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">|</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，之所以会出现问题，理由很简单：TypeScript 试图输出一个定义类型的文件，其中就包括了 <code class=\"language-text\">Props</code> 的定义。然而，如果要明确定义 <code class=\"language-text\">Props</code>，就需要用到两个类型 <code class=\"language-text\">A</code> 和 <code class=\"language-text\">B</code>。在这里，<code class=\"language-text\">A</code> 和 <code class=\"language-text\">B</code> 这两个类型因为没有被公开（export），因而是私有（private）的。故，理论上来说，TypeScript 的导出定义文件中不应该包含这两个类型。而没有这两个类型的话，TypeScript 就没有办法定义 <code class=\"language-text\">Props</code> 了。最终，TypeScript 只能报错。</p>\n<p>官方给出的解释可以参考<a href=\"https://github.com/ant-design/ant-design/pull/19846#event-2817984936\">这里</a>。</p>\n<p>要解决这个问题，方法也很简单：所有使用到的类型，全部都公开（export）就好了。</p>","frontmatter":{"date":"2019-11-21","title":"Export Variable using Private Name","category":"TypeScript"}}},{"node":{"id":"80ff40b4-417e-59fe-8b49-49f477af38e5","html":"<p><code class=\"language-text\">dd</code> 是一个 Bash 命令，可以用于文件/硬盘的整体拷贝。比如，希望将 Raspberry Pi 的 SD 卡复制一份，就可以使用 <code class=\"language-text\">dd</code> 这个命令来进行。</p>\n<p>但是默认的 <code class=\"language-text\">dd</code> 命令并没有进度提示，在完整执行完之前，默认在 stdout 中不会看到任何输出。</p>\n<p>如果想要获得当前 <code class=\"language-text\">dd</code> 的执行进度，可以尝试如下的一些方法：</p>\n<ol>\n<li>通过 <code class=\"language-text\">Control + T</code> 将 <code class=\"language-text\">SIGINFO</code> 发送给 <code class=\"language-text\">dd</code> 命令，<code class=\"language-text\">dd</code> 收到后会输出当前的进度信息；</li>\n<li>类似的，也可以通过 <code class=\"language-text\">pkill</code> 命令将 <code class=\"language-text\">SIGINFO</code> 发送给 <code class=\"language-text\">dd</code>：<code class=\"language-text\">pkill -INFO -x dd</code>。</li>\n</ol>\n<p>其中，针对第二点的命令，可以写一个简单的脚本来定时输出当前的进度：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> pgrep ^dd<span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span> <span class=\"token function\">pkill</span> -INFO <span class=\"token function\">dd</span><span class=\"token punctuation\">;</span> <span class=\"token function\">sleep</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">done</span></code></pre></div>\n<p><code class=\"language-text\">dd</code> 的输出结果示例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">1000+0 records in\n1000+0 records out\n67108864000 bytes transferred in 3.720346 secs (18038339571 bytes/sec)</code></pre></div>\n<p>更多方法（原理都是发送 <code class=\"language-text\">SIGINFO</code> 给 <code class=\"language-text\">dd</code>），可以参考<a href=\"https://www.commandlinefu.com/commands/view/11666/check-the-status-of-dd-in-progress-os-x\">这里</a>。</p>","frontmatter":{"date":"2019-11-20","title":"Progress of dd","category":"Bash"}}},{"node":{"id":"0442beaa-4143-5c44-ad49-5d031a3c488b","html":"<p>Raspberry Pi 的操作系统写在 SD Card 中。如果想将这个当前的系统做克隆（用于备份或存储迁移），可以通过 <code class=\"language-text\">dd</code> 命令来进行。</p>\n<ol>\n<li>将原始的 SD Card 以及新的 SD Card 插入电脑；</li>\n<li>通过 <code class=\"language-text\">diskutil</code> 命令来查看当前两张 SD Card 在 <code class=\"language-text\">dev</code> 中分别的命名是怎样的：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">diskutil list</code></pre></div>\n<p>运行后的结果大致如：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/dev/disk2\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n  ...\n\n/dev/disk3\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   ...</code></pre></div>\n<p>其中 <code class=\"language-text\">/dev/disk2</code> 和 <code class=\"language-text\">/dev/disk3</code> 就分别是插入的两个 SD Card（具体在不同的机器上可能有所不同，需要根据 <code class=\"language-text\">diskutil</code> 列出的数据进行区分）。</p>\n<p>接下来，需要将 <code class=\"language-text\">/dev/disk3</code>（也就是新的 SD Card）进行 unmount 操作，因为 SD Card 最终要写成的格式并不是 MacOS “理解”的格式（这里只是进行了 unmount，文件系统已经不可访问了，但是物理的 SD Card 依然是系统可以访问的，因而可以被写成任意的格式）：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">diskutil unmountDisk /dev/disk2</code></pre></div>\n<p>最后，使用 <code class=\"language-text\">dd</code> 命令进行数据的克隆就可以了：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/dev/disk2 <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>/dev/disk3</code></pre></div>\n<p>当然，如果不需要克隆到新的 SD Card，只是做一个简单的备份，也可以将内容保存到本地的文件中：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/dev/disk2 <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>/path/to/file.dmg</code></pre></div>\n<p>还原备份只需要：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/path/to/file.dmg <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>/dev/disk3</code></pre></div>","frontmatter":{"date":"2019-11-19","title":"Clone SD Card","category":"Bash"}}},{"node":{"id":"96f3c780-0e41-571e-abef-50a625e53a84","html":"<section><h2>现状</h2><p>当前的 Ant Design，常见的样式覆盖方案，大体上有两种：</p><ol>\n<li>使用 Ant Design 提供的 LESS 变量来覆盖原有的样式（详情可以参考官方的<a href=\"https://ant.design/docs/react/customize-theme-cn\">文档</a>）；</li>\n<li>先一次性载入完整的 Ant Design CSS/LESS 文件，然后再载入新的覆盖样式（一些文章提到了这样的处理方法，比如<a href=\"https://www.jianshu.com/p/a2e7728d8717\">这里</a>）。</li>\n</ol><p>第一种方案的主要缺点是写法不太直观，优点是替换非常彻底，而且是官方推荐的方案；第二种方案，优点是覆盖的写法非常的直观，直接写 CSS/LESS 覆盖原有样式就可以了，但是缺点是需要一次性加载所有的样式，再覆盖。</p></section>\n<section><h2>按需加载的困难点</h2><p>如果使用了 <code class=\"language-text\">babel-plugin-import</code> 对样式进行按需加载，再想要进行样式的覆盖，就很容易出现问题。</p><p>在了解具体可能存在的问题前，先来看一下 <code class=\"language-text\">babel-plugin-import</code> 的按需加载是如何运作的：在 JavaScript / TypeScript 文件遇到任何 Ant Design 组件的引用，就会同时将该组件的样式也插入到引用的位置。也就是说，如果有下面的 JavaScript 代码：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Select <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'antd'</span><span class=\"token punctuation\">;</span></code></pre></div><p>那么，编译转化后的代码大体如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token string\">'antd/lib/select/style'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> Select <span class=\"token keyword\">from</span> <span class=\"token string\">'antd/lib/select'</span><span class=\"token punctuation\">;</span></code></pre></div><p>这里实际载入的样式文件来自 <code class=\"language-text\">antd/lib/select/style</code> 目录下的 <code class=\"language-text\">index.js</code> 文件。在这个文件中，具体引用了需要用到的各个 LESS 文件。对 Select 来说，这个样式引用的代码是：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../../style/index.less\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./index.less\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../../empty/style\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>可以看到，除了 Select 自身的 <code class=\"language-text\">index.less</code> 文件外，先后还引用了 <code class=\"language-text\">../../style/index.less</code> 文件和 <code class=\"language-text\">../../empty/style</code> 文件。换句话说，<code class=\"language-text\">babel-plugin-import</code> 在处理按需加载的时候，并不是仅加载了当前使用组件的样式，还包含了一些组件需要的隐含依赖样式。这一点，在 AutoComplete 这样的复杂组件中更为明显。在使用 AutoComplete 的时候，其 <code class=\"language-text\">style/index.js</code> 内容如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../../style/index.less\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./index.less\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../../select/style\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../../input/style\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>可以看到，除了自身的样式之外，Select 和 Input 的样式代码也被加载了一遍。换句话说，如果希望做按需加载的样式覆盖，在加载 AutoComplete 组件的时候，除了需要加载样式覆盖 AutoComplete 的部分，还需要额外加载样式将 Select 和 Input 的样式也覆盖一遍。而这些隐含的样式依赖，在代码上是不容易被察觉的。一旦漏了 Select 和 Input 的样式覆盖，就容易出现问题：明明 Select 的样式在加载的时候已经覆盖过了，但是在加载了 AutoComplete 组件之后，原先已经被覆盖的样式，又被新载入的 Select 原始样式给覆盖回去了。</p><p>因为 Ant Design 的样式没有采用 CSS Module，因此 CSS/LESS 的样式覆盖就强依赖于正确的加载顺序。覆盖的样式必须在原始样式的后面加载，否则结果就会出现错乱。</p></section>\n<section><h2>解决方案</h2><p>为了确保按需加载的情况下，样式的覆盖顺序也是正确的，一个可行的思路是使用 Webpack 中的 loader 功能。根据 Webpack 打包的原理，任何的非 JavaScript 代码，都需要通过合适的 loader 转化成 JavaScript 文件，最终被打包到 bundle 中。而不管 <code class=\"language-text\">babel-plugin-import</code> 插件如何处理 Ant Design 的样式加载，这些最终被引用的 LESS 文件，都需要经过一些 loader 最终处理成可执行的文件（一般需要用到的 loader 包括 <code class=\"language-text\">less-loader</code>，<code class=\"language-text\">css-loader</code> 和 <code class=\"language-text\">style-loader</code>）。</p><p>既然 Webpack 的打包已经保证了统一的处理入口，那么就可以考虑在 loader 这一层，将样式的覆盖处理掉。</p><p>示例代码如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> pattern <span class=\"token operator\">=</span> <span class=\"token regex\">/antd\\/lib\\/([^\\/]+)\\/style\\/index.less/</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">exports</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>content<span class=\"token comment\">/*, map, meta */</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/**\n   * 这里的 resourcePath 就是具体被使用的 LESS 文件的目录，详情可以参考 Webpack 文档：\n   * https://webpack.js.org/api/loaders/#thisresourcepath\n   */</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> resourcePath <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> match <span class=\"token operator\">=</span> pattern<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>resourcePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">/**\n   * 1. 如果不是 Antd 相关的 LESS 文件，直接忽略不处理\n   */</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>match<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> content<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> component <span class=\"token operator\">=</span> match<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">/**\n   * 2. 根据使用的 Component 组件，找到对应的覆盖样式文件，赋值给 customizedLessPath\n   */</span>\n  <span class=\"token keyword\">const</span> customizedLessPath <span class=\"token operator\">=</span> <span class=\"token function\">getCustomizedLessFile</span><span class=\"token punctuation\">(</span>component<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>customizedLessPath<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> content<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">/**\n   * 3. 如果找到了覆盖文件，就将覆盖文件插入到 LESS 的最后面，保证调用顺序\n   */</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>\n    content<span class=\"token punctuation\">,</span>\n    <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">@import \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>customizedLessPath<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\";</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>接下来，在 Webpack 中配置对应的 LESS 文件处理 loader，确保这个自定义的 loader 在 less-loader 的前面：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  test<span class=\"token punctuation\">:</span> <span class=\"token regex\">/\\.less$/</span><span class=\"token punctuation\">,</span>\n  use<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'postcss-loader'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      loader<span class=\"token punctuation\">:</span> <span class=\"token string\">'less-loader'</span><span class=\"token punctuation\">,</span>\n      options<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      loader<span class=\"token punctuation\">:</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path-to-custom-loader'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div><p>这样，假设 <code class=\"language-text\">babel-plugin-import</code> 插件插入了一段 Select 的 LESS 文件：</p><div class=\"gatsby-highlight\" data-language=\"less\"><pre class=\"language-less\"><code class=\"language-less\"><span class=\"token atrule\">@select-prefix-cls<span class=\"token punctuation\">:</span> ~'@</span><span class=\"token punctuation\">{</span>ant<span class=\"token operator\">-</span>prefix<span class=\"token punctuation\">}</span><span class=\"token operator\">-</span>select'<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span></code></pre></div><p>经过上面的自定义 loader 处理之后，就会变成：</p><div class=\"gatsby-highlight\" data-language=\"less\"><pre class=\"language-less\"><code class=\"language-less\"><span class=\"token atrule\">@select-prefix-cls<span class=\"token punctuation\">:</span> ~'@</span><span class=\"token punctuation\">{</span>ant<span class=\"token operator\">-</span>prefix<span class=\"token punctuation\">}</span><span class=\"token operator\">-</span>select'<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span>\n<span class=\"token variable\">@import</span> <span class=\"token string\">\"customized-less-path\"</span><span class=\"token punctuation\">;</span></code></pre></div><p>可以看到，自定义的 LESS 文件一定会在原始 LESS 文件的后面，从顺序上可以保证样式一定可以正确的被覆盖。剩下的事情，就交给 less-loader 及后续 loader 去处理就可以了。</p></section>\n<section><h2>延伸阅读</h2><p>关于 Webpack loader 的写法，可以参考 Webpack 官方的<a href=\"https://webpack.js.org/contribute/writing-a-loader/\">教学文档</a>。</p></section>","frontmatter":{"date":"2019-11-18","title":"Ant Design Style Overwrite","category":"JavaScript"}}},{"node":{"id":"265be941-4b2a-5bcb-b8e5-b5bb85a52bb5","html":"<p>在 JavaScript 的 DOM 事件中，可以通过 <code class=\"language-text\">.stopPropagation</code> 来阻止事件冒泡。比如，如果有如下的一个 DOM 结构：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>parent</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>child</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>同时有如下的 JavaScript 代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> parent <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'parent'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'child'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nparent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (child): capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (child): bubble'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nparent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): bubble'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>那么，点击 child 元素，console 中的输出的结果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">click(parent): capture\nclick(child): capture\nclick(child): bubble\nclick(parent): bubble</code></pre></div>\n<p>这里，代码有意保持输出顺序和回调函数注册顺序的一致性。如果在上面四个回调函数中依次加上 <code class=\"language-text\">event.stopPropagation()</code>，那么之后所有的内容将不会在继续输出。</p>\n<p>以上是关于 DOM 中冒泡和捕获事件处理的一般流程。这里，如果在一个 DOM 节点上注册了不止一个的事件回调函数，那么浏览器将按照事件注册的先后顺序，依次执行对应的回调函数。需要注意的一点是，<code class=\"language-text\">event.stopPropagation()</code> 是无法阻止同级回调函数被执行的。简单将上面的代码进行修改，可以得到如下的测试代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">parent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">stopPropagation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): first capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nparent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): second capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (child): capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>那么，在点击 child 元素的时候，可以得到如下的输出结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">click (parent): first capture\nclick (parent): second capture</code></pre></div>\n<p>parent 上的 click 回调函数都依次执行完毕了，而 child 上的部分则因为 <code class=\"language-text\">event.stopPropagation()</code> 没有被执行到。这里，如果希望连同层的其他回调函数也不要继续执行，可以改用 <code class=\"language-text\">event.stopImmediatePropagation()</code>，代码修改如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">parent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">stopImmediatePropagation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): first capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nparent<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (parent): second capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click (child): capture'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>修改后的代码，执行效果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">click (parent): first capture</code></pre></div>\n<p>几点说明：</p>\n<ol>\n<li>React 的合成事件只有 <code class=\"language-text\">stopPropagation</code> 没有 <code class=\"language-text\">stopImmediatePropagation</code>，如果需要使用的话，可以用如下的方法调用真正的 DOM API：<code class=\"language-text\">.nativeEvent.stopImmediatePropagation</code>。这里 React 不需要 <code class=\"language-text\">stopImmediatePropagation</code> 的理由非常简单，因为在 JSX 中，每个事件在 Component 上只能绑定一个回调函数，因此 <code class=\"language-text\">stopImmediatePropagation</code> 是多余的；</li>\n<li>由于浏览器天然维护了一个 EventListener 的队列用于按顺序执行回调函数，<code class=\"language-text\">stopImmediatePropagation</code> 配合上回调函数的注销（<code class=\"language-text\">removeEventListener</code>），可以用于小成本实现一个 FIFO 的队列。示例代码如下：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">dom</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>key <span class=\"token operator\">!==</span> <span class=\"token string\">'Escape'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    event<span class=\"token punctuation\">.</span><span class=\"token function\">stopImmediatePropagation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">removeEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'keydown'</span><span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    dom<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'display'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'none'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  dom<span class=\"token punctuation\">.</span>attributeStyleMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'display'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'block'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'keydown'</span><span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nArray<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelectorAll</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ul li'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>register<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>以上代码执行后，按下 ESC 键，将会依次将 <code class=\"language-text\">ul</code> 下的 <code class=\"language-text\">li</code> 元素一个一个的隐藏。</p>\n<ol start=\"3\">\n<li><code class=\"language-text\">stopImmediatePropagation</code> API 的浏览器支持比较好，在 IE 9 及以上的浏览器中都可以使用，参考 <a href=\"https://caniuse.com/#search=stopimmediatepropagation\">Can I Use</a>；</li>\n<li>更多关于这个 API 的介绍，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event/stopImmediatePropagation\">MDN</a>。</li>\n</ol>","frontmatter":{"date":"2019-11-17","title":"stopImmediatePropagation","category":"JavaScript"}}},{"node":{"id":"e3c0f3bd-e7cf-579e-8fb1-d24187f5acdb","html":"<p>Google Chrome 的 DevTools 本质上也是一个由 Web 技术编写的应用，在必要的时候，可以通过以下的方式打开 DevTools 的 DevTools：</p>\n<ol>\n<li>首先打开 DevTools；</li>\n<li>选择将 DevTools 在独立窗口中打开，然后按下 Cmd + Opt + I（Mac）或 Ctrl + Shift + I（Windows）</li>\n</ol>\n<p>这样，就可以打开 DevTools 的 DevTools 了。</p>\n<p>注：这里一定要选择将最开始的 DevTools 在独立窗口打开，然后再按 Cmd + Opt + I；否则对于嵌入在页面中的 DevTools 来说，按下上面这个组合键，会将 DevTools 收回，而不是打开 DevTools 的 DevTools。</p>\n<p>另一个稍微麻烦一些的方法是：</p>\n<ol>\n<li>打开一个 DevTools；</li>\n<li>在 Chrome 中打开：<a href=\"chrome://inspect\">chrome://inspect</a>；</li>\n<li>选择 Other，就可以找到刚才打开的 DevTools 了，点击 <code class=\"language-text\">inspect</code> 链接，就可以打开这个指定 DevTools 的 DevTools 了。</li>\n</ol>\n<p>一个可以在 DevTools 的 DevTools 中进行的操作，是查看和修改 DevTools 中记录的 snippets。对应的 API 分别是：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">InspectorFrontendHost<span class=\"token punctuation\">.</span><span class=\"token function\">getPreferences</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">_</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">.</span>scriptSnippets<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nInspectorFrontendHost<span class=\"token punctuation\">.</span><span class=\"token function\">setPreference</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'scriptSnippets'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>yourSnippets<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>关于通过代码来管理 Chrome DevTools 中的 snippets，可以参考 GitHub 上的这个<a href=\"https://github.com/bahmutov/code-snippets/issues/23\">讨论</a>。</p>\n<p>同时，Chrome DevTools 本身也是开源的，代码可以在 <a href=\"https://github.com/ChromeDevTools/devtools-frontend\">GitHub</a> 上找到。</p>","frontmatter":{"date":"2019-11-15","title":"DevTools of DevTools","category":"Chrome"}}},{"node":{"id":"17386daf-da8d-53b5-8e80-73d9d610875a","html":"<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">\b<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'incorrect statement'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'correct statement'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的这段代码，看上去两个 <code class=\"language-text\">if</code> 语句并无差别。但是在实际执行的过程中，却会发现，第一个 <code class=\"language-text\">if</code> 语句有语法报错，而第二个 <code class=\"language-text\">if</code> 语句却没有。TypeScript 给出的报错信息是：<code class=\"language-text\">Invalid character.(1127)</code>。</p>\n<p>“看上去”一样的代码，在解释器看来却非常不同。究其原因，是因为第一个 <code class=\"language-text\">if</code> 语句中，有一个“看不见”的字符：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\bif (true) {</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">charCodeAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>执行上面的这段代码，会看到在 console 中输出 8。这里，8 是 Backspace 的 ASCII 码编号。在很多的文本编辑器中，这类特殊字符并不会显示出来，但对于解释器来说，这个字符确实真是存在的。（当然，并不是所有的文本编辑器都不会显示，比如把上面的代码复制到 Chrome DevTools 中，就会看到一个 <code class=\"language-text\">🔴</code> 符号，用于表示这个看不见的 Backspace）</p>\n<p>这一类的特殊字符除了 Backspace 还有很多，比如 Unicode 中的零宽空格（U+200b）、左至右符号（U+200e）、右至左符号（U+200f）等。</p>","frontmatter":{"date":"2019-11-13","title":"Invisible Characters","category":"JavaScript"}}},{"node":{"id":"65cd384a-ec80-5942-bc9e-9ab8ad9814f5","html":"<p>Node.js 中的 <code class=\"language-text\">require</code> API 在加载 commonjs 模块的时候，会做两个事情：</p>\n<ol>\n<li>根据 Node.js 的算法，查找到对应的模块文件；</li>\n<li>加载查找到的模块文件并运行。</li>\n</ol>\n<p>这里，如果只是想执行第一步，但并不真的运行这个被找到的模块，可以使用 Node.js 提供的 <code class=\"language-text\">require.resolve</code> API。具体的调用示例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> modulePath <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>modulePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上面代码中，<code class=\"language-text\">modulePath</code> 是一个完整的文件路径，指向的位置就是 <code class=\"language-text\">some-package</code> 这个模块的 entry 文件（定义在 package.json 的 <code class=\"language-text\">main</code> 中）。默认情况下，这个 <code class=\"language-text\">require.resolve</code> 的查找路径是和 <code class=\"language-text\">require</code> API 一致的：在查找的时候，会从当前文件的目录开始，逐级往上查找 <code class=\"language-text\">node_modules</code> 目录下是否有需要的库。</p>\n<p>举例来说，假设有下面这样一个目录结构：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">A.js\nnode_modules\n|- some-package\n   |- index.js\n|- other-package\n   |- index.js\nutils\n|- B.js\n   node_modules\n   |- some-package\n      |- index.js</code></pre></div>\n<p>且，假设 A.js 的代码为：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./utils/B'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'A: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'A: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'other-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>B.js 的代码为：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'B: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'B: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'other-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>那么，输出的结果为：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">B: utils/node_modules/some-package/index.js\nB: node_modules/other-package/index.js\nA: node_modules/some-package/index.js\nA: node_modules/other-package/index.js</code></pre></div>\n<p>但有的时候，只是希望可以使用 Node.js 的查找算法，但是查找的目录位置，并不一定是从当前文件所在的目录开始的。这种时候，就需要用到 <code class=\"language-text\">require.resolve</code> 的第二个参数了：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  paths<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'where-to-start-searching'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'other-possible-search-location'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，<code class=\"language-text\">paths</code> 是一个数组，表示所有的搜索起始位置。Node.js 会依次以这些路径为起始点，查找各个层级往上的 node_modules 目录。一旦找到需要的库，就停止查找，否则就会一直往上直到根目录。到达根目录后，当前的查找就以失败告终。如果还有其他的查找路径，就会继续上面的操作，否则程序会抛出异常。</p>\n<p>第二个参数的一个实际应用场景如下：假设有一个 CLI 可以用于代理执行 Webpack 命令，这时候就需要首先通过 <code class=\"language-text\">require.resolve</code> 命令找出当前执行 CLI 命令的目录内，Webpack 库在什么位置。然后才可以用 <code class=\"language-text\">require</code> 命令去加载真正在项目中使用到的 Webpack 版本，而不是 CLI 内部可能依赖的一个 Webpack 版本。</p>\n<p>更多关于 <code class=\"language-text\">require.resolve</code> 命令的说明，可以参考官方的<a href=\"https://nodejs.org/api/modules.html#modules_require_resolve_request_options\">文档</a>。</p>","frontmatter":{"date":"2019-11-12","title":"Require Resolve","category":"Node.js"}}},{"node":{"id":"bdf22101-4989-5baa-9054-a528719b9619","html":"<p><a href=\"https://github.com/tc39/proposal-nullish-coalescing\">Nullish Coalescing</a> 当前在 TC39 Stage 3 的阶段，TypeScript 在 <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing\">3.7</a> 中也将这一功能引入了进来。（<a href=\"http://dict.cn/Coalesce\">Coalesce</a> 是“合并；联合；接合”的意思）</p>\n<p>Nullish Coalescing 的简单用法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>当 <code class=\"language-text\">foo</code> 的值是 <code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code> 的时候，<code class=\"language-text\">x</code> 的值由后面的 <code class=\"language-text\">bar()</code> 决定，否则 <code class=\"language-text\">x</code> 的值就是 <code class=\"language-text\">foo</code> 本身。这一行为，一般会被用于给变量赋初始值。在之前的 JavaScript / TypeScript 中，一般会这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num <span class=\"token operator\">||</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>但是，这样写有一个问题，就是当 <code class=\"language-text\">num</code> 的值是 <code class=\"language-text\">0</code> 的时候，最终的值依然是 <code class=\"language-text\">5</code> 而不是 <code class=\"language-text\">0</code>。这一行为很可能并不是开发者希望的。</p>\n<p>和 Optional Chaining 一样，Nullish Coalescing 只有在原值是 <code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code> 的时候，才进行操作；其他的 falsy 值，都会保持原样，并不会做特殊的处理（根据 <a href=\"https://github.com/tc39/proposal-nullish-coalescing/blob/master/README.md#overview-and-motivation\">Proposal</a> 中的说明，这两个规范将会在“何时处理”上保持一致）。这很大程度上减少了 JavaScript 在类型上导致隐藏问题的可能性。</p>\n<p>需要注意的一点是，这一行为和 JavaScript 中的默认参数是有一点不一样的。上面的代码如果改写成默认参数的形式：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那么，将会在 <code class=\"language-text\">getNumber(null)</code> 的时候产生行为上的分歧。使用 Nullish Coalescing 将会返回 <code class=\"language-text\">5</code>，也就是进行了默认值赋值；而默认参数的方案将会返回 <code class=\"language-text\">null</code>，因为默认参数只有在 <code class=\"language-text\">undefined</code> 的情况下才会进行默认值赋值操作。</p>\n<p>Optional Chaining 和 Nullish Coalescing 可以放在一起操作，确保值不存在的时候，有一个兜底的默认值可以给程序使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>bar<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token string\">'default'</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-11-11","title":"Nullish Coalescing","category":"TypeScript"}}},{"node":{"id":"d7ace064-8159-5fe0-ba4d-0b04683a001d","html":"<p>在 JavaScript 中，新的<a href=\"https://github.com/tc39/proposal-object-rest-spread\">规范</a>定义了 object rest spread 运算符，可以用于对象的解构。</p>\n<p>简单的用法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>除了这种解构同时赋值给新变量的情况，也可以通过解构运算，赋值给一个已有的变量：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">'old'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token string\">'value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里需要注意的一点是，解构加赋值的运算，必须要加上括号。下面的写法会报语法错误：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">'old'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span> value <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">,</span> others<span class=\"token punctuation\">:</span> <span class=\"token string\">'value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>会报错的原因是，前面的 <code class=\"language-text\">{ value } =</code>，如果不加上括号，会被当成一般的代码块（Block），而不是一个解构的对象（Object），因此解析语法树的时候，在 <code class=\"language-text\">=</code> 这里就报错了（<code class=\"language-text\">Uncaught SyntaxError: Unexpected token &#39;=&#39;</code>）。注：如果不加最后的 <code class=\"language-text\">;</code>，语法也是正确的。</p>\n<p>更多相关的相关介绍，可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring\">MDN</a>。</p>","frontmatter":{"date":"2019-11-07","title":"Object Deconstructing without Declaration","category":"JavaScript"}}},{"node":{"id":"04dc3c68-fa9d-535f-94d9-f7a404f1d2dc","html":"<p>在 TC39 将 <a href=\"https://github.com/tc39/proposal-optional-chaining/\">Optional Chaining</a> 转移到 Stage 3 之后，TypeScript 在 3.7 版本中也带来了对应的 Optional Chaining 功能。总体上，TypeScript 的 Optional Chaining 功能和 JavaScript 的提案是保持一致的。总结来说，就是：</p>\n<blockquote>\n<p>如果属性值是 <code class=\"language-text\">undefined</code> 或者 <code class=\"language-text\">null</code>，就会直接返回 <code class=\"language-text\">undefined</code>，否则会进一步获取真实的属性值。</p>\n</blockquote>\n<p>在 <a href=\"https://www.typescriptlang.org/play/index.html\">TypeScript Playground</a> 中可以尝试一下这个新的功能。以下面这段 TypeScript 为例：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>bar<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>最终会被转译成下面的这段 JavaScript：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> _a<span class=\"token punctuation\">,</span> _b<span class=\"token punctuation\">,</span> _c<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_a <span class=\"token operator\">=</span> foo<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _a <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span>\n  <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">(</span>_b <span class=\"token operator\">=</span> _a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _c <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span>\n    <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span>\n    <span class=\"token function\">_c</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>_b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>几点简单的说明：</p>\n<ol>\n<li>即使值是 <code class=\"language-text\">null</code>，最终返回的结果也会是 <code class=\"language-text\">undefined</code>（上面代码中是 <code class=\"language-text\">void 0</code>，是等价的）；</li>\n<li>只有 <code class=\"language-text\">null</code> 和 <code class=\"language-text\">undefined</code> 的情况会被直接返回。这一点，和之前 <code class=\"language-text\">foo &amp;&amp; foo.bar</code> 这样的写法是有区别的。主要是 JavaScript 对哪些值是 falsy 的判断，范围会比 <code class=\"language-text\">null</code> &#x26; <code class=\"language-text\">undefined</code> 更广，还包括了 <code class=\"language-text\">NaN</code>，<code class=\"language-text\">0</code>，<code class=\"language-text\">false</code> 等；</li>\n<li>Optional Chaining 在函数调用中也是可以用的，写法是 <code class=\"language-text\">xx?.()</code>，如果不存在，函数不会调用，而是直接返回 <code class=\"language-text\">undefined</code>；</li>\n<li>Optional Chaining 也可以使用如下的写法：<code class=\"language-text\">foo?.[0]</code>， <code class=\"language-text\">foo?.[&#39;var-name&#39;]</code> 或 <code class=\"language-text\">foo?.[variableName]</code></li>\n</ol>\n<p>官方的发布介绍文档见<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#optional-chaining\">这里</a>。</p>","frontmatter":{"date":"2019-11-06","title":"Optional Chaining in TypeScript","category":"TypeScript"}}},{"node":{"id":"4c12371e-1261-52ed-8522-aacc2f3a7626","html":"<p><code class=\"language-text\">console.assert</code> API 可以用于判断某个条件是否满足，并在不满足的时候，在 Console 里打印出相关的数据。整体 API 和 <code class=\"language-text\">console.error</code> 比较类似，但是第一个参数是一个判断条件。整个调用，只会在第一个参数是 falsy 值的时候，才会将后面的数据打印出来。打印的方式和 <code class=\"language-text\">console.error</code> 类似，输出的是 error 信息。需要注意的一点是，根据 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Console/assert\">MDN</a> 的描述，在 Node.js 10 版本前，除了输出之外，还会抛出一个 <code class=\"language-text\">AssertionError</code>。这个行为是错误的，console API 不应该影响主流程的代码，Node.js 在 10 修复了问题。</p>\n<p>下面是一段示例代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'before'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'incorrect with error message'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'after'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出的结果是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">before\nincorrect with error message\nafter</code></pre></div>\n<p>其中，<code class=\"language-text\">incorrect with error message</code> 这一条，还会额外输出调用的堆栈信息，方便调试。</p>\n<p>总结来说，在代码中实现类似 Chrome 中 conditional breakpoint，使用 <code class=\"language-text\">console.assert</code> 是一个不错的选择：只在出现问题的时候打印必要的信息，可以尽可能的减少对 Console 输出的污染。</p>","frontmatter":{"date":"2019-11-05","title":"console.assert","category":"JavaScript"}}},{"node":{"id":"df525546-37d6-5170-90fd-2fe8e78bc734","html":"<p><code class=\"language-text\">console.trace</code> API 支持可选参数，输出的效果和 <code class=\"language-text\">console.log</code> / <code class=\"language-text\">console.info</code> 类似。但是除了输出参数指定的内容之外，还会连带将当前的调用堆栈一起输出。可以看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Console/trace\">MDN</a> 中给出的一个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">trace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出的结果类似：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">bar\nfoo\n&lt;anonymous&gt;</code></pre></div>\n<p>其中，<code class=\"language-text\">&lt;anonymous&gt;</code> 是因为 <code class=\"language-text\">foo</code> 函数是在 console 中直接运行的。当然，这个只能在调试阶段进行代码的检查。如果需要在线上环境，对可能出问题的地方收集调用堆栈信息，直接使用 <code class=\"language-text\">console.trace</code> 就不满足需求了。可以转而使用 Error 中的 stack 字段：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> error <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出结果类似：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">Error\n    at bar (&lt;anonymous&gt;:3:19)\n    at foo (&lt;anonymous&gt;:6:3)\n    at &lt;anonymous&gt;:9:1</code></pre></div>","frontmatter":{"date":"2019-11-04","title":"console.trace","category":"JavaScript"}}},{"node":{"id":"0e49e733-98a8-5e79-bcb5-c4ef0b27aaf8","html":"<p>在 Node.js 中，可以通过使用 Performance API 来对 <code class=\"language-text\">require</code> 模块的性能进行检测。这里的 Performance 模块，是 Node.js 根据 <a href=\"https://w3c.github.io/performance-timeline/\">W3C Performance Timeline 规范</a>，实现的一套和 Web 相同的 API 接口集合。一般的时间测量，可以通过 <code class=\"language-text\">Performance.mark</code> 和 <code class=\"language-text\">Performance.measure</code> 的组合来进行，使用的方法大体上和 Web 中一致（但是需要使用 <code class=\"language-text\">PerformanceObserver</code> 来获取测量的结果，这一点和 Web 不太相同，具体可以参考官方的<a href=\"https://nodejs.org/api/perf_hooks.html\">文档</a>）。</p>\n<p>和 Web 不同的是，在 Node.js 的 Performance 模块中，还提供了一个 <a href=\"https://nodejs.org/api/perf_hooks.html#perf_hooks_performance_timerify_fn\">timerify</a> 的接口，可以简便的对一个函数进行封装，从而测量出这个函数的实际调用时间。</p>\n<p>有了这个接口，就可以很容易的测量 Node.js 中加载模块的耗时了。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">,</span>\n  PerformanceObserver\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'perf_hooks'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> mod <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'module'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmod<span class=\"token punctuation\">.</span><span class=\"token class-name\">Module</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>require <span class=\"token operator\">=</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">timerify</span><span class=\"token punctuation\">(</span>mod<span class=\"token punctuation\">.</span><span class=\"token class-name\">Module</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>require<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> obs <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PerformanceObserver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">list</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> entries <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">getEntries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  fs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./profile.json'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>entries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  obs<span class=\"token punctuation\">.</span><span class=\"token function\">disconnect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobs<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  entryTypes<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'function'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Module.require'</span><span class=\"token punctuation\">,</span>\n  buffered<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里有几点可以说明一下：</p>\n<ol>\n<li><code class=\"language-text\">mod.Module.prototype.require</code> 被 <code class=\"language-text\">timerify</code> 之后，所有模块在 <code class=\"language-text\">require</code> 的时候，都会使用被 <code class=\"language-text\">timerify</code> 过的版本；</li>\n<li>PerformanceObserver 的作用是获取 entries 的结果；</li>\n<li><code class=\"language-text\">obs.disconnect</code> 用于解除连接，不再进行后续的接听；</li>\n<li><code class=\"language-text\">obs.observer</code> 设置 <code class=\"language-text\">entryTypes: [&#39;function&#39;]</code>，确保这里 <code class=\"language-text\">timerify</code> 的结果都可以被获取到；</li>\n<li><code class=\"language-text\">obs.observer</code> 中设置 <code class=\"language-text\">buffered: true</code>，确保 observer 的回调函数不会被立刻执行，而是用 <code class=\"language-text\">setImmediate</code> 延迟调用。这样的好处是，一次 <code class=\"language-text\">require</code> 后，该模块的调用时间和该模块内部调用子模块的耗时都会一次性通过回调函数返回。（注：默认这里的值是 <code class=\"language-text\">false</code>，见<a href=\"https://nodejs.org/docs/latest-v10.x/api/perf_hooks.html#perf_hooks_performanceobserver_observe_options\">文档</a>）;</li>\n<li>官方给出的示例，还 <code class=\"language-text\">timerify</code> 了 <code class=\"language-text\">require</code> 函数（见<a href=\"https://nodejs.org/api/perf_hooks.html#perf_hooks_measuring_how_long_it_takes_to_load_dependencies\">这里</a>），这样做会导致当前模块中 <code class=\"language-text\">require</code> 的调用，生成两份 Performance 数据（一份来自 <code class=\"language-text\">require</code>，一份来自 <code class=\"language-text\">Module.require</code>）。出于精简的考虑，上面的示例代码中去掉了对 <code class=\"language-text\">require</code> 函数的 <code class=\"language-text\">timerify</code>。</li>\n</ol>\n<p>在上面的示例代码中，最终得到的结果，存放在了一个 JSON 文件内，大体的格式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"0\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"required-module-name\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Module.require\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"entryType\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"startTime\"</span><span class=\"token operator\">:</span> <span class=\"token number\">7397.399892</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"duration\"</span><span class=\"token operator\">:</span> <span class=\"token number\">112.681678</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>这里，<code class=\"language-text\">0</code> 表示第一个参数的值，对于 <code class=\"language-text\">require</code> 来说就是具体引用的模块的名称/地址；<code class=\"language-text\">name</code> 表示是哪个函数的调用，在示例中就是被 <code class=\"language-text\">timerify</code> 过的 <code class=\"language-text\">Module.require</code> 函数；<code class=\"language-text\">entryType</code> 是固定的 <code class=\"language-text\">function</code>，因为这个值是通过 <code class=\"language-text\">timerify</code> 拿到的；<code class=\"language-text\">startTime</code> 和 <code class=\"language-text\">duration</code> 分别表示调用开始的时间以及实际调用的耗时。</p>","frontmatter":{"date":"2019-11-03","title":"Require Performance in Node.js","category":"Node.js"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"startInMonth":"2019-11-01","endInMonth":"2019-11-31","time":"2019-11","previous":"2019-10","next":"2019-12"}}}