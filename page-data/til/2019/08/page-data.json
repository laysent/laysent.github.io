{"componentChunkName":"component---src-templates-til-per-month-js","path":"/til/2019/08","webpackCompilationHash":"687e338135c47159cd63","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"f6b6d594-d2fb-5935-874c-7f6b24cea873","html":"<p>相比于 <code class=\"language-text\">scp</code>，<code class=\"language-text\">rsync</code> 命令可以在 SSH 拷贝的时候提供更多的灵活性，比如只拷贝新修改的或未存在的文件。</p>\n<p>一个简单的拷贝命令如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rsync</span> -auv /local/folder host:/remote/folder</code></pre></div>\n<p>这里，<code class=\"language-text\">-a</code> 表示拷贝所有的文件（包括子文件夹中的），<code class=\"language-text\">-u</code> 表示只拷贝修改时间更新的部分，<code class=\"language-text\">-v</code> 则会将结果输出到 stdin 中方便查看。类似的，还可以使用 <code class=\"language-text\">--ignore-existing</code> 来要求 <code class=\"language-text\">rsync</code> 只拷贝新的文件，忽略已经存在的部分。</p>\n<p>然而在实际使用的过程中，<code class=\"language-text\">rsync</code> 有如下报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Permission denied, please try again.\nrsync: connection unexpectedly closed (0 bytes received so far) [sender]\nrsync error: error in rsync protocol data stream (code 12) at io.c(235) [sender=3.1.2]</code></pre></div>\n<p>如果换同样的 SSH 配置，使用 <code class=\"language-text\">scp</code> 就不会有类似的报错，可见本身并不是 SSH 登陆账户权限的问题。这里的 Permission denied 报错非常的具有误导性。实际上，更可能的情况是 <code class=\"language-text\">rsync</code> 无法在远程主机上找到，需要通过 <code class=\"language-text\">--rsync-path</code> 参数手动指定。</p>\n<p>首先，可以先 SSH 到远程主机上，确认 <code class=\"language-text\">rsync</code> 本身是存在的：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rsync</span> --help</code></pre></div>\n<p>接着，可以通过 <code class=\"language-text\">type</code> 命令确认 <code class=\"language-text\">rsync</code> 的实际位置：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">type</span> -a <span class=\"token function\">rsync</span></code></pre></div>\n<p>这里，假设输出的结果是 <code class=\"language-text\">/bin/rsync</code>，那么，可以将原先的 <code class=\"language-text\">rsync</code> 命令改写为：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rsync</span> -auv /local/folder host:/remote/folder --rsync-path<span class=\"token operator\">=</span>/bin/rsync</code></pre></div>\n<p>再次运行就不会报错了。</p>\n<p><a href=\"https://superuser.com/questions/1017697/how-can-rsync-fail-due-to-missing-permissions-if-remote-login-occurs-with-root\">参考文档</a></p>","frontmatter":{"date":"2019-08-05","title":"Permission Denied for Rsync","category":"Bash"}}},{"node":{"id":"bb00bd56-438b-5e03-926d-cb9348da2b4d","html":"<p>在 C 编程中，经常会用到 <code class=\"language-text\">Makefile</code> 来对源代码进行编译。一个简单的 <code class=\"language-text\">Makefile</code> 如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"makefile\"><pre class=\"language-makefile\"><code class=\"language-makefile\"><span class=\"token symbol\">out</span><span class=\"token punctuation\">:</span> input.c\n  <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> input.c -o out -Wall -Wextra -std<span class=\"token operator\">=</span>c99</code></pre></div>\n<p>这里，第一行的 <code class=\"language-text\">out: input.c</code> 表示 <code class=\"language-text\">make</code> 应该根据输入 <code class=\"language-text\">input.c</code> 来产出 <code class=\"language-text\">out</code> 这个文件。</p>\n<p>第二行的 <code class=\"language-text\">$(CC)</code> 会由 <code class=\"language-text\">make</code> 替换成本机的 cc 程序（即 <strong>c</strong> <strong>c</strong>ompiler）；后面跟着的是 <code class=\"language-text\">cc</code> 编译会用到的参数，包括输入源文件 <code class=\"language-text\">input.c</code>，输出文件 <code class=\"language-text\">out</code>，编译输出所有的 Warning（<code class=\"language-text\">-Wall</code> 即 <strong>W</strong>arning <strong>all</strong>，<code class=\"language-text\">-Wextra</code> 即 <strong>W</strong>arning <strong>extra</strong>），同时指定使用 <a href=\"https://en.wikipedia.org/wiki/C99\">C99</a> 标准来编译 C 代码（和 <a href=\"https://en.wikipedia.org/wiki/ANSI_C\">ANSI C</a> 相比，C99 允许在函数的任意位置定义变量，而不是必须在顶部）。</p>\n<p>运行 <code class=\"language-text\">make</code> 命令，程序会查找当前目录下的 <code class=\"language-text\">Makefile</code> 函数，读取其中的配置，根据输入输出的要求，查找文件，然后再选择编译。</p>\n<p>第一次编译，程序会用 <code class=\"language-text\">input.c</code> 编译出一个 <code class=\"language-text\">out</code> 文件来。</p>\n<p>在 <code class=\"language-text\">input.c</code> 没有修改的情况下，如果再运行一次 <code class=\"language-text\">make</code> 命令，会得到如下的输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">make: `out` is update to date.</code></pre></div>\n<p>这里，<code class=\"language-text\">make</code> 程序并没有通过任何外部文件的方式记录编译的情况。判断是否需要编译完全依赖于系统默认的文件功能，即简单的比较 <code class=\"language-text\">input.c</code> 和 <code class=\"language-text\">out</code> 两个文件的最后修改时间。如果 <code class=\"language-text\">out</code> 的最后修改时间比 <code class=\"language-text\">input.c</code> 要晚，就认为 <code class=\"language-text\">out</code> 是最新的，不再重复编译；如果 <code class=\"language-text\">input.c</code> 的最后修改时间晚于 <code class=\"language-text\">out</code> 的时间，或是 <code class=\"language-text\">out</code> 压根就不存在，那么 <code class=\"language-text\">make</code> 就会执行 <code class=\"language-text\">Makefile</code> 中配置的编译命令。</p>\n<p>可以通过以下方式欺骗 <code class=\"language-text\">Makefile</code> 来检查这一行为：</p>\n<ol>\n<li>修改一下 <code class=\"language-text\">input.c</code> 并保存</li>\n<li>删除 <code class=\"language-text\">out</code> 文件，然后用 <code class=\"language-text\">touch</code> 命令创建一个空的 <code class=\"language-text\">out</code> 文件。因为是先修改，再创建，所以 <code class=\"language-text\">out</code> 的创建时间会晚于 <code class=\"language-text\">input.c</code></li>\n<li>尝试执行 <code class=\"language-text\">make</code> 命令，会发现提示 <code class=\"language-text\">out</code> 已经是最新的，并没有执行真正的编译命令（尽管这里 <code class=\"language-text\">out</code> 并不是通过 <code class=\"language-text\">make</code> 编译出来的）</li>\n</ol>","frontmatter":{"date":"2019-08-04","title":"How Makefile works","category":"Bash"}}},{"node":{"id":"5017cac8-c3ff-523d-bee3-2831eaad1c50","html":"<p>在命令行中，一个命令会有一个返回数值，<code class=\"language-text\">0</code> 代表正确运行；如果命令返回了非 <code class=\"language-text\">0</code> 数据，则代表命令运行出现了错误。</p>\n<p>比如，如果 <code class=\"language-text\">Jest</code> 命令跑单元测试出现了错误，那么就会返回一个非 <code class=\"language-text\">0</code> 的值。运用 <code class=\"language-text\">set -e</code> 可以让 Bash 在遇到非零返回的命令行之后即停止，不再运行接下去的命令。</p>\n<p>那么，该如何确定之前的命令是否返回了 <code class=\"language-text\">0</code> 呢？</p>\n<p>可以简单的使用如下的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token variable\">$?</span></code></pre></div>\n<p>这里的 <code class=\"language-text\">$?</code> 就是上一个命令返回的数值。如果上一条命令执行成功，那么这里应该输出 <code class=\"language-text\">0</code>。</p>","frontmatter":{"date":"2019-08-02","title":"Check Exit Code of Command","category":"Bash"}}},{"node":{"id":"cd1eb582-4609-5413-b31d-1454b20b7d96","html":"<p>在写 CI 脚本的时候，希望可以在脚本执行失败之后终止后续的所有操作。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token string\">\"start\"</span>\n<span class=\"token function\">yarn</span> <span class=\"token function\">test</span>\n<span class=\"token keyword\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>如果 <code class=\"language-text\">yarn test</code> 这个命令失败了，希望不执行 <code class=\"language-text\">echo &quot;end&quot;</code> 语句。然而通过执行上面的代码，会发现默认是执行的。如果希望不执行这个操作，有几种思路：</p>\n<p>第一种，是用 <code class=\"language-text\">&amp;&amp;</code> 将语句串联起来，比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token string\">\"start\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">yarn</span> <span class=\"token function\">test</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>这样的方案，缺点是比较的麻烦。一旦东西比较多，就很难保证代码的可读性了。</p>\n<p>第二种方案，是使用 <code class=\"language-text\">set -e</code>，脚本改为：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">set</span> -e\n<span class=\"token keyword\">echo</span> <span class=\"token string\">\"start\"</span>\n<span class=\"token function\">yarn</span> <span class=\"token function\">test</span>\n<span class=\"token keyword\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>如此一来，脚本在语句执行失败（Exit Code 不是 0）之后就会退出，不会执行接下去的脚本。</p>\n<p><a href=\"http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#The-Set-Builtin\">参考文档</a></p>","frontmatter":{"date":"2019-08-01","title":"Exit when Command Fail","category":"Bash"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"startInMonth":"2019-08-01","endInMonth":"2019-08-31","time":"2019-08","previous":"2019-07","next":null}}}