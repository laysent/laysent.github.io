{"componentChunkName":"component---src-templates-til-per-month-js","path":"/til/2019/12","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"ddf203aa-1bf8-5e71-9ad4-a9dbe9bd9530","html":"<p>在 JavaScript 中，直接定义一个对象（Object），性能上不远如定义一个 <code class=\"language-text\">JSON.parse()</code> 的表达式。具体来说，下面的两行，<code class=\"language-text\">JSON.parse</code> 的表达式会有更好的性能表现：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> slow <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> foo<span class=\"token punctuation\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> bar<span class=\"token punctuation\">:</span> <span class=\"token number\">1337</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fast <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token string\">'{\"foo\":42,\"bar\":1337}'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>同样的效果，但是在 JavaScript 引擎中的表现却差别很大。根据<a href=\"https://github.com/GoogleChromeLabs/json-parse-benchmark\">这里</a>给出的测试数据，<code class=\"language-text\">JSON.parse</code> 的速度是直接写对象速度的 1.7 倍。而且这不仅仅只是 V8 表现上的不同，在各类 JavaScript 引擎上都有类似的表现，性能差异均非常明显（<a href=\"https://developer.apple.com/documentation/javascriptcore\">JavaScriptCore</a> 的性能差异可以到两倍）。</p>\n<p>这里差异的主要原因在于，引擎在解析时候算法复杂度有着巨大的差异。简单来说，JSON 的数据结构是非常简单且固定的，因而在解析的时候可以有更好的表现。这种简单体现在以下几个方面：</p>\n<ol>\n<li>JSON 的数据支持类型不多，只有字符串，数组，数字，NULL，对象这几种；相比之下，JavaScript 中一个对象的支持类型非常的复杂，情况更多；</li>\n<li>从抽象语法树（AST）的角度看，<code class=\"language-text\">JSON.parse</code> 的情况比单纯写一个 JavaScript 对象要简单的多。对于前者来说，就是一个 CallExpression 和一个 StringLiteral；而对于一个 JavaScript 对象来说，涉及到大量的 ObjectExpression，当中可能还包含 StringLiteral，NumericLiteral，Identifier 等等；</li>\n<li>JSON 的解析是上下文无关的；而 JavaScript 对象的解析却需要结合当前的上下文（context）来确定；</li>\n</ol>\n<p>举一个例子来说明：假设有这样一个 JavaScript 代码片段：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> y <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> x <span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里的 <code class=\"language-text\">x</code> 代表什么含义，其实有非常多的可能性，比如：</p>\n<ul>\n<li><code class=\"language-text\">const y = ({ x })</code>，此时 <code class=\"language-text\">x</code> 的值和上下文中的 <code class=\"language-text\">x</code> 变量是相关的，定义是一个 JavaScript 对象；</li>\n<li><code class=\"language-text\">const y = ({ x } = { x: 2 })</code>，此时 <code class=\"language-text\">x</code> 和上下文是相关的，但定义的是一个赋值语句，而不是对象（根据语法，对 <code class=\"language-text\">const</code> 二次赋值导致语法错误）；</li>\n<li><code class=\"language-text\">const y = ({ x }) =&gt; x;</code>，此时 <code class=\"language-text\">x</code> 的值和上面的 <code class=\"language-text\">x</code> 无关，是一个函数的参数；</li>\n</ul>\n<p>换句话说，当 JavaScript 引擎在解析一个 JavaScript 对象的时候，需要考虑很多的可能性，在解析的过程中很可能无法确定当前的类型，甚至连语法是否正确也不能确定。但反观 JSON，定义就简单的多，在解析的当下，引擎就可以很清楚的知道当前的内容是一个数组，还是一个对象，亦或是有语法错误。</p>\n<p>除了上述提到的性能比较数据之外，<a href=\"https://joreteg.com/blog/improving-redux-state-transfer-performance\">这里</a>还有一份针对 Redux 应用的优化分析。数据显示，使用 <code class=\"language-text\">JSON.parse</code> 调用之后 TTI (Time To Interactive) 时间缩短了 0.74s (18%)。考虑到整个改动是非常“简单”的，这一性能提升显得非常客观。</p>\n<p>这里之所以说改动是非常“简单”的，是因为整个优化思路非常的明确，完全可以通过对应的工具在编译时完成。目前开源社区已经提供了各类相关的工具，可以直接使用，列举一些如下：</p>\n<ul>\n<li>Webpack（<a href=\"https://github.com/webpack/webpack/releases/tag/v4.35.3\">v4.35.3</a> 或以上）默认会将 JSON 打包成 <code class=\"language-text\">JSON.parse()</code>；使用 <code class=\"language-text\">json-loader</code> 可以去掉这一优化（具体见这个 <a href=\"https://github.com/webpack/webpack/pull/9349\">Pull Request</a>）；</li>\n<li>一些 Babel Plugin 支持将满足要求的 JavaScript 对象转化成 <code class=\"language-text\">JSON.parse</code> 语法，比如 <a href=\"https://github.com/nd-02110114/babel-plugin-object-to-json-parse\">babel-plugin-object-to-json-parse</a> 或 <a href=\"https://github.com/keyz/babel-plugin-transform-optimize-object-literal\">babel-plugin-transform-optimize-object-literal</a>。</li>\n</ul>","frontmatter":{"date":"2019-12-03","title":"Cost of parsing JSON","category":"JavaScript"}}},{"node":{"id":"1f47e54e-3226-5831-b830-c394c36ddda6","html":"<p>Node.js 的 Docker 有基于 Alpine 的版本。在这个 Docker 中使用 <a href=\"https://github.com/develar/7zip-bin\">7zip-bin</a> 库的时候遇到了错误，无法正常启动。</p>\n<p>一个简单的重现 <code class=\"language-text\">Dockerfile</code> 可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>10<span class=\"token punctuation\">-</span>alpine\n\n<span class=\"token keyword\">RUN</span> mkdir <span class=\"token punctuation\">-</span>p example &amp;&amp; \\\n  cd example &amp;&amp; \\\n  yarn init <span class=\"token punctuation\">-</span>y &amp;&amp; \\\n  yarn add 7zip<span class=\"token punctuation\">-</span>bin &amp;&amp; \\\n  mkdir /lib64 &amp;&amp; \\\n  ln <span class=\"token punctuation\">-</span>s /lib/libc.musl<span class=\"token punctuation\">-</span>x86_64.so.1 /lib64/ld<span class=\"token punctuation\">-</span>linux<span class=\"token punctuation\">-</span>x86<span class=\"token punctuation\">-</span>64.so.2\n\n<span class=\"token keyword\">ADD</span> run.sh /run.sh\n\n<span class=\"token keyword\">RUN</span> chmod +x /run.sh\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"/run.sh\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>其中，<code class=\"language-text\">run.sh</code> 可以写：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> example\n<span class=\"token variable\"><span class=\"token variable\">$(</span>node -e \"console.log<span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">(</span><span class=\"token string\">'7zip-bin'</span><span class=\"token punctuation\">)</span>.path7za<span class=\"token variable\">)</span></span>\"<span class=\"token punctuation\">)</span></code></pre></div>\n<p>报错的内容是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/run.sh: line 2: /example/node_modules/7zip-bin/linux/x64/7za: not found</code></pre></div>\n<p>通过进入 Docker 内部观察不难发现，<code class=\"language-text\">/example/node_modules/7zip-bin/linux/x64/7za</code> 这个文件实际是真实存在的，但是在使用的时候系统却报错 <code class=\"language-text\">not found</code>。造成这一问题的原因，可能是动态库缺失。</p>\n<p>通过 <code class=\"language-text\">ldd</code> 命令可以列出动态库依赖关系（<a href=\"https://linux.die.net/man/1/ldd\">文档</a>）：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">ldd /example/node_modules/7zip-bin/linux/x64/7za</code></pre></div>\n<p>输出结果是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibpthread.so.0 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibstdc++.so.6 =&gt; /usr/lib/libstdc++.so.6 (0x7febe52b9000)\nlibm.so.6 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibgcc_s.so.1 =&gt; /usr/lib/libgcc_s.so.1 (0x7febe52a5000)\nlibc.so.6 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)</code></pre></div>\n<p>注意到缺少了 <code class=\"language-text\">/lib64/ld-linux-x86-64.so.2</code> 这个动态库，因此导致了 <code class=\"language-text\">7zip-bin</code> 这个库无法正常使用。造成这个的原因是，Alpine 使用的是 <a href=\"https://www.musl-libc.org/\">musl</a>，而 <code class=\"language-text\">7zip-bin</code> 使用的二进制文件是基于 glibc 编译出来的。要解决这个问题，有两种思路：</p>\n<ol>\n<li>在 Alpine 中安装 libc 的兼容库：<code class=\"language-text\">RUN apk add --no-cache libc6-compat</code>；</li>\n<li>或者，<code class=\"language-text\">ln -s /lib/libc.musl-x86_64.so.1 /lib/ld-linux-x86-64.so.2</code> 将 musl 的版本软连过去，直接让 <code class=\"language-text\">7zip-bin</code> 的二进制使用</li>\n</ol>\n<p>当然，最佳的方案是不使用 <code class=\"language-text\">7zip-bin</code> 中的 pre-build 版本，而改用 Alpine 的 <a href=\"https://pkgs.alpinelinux.org/package/edge/main/x86/p7zip\">p7zip</a> 版本。用 Alpine 的包管理器安装好 <code class=\"language-text\">pz7ip</code> 之后（<code class=\"language-text\">apk add p7zip</code>），使用类似下面的代码直接替换脚本就好了：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cp</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">type</span> -p 7za<span class=\"token variable\">)</span></span> <span class=\"token variable\"><span class=\"token variable\">$(</span>node -p <span class=\"token string\">\"require('7zip-bin').path7za\"</span><span class=\"token variable\">)</span></span></code></pre></div>\n<section><h2>参考链接</h2><ul>\n<li>在 7zip-bin issue 中的<a href=\"https://github.com/develar/7zip-bin/issues/8\">相关讨论</a></li>\n<li>重现的配置代码 <a href=\"https://gist.github.com/laysent/b12faceac4bcf10bee04aabfa505c244\">gist</a></li>\n<li>node-gyp 在 Alpine 中也可能会遇到类似的问题，在<a href=\"https://medium.com/devgorilla/node-gyp-support-in-alpine-linux-9374c6191140\">这里</a>可以找到相关的讨论</li>\n</ul></section>","frontmatter":{"date":"2019-12-02","title":"7zip-bin in Alpine Docker","category":"Docker"}}},{"node":{"id":"fd022b7a-07a5-588c-83eb-4dc5e5ec807c","html":"<p><code class=\"language-text\">arguments.callee</code> 是一个不应该被使用的 API，在严格模式下使用会直接报错。这里仅仅是作为了解，记录一下该 API 的作用。</p>\n<p>在早期的 JavaScript 版本中，不允许写带名字的函数表达式，在这种情况下，如果需要做递归调用，就无法显式得指明需要调用的函数名称。<code class=\"language-text\">arguments.callee</code> 这个值，指向了当前被调用的函数本身，因此可以在匿名函数递归调用中被使用。举例来说，在早期的 JavaScript 中，<code class=\"language-text\">Array.prototype.map</code> 函数给定的回调函数只能是匿名的，如果要实现一个阶乘函数，只能这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">num</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> arguments<span class=\"token punctuation\">.</span><span class=\"token function\">callee</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> num<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>然而，<code class=\"language-text\">arguments.callee</code> 的调用会导致 <code class=\"language-text\">this</code> 的指向出现问题（具体见 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee\">MDN</a>），使用起来比较危险。</p>\n<p>在 ECMAScript 3 中已经支持了带函数名的表达式，因此上面的代码可以简单的改写为一下这种正常的写法：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> num<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>换句话说，只需要给函数指定名称，就可以规避绝大多数的 <code class=\"language-text\">arguments.callee</code> 使用了（注：匿名函数/箭头函数无法指定名称，但同时规范也明确了匿名函数中没有 <code class=\"language-text\">arguments</code>）。</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee\">MDN</a> 给出了一个 <code class=\"language-text\">arguments.callee</code> 无法替换的场景：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">sIdentity</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> oPerson <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">'alert(arguments.callee.identity);'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  oPerson<span class=\"token punctuation\">.</span>identity <span class=\"token operator\">=</span> sIdentity<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> oPerson<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> john <span class=\"token operator\">=</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token string\">'John Smith'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">john</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里的函数 <code class=\"language-text\">oPerson</code> 是通过 <code class=\"language-text\">new Function</code> 创建的。在字符串内无法“得知”函数会被赋值的名称，因此只能通过 <code class=\"language-text\">arguments.callee</code> 去获取。在某些非常特殊的业务场景中，可能会有需求将某些表达式通过字符串进行存储，并通过 <code class=\"language-text\">new Function</code> 构建执行。这种时候，使用 <code class=\"language-text\">arguments.callee</code> 获取数据类似于传参。当然，如果只是传参的需求，其实可以写成：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> script <span class=\"token operator\">=</span> <span class=\"token string\">'alert(arg.identity)'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">identity</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> closure <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'const arg = arguments[0];'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">return function () { </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>script<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> }</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">closure</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> identity <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> john <span class=\"token operator\">=</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token string\">'John Smith'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">john</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-12-01","title":"arguments.callee","category":"JavaScript"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"startInMonth":"2019-12-01","endInMonth":"2019-12-31","time":"2019-12","previous":"2019-11","next":null}}}