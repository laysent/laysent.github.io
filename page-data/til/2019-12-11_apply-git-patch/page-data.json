{"componentChunkName":"component---src-templates-til-js","path":"/til/2019-12-11_apply-git-patch","result":{"data":{"markdownRemark":{"id":"dd6397f0-93cc-5c70-af8e-6a02ee16d25b","html":"<p>在实际开发过程中，可能会遇到这样的问题：因为重构，一些文件从 A 目录移动到了 B 目录，而后又对文件内容做了修改。这时，如果希望将其中的某些修改（比如和安全相关的布丁）应用回重构前的代码，就显得比较困难了。直接通过 Git 进行 cherry-pick 并不顺利，因为具体修改的 commit 中并不包含文件目录移动的信息。</p>\n<p>可以简单使用下面的命令来构建一个场景：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> init<span class=\"token punctuation\">;</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"console.log('hello world');\"</span> <span class=\"token operator\">></span> origin.js<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> -A<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"first commit\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">git</span> checkout -b <span class=\"token string\">\"new_branch\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">mv</span> origin.js modified.js<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> -A<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"rename commit\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"console.log('hi')\"</span> <span class=\"token operator\">>></span> origin.js<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> -A<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"modify commit\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">git</span> checkout master<span class=\"token punctuation\">;</span></code></pre></div>\n<p>这时候，希望直接将 <code class=\"language-text\">new_branch</code> 中最后一个 commit cherry-pick 到 master 是比较困难的。</p>\n<p>针对这种情况，可以考虑使用 Git Patch 功能。首先将修改的部分生成 Patch 文件，然后手动将 Patch 中的目录映射关系处理正确，最终将修改后的 Patch 应用到重构前的某个旧版本中。</p>\n<section><h2>创建 Patch</h2><p><code class=\"language-text\">git diff</code> 命令输出的结果就是一个 Patch，可以简单的将输出的内容存储到文件中，就生成了一个当前未签入内容的 Patch 文件：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">diff</span> <span class=\"token operator\">></span> change.patch</code></pre></div><p>如果希望只是将部分修改的文件生成 Patch，可以先将需要的部分放入缓冲区中（<code class=\"language-text\">git add</code>），然后通过 <code class=\"language-text\">git diff --cached</code> 命令，仅针对缓冲区中的修改生成 Patch 文件。</p><p>以上这些生成的方案，比较适合为没有写权限的 Git 仓库提交修改的场景。直接将 Patch 文件通过 email 的形式发送，就可以进行修改的讨论了。</p><p>注：如果改动包含了二进制文件的修改，可以通过增加 <code class=\"language-text\">--binary</code> 命令来获取到这部分文件的修改 Patch。</p><p>针对已经签入的提交，也可以通过 <code class=\"language-text\">git format-patch</code> 或 <code class=\"language-text\">git show</code> 命令来生成 commit 对应的 Patch 文件。</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> show commit-id <span class=\"token operator\">></span> change.patch</code></pre></div><p>可以生成单个 commit 的 Patch 文件；如果希望生成一组 commit 的 Patch，可以使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> format-patch A<span class=\"token punctuation\">..</span>B</code></pre></div><p>上面的命令会生成为从 A 到 B 之间的所有 commit 生成对应的 Patch 文件（包含 B commit，但是不包含 A commit；如果需要包含 A，可以使用 <code class=\"language-text\">A^..B</code> 命令）。或者，如果希望将所有的改动合成到一个 Patch 文件中，可以使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> format-patch A<span class=\"token punctuation\">..</span>B --stdout <span class=\"token operator\">></span> changes.patch</code></pre></div><p>上面的 A 和 B 除了可以是 commit id 之外，也可以是 Branch 或者 Tag。</p></section>\n<section><h2>应用 Patch</h2><p>将生成的 Patch 文件应用到当前的代码中，只需要使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> apply change.patch</code></pre></div><p>Git 会将 Patch 中提到的修改应用到当前的项目中，但改动不会被自动提交；如果希望直接将 Patch 以 commit 的形式进行提交，可以直接使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> am change.patch</code></pre></div></section>\n<section><h2>关于 Patch</h2><p>Git 生成的 Patch 文件，除了提交作者、commit message 这些信息外，核心的部分是通过 <code class=\"language-text\">diff</code> 命令生成的修改内容。如果只是需要修改一下文件的位置，应该可以通过观察文件直接找到。更多关于 <code class=\"language-text\">diff</code> 命令生成的补丁文件的格式，可以参考 <a href=\"https://en.wikipedia.org/wiki/Diff\">Wikipedia</a> 中的相关描述。</p></section>","frontmatter":{"title":"Apply Git Patch","category":"Git","date":"2019-12-11"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"time":"2019-12-11","title":"Apply Git Patch","previous":{"time":"2019-12-10","title":"Cherry-pick Range of Git Commits"},"next":{"time":"2019-12-12","title":"Git Diff Filenames"}}}}