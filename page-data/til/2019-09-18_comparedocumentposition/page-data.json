{"componentChunkName":"component---src-templates-til-js","path":"/til/2019-09-18_comparedocumentposition","webpackCompilationHash":"d0c1c456129354e33ddb","result":{"data":{"markdownRemark":{"id":"36872891-c5a0-57ab-a5f7-a569c2473f52","html":"<p>在判断一个 DOM 节点是否包含另一个节点的时候，常常用到 <code class=\"language-text\">contains</code> 这个 API。在实际的使用从过程中，也经常会遇到这样的情况，需要判断 A 是否包含 B，返回是 <code class=\"language-text\">false</code>，但经过排查，发现其实 A 和 B 就是同一个节点。这种情况下，光用 <code class=\"language-text\">contains</code> API 就有点不够用了。同时，也暴露了这个 API 本身能力的局限性。</p>\n<p>在 DOM Level 3 的<a href=\"https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-compareDocumentPosition\">规范</a>中，定义了一个新的 API，<code class=\"language-text\">compareDocumentPosition</code>。相比于 <code class=\"language-text\">contains</code>，<code class=\"language-text\">compareDocumentPosition</code> 提供了更强大的判断结果。</p>\n<p><code class=\"language-text\">compareDocumentPosition</code> 这个 API 比较后会返回一个数字，通过二进制位的比较，可以用于判断两个节点之间的关系。假设调用的函数为 <code class=\"language-text\">A.compareDocumentPosition(B)</code>，那么返回值具体支持的类型如下：</p>\n<table>\n<thead>\n<tr>\n<th>常量名</th>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code></td>\n<td>1</td>\n<td>不在一个文档中</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_PRECEDING</code></td>\n<td>2</td>\n<td>B 在 A 之前</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_FOLLOWING</code></td>\n<td>4</td>\n<td>B 在 A 之后</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_CONTAINS</code></td>\n<td>8</td>\n<td>B 包含 A</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_CONTAINED_BY</code></td>\n<td>16</td>\n<td>A 包含 B</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code></td>\n<td>32</td>\n<td>A 和 B 的位置关系取决于具体的实现方式（不由规范确定）</td>\n</tr>\n</tbody>\n</table>\n<p>这里之所以使用二进制位表示位置关系，一个很重要的原因就是：API 有可能会一次性返回多个结果。举个例子，假设 <code class=\"language-text\">A.contains(B)</code> 返回 <code class=\"language-text\">true</code>。那么，在调用 <code class=\"language-text\">A.compareDocumentPosition(B)</code> 的时候，返回值是 <code class=\"language-text\">20</code>，也就是 <code class=\"language-text\">Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY</code> 的结果。换句话说，B 元素在文档中的位置在 A 的后面，同时 B 也是 A 的一个子元素。</p>\n<p>这里，<code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code> 表示两个节点不再同一个文档中，有几种可能的情况：</p>\n<ol>\n<li>A 和 B 中某一个存在于 iframe 中，因而两者不属于同一个文档（<code class=\"language-text\">A.ownerDocument !== B.ownerDocument</code>）；</li>\n<li>A 和 B 中某一个元素被删除了（或没有插入到 DOM 中），导致两者不属于同一个文档（可以通过 <code class=\"language-text\">A.parentElement</code> 和 <code class=\"language-text\">B.parentElement</code> 判断是否被删除，被删后就没有父元素了）</li>\n</ol>\n<p>另外，<code class=\"language-text\">DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code> 有两种情况：</p>\n<ol>\n<li>A 和 B 没有任何相同的 container，这种情况和 <code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code> 是等价的。换句话说，当有 <code class=\"language-text\">Node.DOCUMENT_POSITION_DISCONNECTED</code> 的时候，一定同时有 <code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code>；</li>\n<li>A 和 B 是同一个元素的两个属性值，这种情况下，谁先谁后是由具体实现决定的。比如，<code class=\"language-text\">Element.attributes</code> 返回一个 <code class=\"language-text\">NamedNodeMap</code>。根据<a href=\"https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1780488922\">规范</a> 的定义，<code class=\"language-text\">NamedNodeMap</code> 不维护一个具体的顺序，但同时提供使用 index 访问的 API。也就是说，<code class=\"language-text\">Element.attributes</code> 中的任意两个字段，是没有定义上的先后之分的（虽然可能通过不同的下标获取到）。具体来说：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// div = &lt;div id=\"id\" class=\"class>&lt;/div></span>\n<span class=\"token keyword\">const</span> attributes <span class=\"token operator\">=</span> div<span class=\"token punctuation\">.</span>attributes<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> attributes<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareDocumentPosition</span><span class=\"token punctuation\">(</span>attributes<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// result = 36</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，<code class=\"language-text\">compareDocumentPosition</code> 返回的结果是 <code class=\"language-text\">36</code>，即 <code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING</code>。因此，在实际使用 API 的时候，有必要检查是否有 <code class=\"language-text\">Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code> 这一位，如果有的话，其他的结果都可以忽略不计了。</p>\n<p>另外，如果 A 和 B 是同一个元素，那么返回的结果将是 <code class=\"language-text\">0</code>，因为 A 和 B 的关系不属于上面列出的任何一种情况。同时，也不难发现，只有当 A 和 B 是同一个元素的时候，才会出现返回值是 0 的情况。</p>","frontmatter":{"title":"compareDocumentPosition","category":"JavaScript","date":"2019-09-18"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"time":"2019-09-18","title":"compareDocumentPosition","previous":{"time":"2019-09-17","title":"Git Pull Rebase"},"next":{"time":"2019-09-19","title":"Babel JSX Improvement"}}}}