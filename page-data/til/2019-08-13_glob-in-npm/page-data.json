{"componentChunkName":"component---src-templates-til-js","path":"/til/2019-08-13_glob-in-npm","webpackCompilationHash":"d0c1c456129354e33ddb","result":{"data":{"markdownRemark":{"id":"82f9644e-2191-5f1f-9758-880c26b73c6d","html":"<p>在使用 stylelint 的时候，发现了一个有趣的问题：如果直接使用 stylelint 的 <code class=\"language-text\">bin</code> 文件对批量 LESS 文件进行检查，程序可以如预期的运行；但是如果把同样的命令写到 <code class=\"language-text\">package.json</code> 中，以 npm script 的方式进行运行，最终被检查的文件就少了很多，实际只有一个文件参与了检查。</p>\n<p>具体来说，<code class=\"language-text\">./node_modules/.bin/stylelint src/**/*.less</code> 这个命令可以检查所有的 LESS 文件，但是把 <code class=\"language-text\">stylelint src/**/*.less</code> 写到 <code class=\"language-text\">package.josn</code> 中之后，再运行却只检查了一个文件。</p>\n<p>通过检查 stylelint 的<a href=\"https://github.com/stylelint/stylelint/blob/master/docs/user-guide/cli.md\">文档</a>，发现官方在写命令的时候，写法和上述略有不同，为：<code class=\"language-text\">stylelint &quot;src/**/*.less&quot;</code>。</p>\n<p>经过排查问题，发现根源在于：<code class=\"language-text\">npm</code> 使用了 <code class=\"language-text\">sh</code> 来执行代码，而 <code class=\"language-text\">sh</code> 和 <code class=\"language-text\">zsh</code> 在解析 Glob 的时候，行为是不同的。</p>\n<p><code class=\"language-text\">npm</code>，包括其他 Linux 进程，在使用 shell 的时候，默认使用的都是 <code class=\"language-text\">sh</code>，除非有其他明确的指定。这意味着，即使当前正在使用的 shell 是 <code class=\"language-text\">zsh</code>，在运行 <code class=\"language-text\">npm</code> 命令的时候，还是默认使用了 <code class=\"language-text\">sh</code> 对脚本进行执行。也就是说，<code class=\"language-text\">./node_modules/.bin/stylelint src/**/*.less</code> 这个命令执行，使用的是当前打开的 shell 程序（比如 <code class=\"language-text\">zsh</code>）；而当这个命令写到 <code class=\"language-text\">package.json</code> 中，并以 npm script 的方式进行运行的时候，执行 shell 的就是 <code class=\"language-text\">sh</code> 了。</p>\n<p>使用不同的 shell 程序，难免就会在行为上造成不一致。这里的 Glob 解析就是一个例子。在 <code class=\"language-text\">zsh</code> 里面可以简单的做一个实验。执行如下的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ls</span> src/**/*.less</code></pre></div>\n<p>可以看到，<code class=\"language-text\">zsh</code> 给出了当前 <code class=\"language-text\">src</code> 目录下所有的 LESS 文件， 不管这个文件是在多深的子目录下；而如果先在 <code class=\"language-text\">zsh</code> 中执行 <code class=\"language-text\">sh</code> 或 <code class=\"language-text\">bash</code> 进入到 <code class=\"language-text\">sh</code> 或 <code class=\"language-text\">bash</code> 的工作环境中，再执行同样的命令，可以看到输出的结果可能就是不同的。实际上，对于 <code class=\"language-text\">sh</code> 来说，它本身并不识别 <code class=\"language-text\">**</code> 这个语法，这个表示在 <code class=\"language-text\">sh</code> 中会被简单的识别为 <code class=\"language-text\">*</code>，<code class=\"language-text\">src/**/*.less</code> 在 <code class=\"language-text\">sh</code> 中等价于 <code class=\"language-text\">src/*/*.less</code>。换句话说，在 <code class=\"language-text\">sh</code> 的环境中，上述命令只会寻找所有在 <code class=\"language-text\">src</code> 目录下一级子目录中的 LESS 文件，一旦层级大于一层，就不会被找到了。</p>\n<p>这也是为什么同样的命令，直接执行和在 npm 中执行会有差异的原因。</p>\n<p>最后，加上双引号 <code class=\"language-text\">stylelint &quot;src/**/*.less&quot;</code> 就可以解决这一问题的原因在于：一旦加上了双引号，这一个 Glob 就不会被 shell 直接解析，而是会以字符串的形式直接传递给 stylelint。（具体来说，如果不加双引号，shell 会先将 Glob 解析成一组具体的文件，stylelint 实际拿到的 <code class=\"language-text\">process.env.argv</code> 很可能会是一个很长的字符串数组，每一个元素都是一个具体的文件；而如果加上了双引号，stylelint 拿到的只有一个 Glob 表达式字符串。）有了这个 Glob 的字符串，stylelint 内部就可以使用相应的 package 来进行解析，从而得到一串具体的文件列表。因为使用了 stylelint 内部自带的 Glob 解析，就可以保证在不同的 shell 环境中都得到一致的结果了。</p>\n<p><a href=\"https://stackoverflow.com/questions/32017169/npm-glob-pattern-not-matching-subdirectories\">参考</a></p>","frontmatter":{"title":"Glob in NPM","category":"JavaScript","date":"2019-08-13"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"time":"2019-08-13","title":"Glob in NPM","previous":{"time":"2019-08-12","title":"Chrome DevTools Blackbox"},"next":{"time":"2019-08-14","title":"Replace All Substring"}}}}