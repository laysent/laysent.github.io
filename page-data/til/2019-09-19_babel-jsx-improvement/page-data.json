{"componentChunkName":"component---src-templates-til-js","path":"/til/2019-09-19_babel-jsx-improvement","webpackCompilationHash":"d0c1c456129354e33ddb","result":{"data":{"markdownRemark":{"id":"03867888-4df4-54ab-af0a-3ea92ffb495f","html":"<p>在 React 的开发中，需要在 Component 的 render 函数或是 Functional Component 的函数中，返回一个定义好的 JSX 内容，用于表示具体需要渲染出来的 UI 样式。Babel 或 TypeScript 会在编译时将这个对象转化成一个 JavaScript 可以理解的一般函数调用（具体调用的函数根据库的不同可能存在差异，对于 React 来说就是 <code class=\"language-text\">React.createElement</code> 函数，对于 Preact 来说则是 <code class=\"language-text\">h</code> 函数）。这个函数会在运行时被执行，并返回一个普通的 Object。React 拿到这个 Object 之后，就可以根据其中的内容来渲染出对应的 UI（根据具体执行的环境，这个步骤可能通过 React-DOM 或 React Native 来完成）。</p>\n<p>既然 JSX 的部分会被编译成普通的函数调用，并在运行时被反复执行，这里必然会有一些性能上的损耗。</p>\n<p>而在实际的开发中，存在着很多的组件，实际需要返回的 JSX 是固定不变的。比如说：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在上面这个例子中，实际上条件的第一种结果，返回的 JSX 是一个固定的值。手动的优化可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> loadingComponent <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> loadingComponent<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样，每次当 <code class=\"language-text\">loading = true</code> 的时候，都会直接返回 <code class=\"language-text\">loadingComponent</code>，而不需要反复执行 <code class=\"language-text\">React.createElement(Loading)</code> 这个函数去拿到最终的返回 Object。除了在运行时减少了重复计算，节省了时间和内存开销（这个在 re-render 非常频繁的时候有一定的优势），另一个好处是，React 可以通过比较返回的结果知道 Object 并没有发生变化，从而直接结束渲染的流程，不再进行接下来更深层次的渲染。</p>\n<p>这部分的操作，其实可以交给编译器去完成。Babel 有一个插件 <code class=\"language-text\">@babel/plugin-transform-react-constant-elements</code> 可以拿来做这方面的优化，具体的使用方式以及可能存在的问题可以参考<a href=\"https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements/\">文档</a>。</p>\n<p>当然，上面的优化依然存在小的瑕疵：因为把创建 Object 的操作提到了初始化的时候就直接进行了，如果存在大量类似的优化，会导致 JavaScript 初始运行的速度被减慢。大量的 Object 被事先创建了出来，而实际上这部分内容都远还没有到需要用的时候。一个更极致的优化可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> loadingComponent<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>loadingComponent<span class=\"token punctuation\">)</span> loadingComponent <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> loadingComponent<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这部分的操作就不是 Babel 插件原生支持的了。</p>\n<p>从目前的实际情况来看，生成 JSX 对应 Object 拖慢初始化的例子暂时还不存在（毕竟 <code class=\"language-text\">React.createElement</code> 的执行速度并不是非常慢，而且一个项目中的 JSX 数量也不会非常庞大）。如果有必要，可以 <a href=\"https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-react-constant-elements\">GitHub</a> 上提出 PR，按照类似上面提到的方式进行进一步的优化。</p>","frontmatter":{"title":"Babel JSX Improvement","category":"Build","date":"2019-09-19"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"time":"2019-09-19","title":"Babel JSX Improvement","previous":{"time":"2019-09-18","title":"compareDocumentPosition"},"next":{"time":"2019-09-22","title":"Git Worktree"}}}}