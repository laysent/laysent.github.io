{"componentChunkName":"component---src-templates-til-js","path":"/til/2019-12-03_cost-of-parsing-json","result":{"data":{"markdownRemark":{"id":"ddf203aa-1bf8-5e71-9ad4-a9dbe9bd9530","html":"<p>在 JavaScript 中，直接定义一个对象（Object），性能上不远如定义一个 <code class=\"language-text\">JSON.parse()</code> 的表达式。具体来说，下面的两行，<code class=\"language-text\">JSON.parse</code> 的表达式会有更好的性能表现：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> slow <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> foo<span class=\"token punctuation\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> bar<span class=\"token punctuation\">:</span> <span class=\"token number\">1337</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fast <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token string\">'{\"foo\":42,\"bar\":1337}'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>同样的效果，但是在 JavaScript 引擎中的表现却差别很大。根据<a href=\"https://github.com/GoogleChromeLabs/json-parse-benchmark\">这里</a>给出的测试数据，<code class=\"language-text\">JSON.parse</code> 的速度是直接写对象速度的 1.7 倍。而且这不仅仅只是 V8 表现上的不同，在各类 JavaScript 引擎上都有类似的表现，性能差异均非常明显（<a href=\"https://developer.apple.com/documentation/javascriptcore\">JavaScriptCore</a> 的性能差异可以到两倍）。</p>\n<p>这里差异的主要原因在于，引擎在解析时候算法复杂度有着巨大的差异。简单来说，JSON 的数据结构是非常简单且固定的，因而在解析的时候可以有更好的表现。这种简单体现在以下几个方面：</p>\n<ol>\n<li>JSON 的数据支持类型不多，只有字符串，数组，数字，NULL，对象这几种；相比之下，JavaScript 中一个对象的支持类型非常的复杂，情况更多；</li>\n<li>从抽象语法树（AST）的角度看，<code class=\"language-text\">JSON.parse</code> 的情况比单纯写一个 JavaScript 对象要简单的多。对于前者来说，就是一个 CallExpression 和一个 StringLiteral；而对于一个 JavaScript 对象来说，涉及到大量的 ObjectExpression，当中可能还包含 StringLiteral，NumericLiteral，Identifier 等等；</li>\n<li>JSON 的解析是上下文无关的；而 JavaScript 对象的解析却需要结合当前的上下文（context）来确定；</li>\n</ol>\n<p>举一个例子来说明：假设有这样一个 JavaScript 代码片段：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> y <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> x <span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里的 <code class=\"language-text\">x</code> 代表什么含义，其实有非常多的可能性，比如：</p>\n<ul>\n<li><code class=\"language-text\">const y = ({ x })</code>，此时 <code class=\"language-text\">x</code> 的值和上下文中的 <code class=\"language-text\">x</code> 变量是相关的，定义是一个 JavaScript 对象；</li>\n<li><code class=\"language-text\">const y = ({ x } = { x: 2 })</code>，此时 <code class=\"language-text\">x</code> 和上下文是相关的，但定义的是一个赋值语句，而不是对象（根据语法，对 <code class=\"language-text\">const</code> 二次赋值导致语法错误）；</li>\n<li><code class=\"language-text\">const y = ({ x }) =&gt; x;</code>，此时 <code class=\"language-text\">x</code> 的值和上面的 <code class=\"language-text\">x</code> 无关，是一个函数的参数；</li>\n</ul>\n<p>换句话说，当 JavaScript 引擎在解析一个 JavaScript 对象的时候，需要考虑很多的可能性，在解析的过程中很可能无法确定当前的类型，甚至连语法是否正确也不能确定。但反观 JSON，定义就简单的多，在解析的当下，引擎就可以很清楚的知道当前的内容是一个数组，还是一个对象，亦或是有语法错误。</p>\n<p>除了上述提到的性能比较数据之外，<a href=\"https://joreteg.com/blog/improving-redux-state-transfer-performance\">这里</a>还有一份针对 Redux 应用的优化分析。数据显示，使用 <code class=\"language-text\">JSON.parse</code> 调用之后 TTI (Time To Interactive) 时间缩短了 0.74s (18%)。考虑到整个改动是非常“简单”的，这一性能提升显得非常客观。</p>\n<p>这里之所以说改动是非常“简单”的，是因为整个优化思路非常的明确，完全可以通过对应的工具在编译时完成。目前开源社区已经提供了各类相关的工具，可以直接使用，列举一些如下：</p>\n<ul>\n<li>Webpack（<a href=\"https://github.com/webpack/webpack/releases/tag/v4.35.3\">v4.35.3</a> 或以上）默认会将 JSON 打包成 <code class=\"language-text\">JSON.parse()</code>；使用 <code class=\"language-text\">json-loader</code> 可以去掉这一优化（具体见这个 <a href=\"https://github.com/webpack/webpack/pull/9349\">Pull Request</a>）；</li>\n<li>一些 Babel Plugin 支持将满足要求的 JavaScript 对象转化成 <code class=\"language-text\">JSON.parse</code> 语法，比如 <a href=\"https://github.com/nd-02110114/babel-plugin-object-to-json-parse\">babel-plugin-object-to-json-parse</a> 或 <a href=\"https://github.com/keyz/babel-plugin-transform-optimize-object-literal\">babel-plugin-transform-optimize-object-literal</a>。</li>\n</ul>","frontmatter":{"title":"Cost of parsing JSON","category":"JavaScript","date":"2019-12-03"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"time":"2019-12-03","title":"Cost of parsing JSON","previous":{"time":"2019-12-02","title":"7zip-bin in Alpine Docker"},"next":{"time":"2019-12-04","title":"Rendered Fonts"}}}}