{"componentChunkName":"component---src-templates-til-js","path":"/til/2019-08-04_how-makefile-works","webpackCompilationHash":"d0c1c456129354e33ddb","result":{"data":{"markdownRemark":{"id":"8a0f43f3-a20d-55b4-b583-513fd38b8f95","html":"<p>在 C 编程中，经常会用到 <code class=\"language-text\">Makefile</code> 来对源代码进行编译。一个简单的 <code class=\"language-text\">Makefile</code> 如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"makefile\"><pre class=\"language-makefile\"><code class=\"language-makefile\"><span class=\"token symbol\">out</span><span class=\"token punctuation\">:</span> input.c\n  <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> input.c -o out -Wall -Wextra -std<span class=\"token operator\">=</span>c99</code></pre></div>\n<p>这里，第一行的 <code class=\"language-text\">out: input.c</code> 表示 <code class=\"language-text\">make</code> 应该根据输入 <code class=\"language-text\">input.c</code> 来产出 <code class=\"language-text\">out</code> 这个文件。</p>\n<p>第二行的 <code class=\"language-text\">$(CC)</code> 会由 <code class=\"language-text\">make</code> 替换成本机的 cc 程序（即 <strong>c</strong> <strong>c</strong>ompiler）；后面跟着的是 <code class=\"language-text\">cc</code> 编译会用到的参数，包括输入源文件 <code class=\"language-text\">input.c</code>，输出文件 <code class=\"language-text\">out</code>，编译输出所有的 Warning（<code class=\"language-text\">-Wall</code> 即 <strong>W</strong>arning <strong>all</strong>，<code class=\"language-text\">-Wextra</code> 即 <strong>W</strong>arning <strong>extra</strong>），同时指定使用 <a href=\"https://en.wikipedia.org/wiki/C99\">C99</a> 标准来编译 C 代码（和 <a href=\"https://en.wikipedia.org/wiki/ANSI_C\">ANSI C</a> 相比，C99 允许在函数的任意位置定义变量，而不是必须在顶部）。</p>\n<p>运行 <code class=\"language-text\">make</code> 命令，程序会查找当前目录下的 <code class=\"language-text\">Makefile</code> 函数，读取其中的配置，根据输入输出的要求，查找文件，然后再选择编译。</p>\n<p>第一次编译，程序会用 <code class=\"language-text\">input.c</code> 编译出一个 <code class=\"language-text\">out</code> 文件来。</p>\n<p>在 <code class=\"language-text\">input.c</code> 没有修改的情况下，如果再运行一次 <code class=\"language-text\">make</code> 命令，会得到如下的输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">make: `out` is update to date.</code></pre></div>\n<p>这里，<code class=\"language-text\">make</code> 程序并没有通过任何外部文件的方式记录编译的情况。判断是否需要编译完全依赖于系统默认的文件功能，即简单的比较 <code class=\"language-text\">input.c</code> 和 <code class=\"language-text\">out</code> 两个文件的最后修改时间。如果 <code class=\"language-text\">out</code> 的最后修改时间比 <code class=\"language-text\">input.c</code> 要晚，就认为 <code class=\"language-text\">out</code> 是最新的，不再重复编译；如果 <code class=\"language-text\">input.c</code> 的最后修改时间晚于 <code class=\"language-text\">out</code> 的时间，或是 <code class=\"language-text\">out</code> 压根就不存在，那么 <code class=\"language-text\">make</code> 就会执行 <code class=\"language-text\">Makefile</code> 中配置的编译命令。</p>\n<p>可以通过以下方式欺骗 <code class=\"language-text\">Makefile</code> 来检查这一行为：</p>\n<ol>\n<li>修改一下 <code class=\"language-text\">input.c</code> 并保存</li>\n<li>删除 <code class=\"language-text\">out</code> 文件，然后用 <code class=\"language-text\">touch</code> 命令创建一个空的 <code class=\"language-text\">out</code> 文件。因为是先修改，再创建，所以 <code class=\"language-text\">out</code> 的创建时间会晚于 <code class=\"language-text\">input.c</code></li>\n<li>尝试执行 <code class=\"language-text\">make</code> 命令，会发现提示 <code class=\"language-text\">out</code> 已经是最新的，并没有执行真正的编译命令（尽管这里 <code class=\"language-text\">out</code> 并不是通过 <code class=\"language-text\">make</code> 编译出来的）</li>\n</ol>","frontmatter":{"title":"How Makefile works","category":"Bash","date":"2019-08-04"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"time":"2019-08-04","title":"How Makefile works","previous":{"time":"2019-08-02","title":"Check Exit Code of Command"},"next":{"time":"2019-08-05","title":"Permission Denied for Rsync"}}}}