{"componentChunkName":"component---src-templates-til-js","path":"/til/2019-11-25_issamenode","result":{"data":{"markdownRemark":{"id":"1de0a311-e54d-5928-bcf7-eccaae105279","html":"<p><code class=\"language-text\">Node.isSameNode</code> 这个 API 的作用，是判断另一个 Node 节点和当前节点是否是相同的。举例来说：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n\na<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => true</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span></code></pre></div>\n<p>因为在一个同一个 document 中，一个 Node 实际只有一个引用，因此 <code class=\"language-text\">.isSameNode</code> API 的实际效果其实和 <code class=\"language-text\">==</code> 或 <code class=\"language-text\">===</code> 运算是一致的。简单来说，上面的代码，可以等价于：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">a <span class=\"token operator\">===</span> c<span class=\"token punctuation\">;</span> <span class=\"token comment\">// => true</span>\na <span class=\"token operator\">===</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span></code></pre></div>\n<p>在 <a href=\"https://dom.spec.whatwg.org/#dom-node-issamenode-othernode-othernode\">DOM (Living Standard) 规范</a>中，也可以看到相关的注释，说明 <code class=\"language-text\">.isSameNode</code> 本质上只是因为历史原因而给出的 <code class=\"language-text\">===</code> 的别名（alias）。</p>\n<p>然而在某些有限的场景下，<code class=\"language-text\">.isSameNode</code> 依然有发挥的应用场景，目前可以想到的有以下几点：</p>\n<ol>\n<li>在节点相关算法（如 Diff 算法）中作为抽象方法直接使用。比如，在 <a href=\"https://github.com/patrick-steele-idem/morphdom\">morphdom</a> 中，就使用了 <code class=\"language-text\">.isSameNode</code> 这个 API 来比较两个节点是否相同，从而节省比较的次数(<a href=\"https://github.com/patrick-steele-idem/morphdom/blob/56f330fa0fa6df9e51eeeaaae5894e24f30edb7c/src/morphdom.js#L237\">源码</a>)。根据 morphdom 给出的<a href=\"https://github.com/patrick-steele-idem/morphdom/blob/e4a34d934b24bb5aad1fcbc6222ed21bcdb5e56d/docs/virtual-dom.md#L23\">文档</a>可以看到，morphdom 的算法也支持对 virtual dom 进行比较，只需要 virtual dom 也对节点实现了相应的 <code class=\"language-text\">.isSameNode</code> API，就有可能可以在比较的时候节省一定的计算次数。这里，<code class=\"language-text\">.isSameNode</code> 在 morphdom 中就被作为抽象方法使用了，算法本身并不在意真正在 diff 的对象是真实的 DOM 还是 virtual DOM，只要节点实现了符合要求的 API，算法就可以正确的进行。</li>\n<li>通过重写方法来达到“代理节点”的功能。现在大多数的 UI 库，都通过声明式的方式来定义组件。在这种情况下，开发者并不需要显示的写出在何时通过何种方式创建或更新一个节点，只需要写出 <code class=\"language-text\">state =&gt; UI</code> 这样的映射函数，UI 库就会在 state 更新后，通过映射函数去得到新的 UI 组件，然后通过 diff 算法去计算得到需要修改的部分，最终将必要的部分进行更新。在这种情况下，就没有办法通过 <code class=\"language-text\">===</code> 去比较两个节点是否相同了，因为流程上是需要通过新的 state 生成节点，然后再和已有的 Node 进行比较。这种情况下，通过改写 <code class=\"language-text\">.isSameNode</code> 就可以达到人为控制的目的。</li>\n</ol>\n<p>举一个 <a href=\"https://github.com/choojs/nanocomponent\">nanocomponent</a> 中提到的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> html <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nanohtml'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> el1 <span class=\"token operator\">=</span> html<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>pink is the best&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> el2 <span class=\"token operator\">=</span> html<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>blue is the best&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 对 el1 进行代理操作</span>\n<span class=\"token keyword\">const</span> proxy <span class=\"token operator\">=</span> html<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\nproxy<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">isSameNode</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">targetNode</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>targetNode <span class=\"token operator\">===</span> el1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nel1<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// true</span>\nel1<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// false</span>\nproxy<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nproxy<span class=\"token punctuation\">.</span><span class=\"token function\">isSameNode</span><span class=\"token punctuation\">(</span>el2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<p>虽然 <code class=\"language-text\">proxy</code> 和 <code class=\"language-text\">el1</code> 并不是真的一样的两个节点，但是因为对 <code class=\"language-text\">isSameNode</code> 进行了改写，因而在 diff 算法中，两个节点会被当作是一致的。这有助于节省比较的次数。</p>\n<p><code class=\"language-text\">.isSameNode</code> API 的支持情况，可以查看 <a href=\"https://caniuse.com/#search=isSameNode\">Can I Use</a>；文档可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/isSameNode\">MDN</a>。</p>","frontmatter":{"title":"isSameNode","category":"JavaScript","date":"2019-11-25"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"time":"2019-11-25","title":"isSameNode","previous":{"time":"2019-11-21","title":"Export Variable using Private Name"},"next":{"time":"2019-11-26","title":"isEqualNode"}}}}