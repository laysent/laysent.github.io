{"componentChunkName":"component---src-templates-til-category-js","path":"/til/category/typescript","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"202b1c1f-e486-5449-863c-b7cad49cf68a","html":"<p>在使用 TypeScript + Webpack 的项目中，可能会遇到如下类似的报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in ./src/xxx.tsx 346:0-62\n&quot;export &#39;xxx&#39; was not found in &#39;./xxxx&#39;</code></pre></div>\n<p>这类报错出现的情况是，在 <code class=\"language-text\">./scr/xxx.tsx</code> 文件中，先 <code class=\"language-text\">import</code> 了一个类型定义，然后又将这个类型定义重新 <code class=\"language-text\">export</code> 出去了。产生报错的原因在于，TypeScript 的文件需要通过 loader（无论是 babel-loader 还是 ts-loader）转化成 Webpack 可识别的 JavaScript 文件。在转化之后，TypeScript 中定义的纯类型（如 interface）都丢失了。正因为这些类型丢失了，在试图重新 <code class=\"language-text\">export</code> 的时候，Webpack 就无法找到对应的定义，只能报错（Warning）了。</p>\n<p>可以考虑通过以下的方案避免警告：</p>\n<ol>\n<li>将所有的类型定义放到单独的文件（比如 <code class=\"language-text\">types.ts</code> 中），然后通过 <code class=\"language-text\">export * from &#39;types.ts&#39;</code> 一次性将所有内容 export 出去（这样可以避免具体声明需要 export 的内容）；</li>\n<li>重新在当前文件中定义一个类型，然后将这个类型 export 出去：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Type <span class=\"token keyword\">as</span> _Type <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./type'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> Type <span class=\"token operator\">=</span> _Type<span class=\"token punctuation\">;</span></code></pre></div>\n<p>在 TypeScript 3.7 之前，上面的代码可以简写为：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Type <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./type'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> Type <span class=\"token operator\">=</span> Type<span class=\"token punctuation\">;</span></code></pre></div>\n<p>在 3.7 及之后的版本中，必须保证新定义的类型名称和原来的类型名称不同。这是因为在 TypeScript 3.7 中对类型定义做了调整，在提供更强大的递归引用类型功能的同时，不再允许定义同名的类型。相关的介绍，可以查看官方的<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#more-recursive-type-aliases\">发布文档</a>。</p>","frontmatter":{"date":"2019-12-05","title":"Export was Not Found","category":"TypeScript"}}},{"node":{"id":"d4f2cc35-174d-5e24-86fa-274d23e4c9a1","html":"<p>在 TypeScript 编译过程中，可能会遇到如下的报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">Exported variable &lt;variable name&gt; has or is using private name &lt;private name&gt;</code></pre></div>\n<p>这一报错只会出现在开启了 declaration 输出之后。开启的方式是编译时增加 <code class=\"language-text\">--declaration</code>，或者在 tsconfig.json 中加入：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"declaration\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>出现这一报错的原因是，最终被使用的某一个类型，引用到了某一个没有被公开（export）的类型。简单的例子如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">B</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">type</span> Props <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">|</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，之所以会出现问题，理由很简单：TypeScript 试图输出一个定义类型的文件，其中就包括了 <code class=\"language-text\">Props</code> 的定义。然而，如果要明确定义 <code class=\"language-text\">Props</code>，就需要用到两个类型 <code class=\"language-text\">A</code> 和 <code class=\"language-text\">B</code>。在这里，<code class=\"language-text\">A</code> 和 <code class=\"language-text\">B</code> 这两个类型因为没有被公开（export），因而是私有（private）的。故，理论上来说，TypeScript 的导出定义文件中不应该包含这两个类型。而没有这两个类型的话，TypeScript 就没有办法定义 <code class=\"language-text\">Props</code> 了。最终，TypeScript 只能报错。</p>\n<p>官方给出的解释可以参考<a href=\"https://github.com/ant-design/ant-design/pull/19846#event-2817984936\">这里</a>。</p>\n<p>要解决这个问题，方法也很简单：所有使用到的类型，全部都公开（export）就好了。</p>","frontmatter":{"date":"2019-11-21","title":"Export Variable using Private Name","category":"TypeScript"}}},{"node":{"id":"bdf22101-4989-5baa-9054-a528719b9619","html":"<p><a href=\"https://github.com/tc39/proposal-nullish-coalescing\">Nullish Coalescing</a> 当前在 TC39 Stage 3 的阶段，TypeScript 在 <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing\">3.7</a> 中也将这一功能引入了进来。（<a href=\"http://dict.cn/Coalesce\">Coalesce</a> 是“合并；联合；接合”的意思）</p>\n<p>Nullish Coalescing 的简单用法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>当 <code class=\"language-text\">foo</code> 的值是 <code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code> 的时候，<code class=\"language-text\">x</code> 的值由后面的 <code class=\"language-text\">bar()</code> 决定，否则 <code class=\"language-text\">x</code> 的值就是 <code class=\"language-text\">foo</code> 本身。这一行为，一般会被用于给变量赋初始值。在之前的 JavaScript / TypeScript 中，一般会这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num <span class=\"token operator\">||</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>但是，这样写有一个问题，就是当 <code class=\"language-text\">num</code> 的值是 <code class=\"language-text\">0</code> 的时候，最终的值依然是 <code class=\"language-text\">5</code> 而不是 <code class=\"language-text\">0</code>。这一行为很可能并不是开发者希望的。</p>\n<p>和 Optional Chaining 一样，Nullish Coalescing 只有在原值是 <code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code> 的时候，才进行操作；其他的 falsy 值，都会保持原样，并不会做特殊的处理（根据 <a href=\"https://github.com/tc39/proposal-nullish-coalescing/blob/master/README.md#overview-and-motivation\">Proposal</a> 中的说明，这两个规范将会在“何时处理”上保持一致）。这很大程度上减少了 JavaScript 在类型上导致隐藏问题的可能性。</p>\n<p>需要注意的一点是，这一行为和 JavaScript 中的默认参数是有一点不一样的。上面的代码如果改写成默认参数的形式：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那么，将会在 <code class=\"language-text\">getNumber(null)</code> 的时候产生行为上的分歧。使用 Nullish Coalescing 将会返回 <code class=\"language-text\">5</code>，也就是进行了默认值赋值；而默认参数的方案将会返回 <code class=\"language-text\">null</code>，因为默认参数只有在 <code class=\"language-text\">undefined</code> 的情况下才会进行默认值赋值操作。</p>\n<p>Optional Chaining 和 Nullish Coalescing 可以放在一起操作，确保值不存在的时候，有一个兜底的默认值可以给程序使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>bar<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token string\">'default'</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-11-11","title":"Nullish Coalescing","category":"TypeScript"}}},{"node":{"id":"04dc3c68-fa9d-535f-94d9-f7a404f1d2dc","html":"<p>在 TC39 将 <a href=\"https://github.com/tc39/proposal-optional-chaining/\">Optional Chaining</a> 转移到 Stage 3 之后，TypeScript 在 3.7 版本中也带来了对应的 Optional Chaining 功能。总体上，TypeScript 的 Optional Chaining 功能和 JavaScript 的提案是保持一致的。总结来说，就是：</p>\n<blockquote>\n<p>如果属性值是 <code class=\"language-text\">undefined</code> 或者 <code class=\"language-text\">null</code>，就会直接返回 <code class=\"language-text\">undefined</code>，否则会进一步获取真实的属性值。</p>\n</blockquote>\n<p>在 <a href=\"https://www.typescriptlang.org/play/index.html\">TypeScript Playground</a> 中可以尝试一下这个新的功能。以下面这段 TypeScript 为例：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> foo<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>bar<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>最终会被转译成下面的这段 JavaScript：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> _a<span class=\"token punctuation\">,</span> _b<span class=\"token punctuation\">,</span> _c<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_a <span class=\"token operator\">=</span> foo<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _a <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span>\n  <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">(</span>_b <span class=\"token operator\">=</span> _a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _c <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span>\n    <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span>\n    <span class=\"token function\">_c</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>_b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>几点简单的说明：</p>\n<ol>\n<li>即使值是 <code class=\"language-text\">null</code>，最终返回的结果也会是 <code class=\"language-text\">undefined</code>（上面代码中是 <code class=\"language-text\">void 0</code>，是等价的）；</li>\n<li>只有 <code class=\"language-text\">null</code> 和 <code class=\"language-text\">undefined</code> 的情况会被直接返回。这一点，和之前 <code class=\"language-text\">foo &amp;&amp; foo.bar</code> 这样的写法是有区别的。主要是 JavaScript 对哪些值是 falsy 的判断，范围会比 <code class=\"language-text\">null</code> &#x26; <code class=\"language-text\">undefined</code> 更广，还包括了 <code class=\"language-text\">NaN</code>，<code class=\"language-text\">0</code>，<code class=\"language-text\">false</code> 等；</li>\n<li>Optional Chaining 在函数调用中也是可以用的，写法是 <code class=\"language-text\">xx?.()</code>，如果不存在，函数不会调用，而是直接返回 <code class=\"language-text\">undefined</code>；</li>\n<li>Optional Chaining 也可以使用如下的写法：<code class=\"language-text\">foo?.[0]</code>， <code class=\"language-text\">foo?.[&#39;var-name&#39;]</code> 或 <code class=\"language-text\">foo?.[variableName]</code></li>\n</ol>\n<p>官方的发布介绍文档见<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#optional-chaining\">这里</a>。</p>","frontmatter":{"date":"2019-11-06","title":"Optional Chaining in TypeScript","category":"TypeScript"}}},{"node":{"id":"eaaeec73-6699-5bf9-b4b2-fec94aeecd0b","html":"<p>在 React 中，经常会有这样的场景：通过某一个参数是否是真值，来决定某一个元素是否需要显示出来。</p>\n<p>以 Ant Design 为例，<a href=\"https://ant.design/components/tooltip/\">Tooltip</a> 的定义中，就包含了 <code class=\"language-text\">title</code> 这个参数，用于决定是否显示 Tooltip 及显示什么。如果传递的是 <code class=\"language-text\">false</code>，<code class=\"language-text\">null</code> 或者 <code class=\"language-text\">undefined</code>，那么最终 Tooltip 就不会被显示出来。</p>\n<p>常用的调用形式可能如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Tooltip</span></span> <span class=\"token attr-name\">title</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>hide <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">'text'</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>在最初 Ant Design 对此的定义上，使用了如下的 TypeScript 类型定义：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Props</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  title<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> React<span class=\"token punctuation\">.</span>ReactNode <span class=\"token operator\">|</span> RenderFunction<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里，<code class=\"language-text\">title</code> 的定义用到了“可选参数”。看上去，是符合预期的行为，然而这里有几个细节值得注意：</p>\n<ol>\n<li><code class=\"language-text\">React.ReactNode</code> 的定义是：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> ReactNode <span class=\"token operator\">=</span>\n  ReactChild <span class=\"token operator\">|</span> ReactFragment <span class=\"token operator\">|</span> ReactPortal <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">|</span> undefined<span class=\"token punctuation\">;</span></code></pre></div>\n<p>可以看到，即使不是可选参数，<code class=\"language-text\">undefined</code> 等一系列值也是可以赋予给 <code class=\"language-text\">title</code> 的；</p>\n<ol start=\"2\">\n<li><code class=\"language-text\">title?: string</code> 和 <code class=\"language-text\">title: string | undefined</code> 之间存在着细微的差别。</li>\n</ol>\n<p>这里展开对比一下 <code class=\"language-text\">title?: string</code> 和 <code class=\"language-text\">title: string | undefined</code> 之间的细微差别。如果定义的类型是 <code class=\"language-text\">title?: string</code>，那么，以下的调用方式都是正确的：</p>\n<ol>\n<li>传递字符串作为参数：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Tooltip</span></span> <span class=\"token attr-name\">title</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>string<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<ol start=\"2\">\n<li>传递 <code class=\"language-text\">undefined</code> 作为参数：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Tooltip</span></span> <span class=\"token attr-name\">title</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<ol start=\"3\">\n<li>不传递参数：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Tooltip</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>而如果是 <code class=\"language-text\">title: string | undefined</code>，那么上面的第三种方案（即不传参数）就是不可行的。</p>\n<p>还是以 Tooltip 为例，显然前两种调用方法都是真实存在的场景，毕竟 Tooltip 可能是需要根据外部条件来选择性展示的；但是对于第三种场景，即不提供 <code class=\"language-text\">title</code> 数据、一直保持不渲染 Tooltip 的状态，可以认为是有错误的，应该由 TypeScript 进行检查并报错。</p>\n<p>故，改成以下这种形式就可以了，毕竟 <code class=\"language-text\">React.ReactNode</code> 就允许了 <code class=\"language-text\">undefined</code> 的使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Props</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  title<span class=\"token punctuation\">:</span> React<span class=\"token punctuation\">.</span>ReactNode <span class=\"token operator\">|</span> RenderFunction<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ant Design 对这种情况进行了<a href=\"https://github.com/ant-design/ant-design/pull/18515\">修正</a>。</p>","frontmatter":{"date":"2019-08-29","title":"Conditional Props in React","category":"TypeScript"}}},{"node":{"id":"270c29d9-1949-5a76-a5f3-0aa46f71ce1a","html":"<p>在 TypeScript 中，如果希望一个变量只能取某几个固定值中的一个，可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> Type <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> a<span class=\"token punctuation\">:</span> Type <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✔</span>\n<span class=\"token keyword\">const</span> c<span class=\"token punctuation\">:</span> Type <span class=\"token operator\">=</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✖</span></code></pre></div>\n<p>然而，在实际的开发过程中，可能会遇到这样的需求：希望 TypeScript 可以限定某一个类型只能取某几个固定的值，同时这几个值又可以组成一个数组，方便 JavaScript 在运行时动态的执行匹配功能（如 <code class=\"language-text\">Array.prototype.some</code>）。</p>\n<p>如果直接尝试在 TypeScript 中写数组，实际无法达到预想的效果：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> Type <span class=\"token operator\">=</span> list<span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Type = string</span></code></pre></div>\n<p>这是因为，TypeScript 默认 <code class=\"language-text\">list</code> 的类型是 <code class=\"language-text\">string[]</code>，而不是 <code class=\"language-text\">(&#39;a&#39; | &#39;b&#39;)[]</code>。因此，在转化成 <code class=\"language-text\">Type</code> 的时候，得到的结果是更宽泛的字符串类型，而不是限定死的两个固定值。这其中，一个很重要的原因是 JavaScript 语言的动态性。数组随时可以被加入/删除元素，因而默认只能假设这是一个字符串类型的数组，而不能过多约束。</p>\n<p>为了达到目的，有以下几个变通的写法：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> list<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> Type <span class=\"token operator\">=</span> list<span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Type = 'a' | 'b';</span></code></pre></div>\n<p>这种写法比较啰嗦，重新写了一遍完整的数组用于定死类型的选择范围。</p>\n<p>也可以通过写一个辅助函数来达到类似的效果：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> tupleStr<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span>args<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> list <span class=\"token operator\">=</span> <span class=\"token function\">tupleStr</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> Type <span class=\"token operator\">=</span> list<span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Type = 'a' | 'b';</span></code></pre></div>\n<p>在 Ant Design 中可以找到<a href=\"https://github.com/ant-design/ant-design/blob/65eb713fe897f65bbf187e215c664e5f9b468252/components/_util/type.ts#L5\">类似的写法</a>。这里也有一个类似的 <a href=\"https://gist.github.com/jcalz/381562d282ebaa9b41217d1b31e2c211\">gist</a>。</p>\n<p>注：上述这种写法需要 TypeScript 3.0 的<a href=\"https://github.com/Microsoft/TypeScript/pull/24897\">支持</a>。</p>\n<p>当然，上述的方案或多或少都需要额外写一些东西，有些麻烦。在 TypeScript 3.4 中，可以通过 <code class=\"language-text\">as const</code> 这个语法来告知 TypeScript 数组是静态的、并不会增加或者减少内容。有了这样的前提假设，TypeScript 就可以更好的进行类型推导，把实际的类型结果限制到已知的几个有限的值范围内。例子如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> list1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> list2 <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">const</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> Type1 <span class=\"token operator\">=</span> list1<span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> Type2 <span class=\"token operator\">=</span> list2<span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上述两种写法是等价的（参考<a href=\"https://github.com/Microsoft/TypeScript/pull/29510\">这里</a>），都可以达到目的。另外，由于在 TypeScript 中限制了数组，之后想要在数组中做改动都是会导致编译器报错的。</p>\n<p><a href=\"https://stackoverflow.com/questions/45251664/typescript-derive-union-type-from-tuple-array-values\">参考</a></p>","frontmatter":{"date":"2019-07-04","title":"Derive Union Type from Tuple/Array","category":"TypeScript"}}},{"node":{"id":"9d0214db-d137-5836-8ef7-f5647b897c2e","html":"<p>在 TypeScript 中，常常存在一个对象可能是 <code class=\"language-text\">undefined</code> 或 <code class=\"language-text\">null</code> 的情况。如果试图直接使用这样的对象，很可能会造成 TypeScript 的报错（在 <code class=\"language-text\">--strictNullChecks</code> 开启的情况下）。这本身是一个正确的行为，也可以在编译时帮助开发者避免一些不必要的错误。</p>\n<p>然而，在实际的开发中，不免遇到这样的情况：在某些特定的生命周期中，开发者可以很明确的知道某一个值不会是 <code class=\"language-text\">undefined</code> 或者 <code class=\"language-text\">null</code>。然而，这样的前置条件 TypeScript 本身并不知情。此时，为了防止 TypeScript 报错，就需要通过某些显式的方法，声明这一情况。</p>\n<p>最常见的方案，是通过 <code class=\"language-text\">as</code> 来强制类型转化。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">throwIfUndefined</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> input <span class=\"token operator\">===</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Undefined!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">optional<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">throwIfUndefined</span><span class=\"token punctuation\">(</span>optional<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>optional <span class=\"token keyword\">as</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TypeScript 提供了一个 Non-null assertion 运算符：<code class=\"language-text\">!.</code>，就是用于上述情景的。具体来说：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">optional<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">throwIfUndefined</span><span class=\"token punctuation\">(</span>optional<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>optional<span class=\"token operator\">!</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面这样写之后，TypeScript 就不会报错了。<code class=\"language-text\">optional</code> 被认为一定是非 <code class=\"language-text\">undefined</code> 或 <code class=\"language-text\">null</code> 类型的。（至于 TypeScript 会认为这个变量是什么类型的，就要看这个变量除了 <code class=\"language-text\">undefined | null</code> 的类型之外，还可能是什么类型的了）</p>\n<p>当然，不难看出，这个运算符只是一个编译时帮助编译器理解类型用的辅助手段，本身并不是一个语法糖。因此，在 TypeScript 转化成 JavaScript 的过程中，这里的运算符会直接被去掉。<code class=\"language-text\">optional!.length</code> 生成的就是 <code class=\"language-text\">optional.length</code>，没有生成任何额外的东西。</p>","frontmatter":{"date":"2019-06-20","title":"TypeScript Non-null Assertion","category":"TypeScript"}}},{"node":{"id":"f8816c31-98ea-573f-a38e-fbaac6df6966","html":"<p><code class=\"language-text\">Record</code> 是 TypeScript 中一个很实用的范型类型。它需要两个具体的参数类型，<code class=\"language-text\">Record&lt;K, V&gt;</code>，用于指定一个对象的类型。其中，对象的所有 key 都是 <code class=\"language-text\">K</code> 类型的，而这些 key 对应的值则都是 <code class=\"language-text\">V</code> 类型的。如果不使用 <code class=\"language-text\">Record</code> 类型，可能需要用如下的方法来达到同等的效果：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> RecordExample <span class=\"token operator\">=</span> Record<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">EquivalentExample</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>显然，等价的写法更为的复杂，看起来也不那么清晰。</p>\n<p>当然，对于 JavaScript 来说，对象的属性其实只能是 <code class=\"language-text\">string</code> 类型的。虽然有时候也会直接使用 <code class=\"language-text\">number</code> 作为值（TypeScript 里面也可以专门这么来做类型强制），但是其实在用作 key 的时候，会经过一步 toString 的转化。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> key<span class=\"token punctuation\">:</span> <span class=\"token string\">'value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token string\">'key'</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: value</span></code></pre></div>\n<p>这么看起来，<code class=\"language-text\">Record</code> 的应用场景似乎非常有限，只有 <code class=\"language-text\">Record&lt;string, xxx&gt;</code> 或者 <code class=\"language-text\">Record&lt;number, xxx&gt;</code> 两种可能性。然而，TypeScript 中除了可以使用一些泛用的类型之外，也可以对类型做更进一步的限定。比如，指定类型只能是 <code class=\"language-text\">&#39;apple&#39; | &#39;banana&#39; | &#39;orange&#39;</code>。如此一来，<code class=\"language-text\">Record</code> 就有了更多的应用场景。</p>\n<p>举例来说，如果希望写一个函数，可以将参数对象中所有的值都转化成对应的数字，就可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> Input <span class=\"token operator\">=</span> Record<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">function</span> transform<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Input</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Record<span class=\"token operator\">&lt;</span><span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> keys<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> keys<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">acc<span class=\"token punctuation\">,</span> key</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    acc<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">+</span>input<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> acc<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> Record<span class=\"token operator\">&lt;</span><span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样，就可以保证输入和输出的对象，有相同的 key。</p>\n<p>然而，需要注意的一点是，在使用联合类型的时候 <code class=\"language-text\">Record</code> 本身也存在局限性（这一点本身是 TypeScript 的局限性）。还是以上面的 <code class=\"language-text\">&#39;apple&#39; | &#39;banana&#39; | &#39;orange&#39;</code> 为例，如果这么写，那么下面的代码将是错误的：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> Fruit <span class=\"token operator\">=</span> <span class=\"token string\">'apple'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'banana'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'orange'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> Price <span class=\"token operator\">=</span> Record<span class=\"token operator\">&lt;</span>Fruit<span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// type error</span>\n<span class=\"token keyword\">const</span> prices<span class=\"token punctuation\">:</span> Price <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  apple<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>原因是，上面只定义了 <code class=\"language-text\">apple</code> 的数据，但是没有定义剩下的 <code class=\"language-text\">banana</code> 和 <code class=\"language-text\">orange</code> 的数据。以下定义不会报错，但有时候并不满足需求：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> prices<span class=\"token punctuation\">:</span> Price <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  apple<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span>\n  banana<span class=\"token punctuation\">:</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span>\n  orange<span class=\"token punctuation\">:</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">Record</code> 天然并不能解决可选 key 的情况。<code class=\"language-text\">Record&lt;&#39;A&#39; | &#39;B&#39;, number&gt;</code> 的含义是 <code class=\"language-text\">A</code> 和 <code class=\"language-text\">B</code> 都需要是这个类型的 key，而不是说只需要有 <code class=\"language-text\">A</code> 或 <code class=\"language-text\">B</code> 一个做 key 就可以了。对于这种需要可选的情况，可以再套上一层 <code class=\"language-text\">Partial</code> 来满足需求：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> Price <span class=\"token operator\">=</span> Partial<span class=\"token operator\">&lt;</span>Record<span class=\"token operator\">&lt;</span>Fruit<span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token operator\">>></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// correct</span>\n<span class=\"token keyword\">const</span> prices<span class=\"token punctuation\">:</span> Price <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  apple<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>更多实现的细节，可以参考 <a href=\"https://github.com/microsoft/TypeScript/blob/408b17649a1197a52f68fcb49b8c2f1eeac13668/src/lib/es5.d.ts#L1449\">Record 定义</a> 和 <a href=\"https://github.com/microsoft/TypeScript/blob/408b17649a1197a52f68fcb49b8c2f1eeac13668/src/lib/es5.d.ts#L1421\">Partial 定义</a>。</p>","frontmatter":{"date":"2019-06-19","title":"Record in TypeScript","category":"TypeScript"}}},{"node":{"id":"9f6415c3-86fc-52d1-9a28-19992b45f9a2","html":"<p>假设有一个 TypeScript 的类型是：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Example</span> <span class=\"token punctuation\">{</span>\n  str<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">func1</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">param1<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> param2<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">func2</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>以下这个 TypeScript 的定义，可以用于将 <code class=\"language-text\">T</code> 中函数的部分抽离出来，形成新的类型：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> Pick<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">keyof</span> <span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span><span class=\"token constant\">P</span> <span class=\"token keyword\">in</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">P</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> FunctionPropertyNames<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span><span class=\"token constant\">K</span> <span class=\"token keyword\">in</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Function</span> <span class=\"token operator\">?</span> <span class=\"token constant\">K</span> <span class=\"token punctuation\">:</span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>最终，新类型的定义如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> Result <span class=\"token operator\">=</span> Pick<span class=\"token operator\">&lt;</span>Example<span class=\"token punctuation\">,</span> FunctionPropertyNames<span class=\"token operator\">&lt;</span>Example<span class=\"token operator\">>></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>等价于：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Equivalent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">func1</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">param1<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> param2<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">func2</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"date":"2019-05-21","title":"Extract all function properties from given type","category":"TypeScript"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"TypeScript"}}}