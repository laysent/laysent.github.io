{"componentChunkName":"component---src-templates-til-category-js","path":"/til/category/docker","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"1f47e54e-3226-5831-b830-c394c36ddda6","html":"<p>Node.js 的 Docker 有基于 Alpine 的版本。在这个 Docker 中使用 <a href=\"https://github.com/develar/7zip-bin\">7zip-bin</a> 库的时候遇到了错误，无法正常启动。</p>\n<p>一个简单的重现 <code class=\"language-text\">Dockerfile</code> 可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>10<span class=\"token punctuation\">-</span>alpine\n\n<span class=\"token keyword\">RUN</span> mkdir <span class=\"token punctuation\">-</span>p example &amp;&amp; \\\n  cd example &amp;&amp; \\\n  yarn init <span class=\"token punctuation\">-</span>y &amp;&amp; \\\n  yarn add 7zip<span class=\"token punctuation\">-</span>bin &amp;&amp; \\\n  mkdir /lib64 &amp;&amp; \\\n  ln <span class=\"token punctuation\">-</span>s /lib/libc.musl<span class=\"token punctuation\">-</span>x86_64.so.1 /lib64/ld<span class=\"token punctuation\">-</span>linux<span class=\"token punctuation\">-</span>x86<span class=\"token punctuation\">-</span>64.so.2\n\n<span class=\"token keyword\">ADD</span> run.sh /run.sh\n\n<span class=\"token keyword\">RUN</span> chmod +x /run.sh\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"/run.sh\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>其中，<code class=\"language-text\">run.sh</code> 可以写：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> example\n<span class=\"token variable\"><span class=\"token variable\">$(</span>node -e \"console.log<span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">(</span><span class=\"token string\">'7zip-bin'</span><span class=\"token punctuation\">)</span>.path7za<span class=\"token variable\">)</span></span>\"<span class=\"token punctuation\">)</span></code></pre></div>\n<p>报错的内容是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/run.sh: line 2: /example/node_modules/7zip-bin/linux/x64/7za: not found</code></pre></div>\n<p>通过进入 Docker 内部观察不难发现，<code class=\"language-text\">/example/node_modules/7zip-bin/linux/x64/7za</code> 这个文件实际是真实存在的，但是在使用的时候系统却报错 <code class=\"language-text\">not found</code>。造成这一问题的原因，可能是动态库缺失。</p>\n<p>通过 <code class=\"language-text\">ldd</code> 命令可以列出动态库依赖关系（<a href=\"https://linux.die.net/man/1/ldd\">文档</a>）：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">ldd /example/node_modules/7zip-bin/linux/x64/7za</code></pre></div>\n<p>输出结果是：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibpthread.so.0 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibstdc++.so.6 =&gt; /usr/lib/libstdc++.so.6 (0x7febe52b9000)\nlibm.so.6 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)\nlibgcc_s.so.1 =&gt; /usr/lib/libgcc_s.so.1 (0x7febe52a5000)\nlibc.so.6 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7febe540e000)</code></pre></div>\n<p>注意到缺少了 <code class=\"language-text\">/lib64/ld-linux-x86-64.so.2</code> 这个动态库，因此导致了 <code class=\"language-text\">7zip-bin</code> 这个库无法正常使用。造成这个的原因是，Alpine 使用的是 <a href=\"https://www.musl-libc.org/\">musl</a>，而 <code class=\"language-text\">7zip-bin</code> 使用的二进制文件是基于 glibc 编译出来的。要解决这个问题，有两种思路：</p>\n<ol>\n<li>在 Alpine 中安装 libc 的兼容库：<code class=\"language-text\">RUN apk add --no-cache libc6-compat</code>；</li>\n<li>或者，<code class=\"language-text\">ln -s /lib/libc.musl-x86_64.so.1 /lib/ld-linux-x86-64.so.2</code> 将 musl 的版本软连过去，直接让 <code class=\"language-text\">7zip-bin</code> 的二进制使用</li>\n</ol>\n<p>当然，最佳的方案是不使用 <code class=\"language-text\">7zip-bin</code> 中的 pre-build 版本，而改用 Alpine 的 <a href=\"https://pkgs.alpinelinux.org/package/edge/main/x86/p7zip\">p7zip</a> 版本。用 Alpine 的包管理器安装好 <code class=\"language-text\">pz7ip</code> 之后（<code class=\"language-text\">apk add p7zip</code>），使用类似下面的代码直接替换脚本就好了：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cp</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">type</span> -p 7za<span class=\"token variable\">)</span></span> <span class=\"token variable\"><span class=\"token variable\">$(</span>node -p <span class=\"token string\">\"require('7zip-bin').path7za\"</span><span class=\"token variable\">)</span></span></code></pre></div>\n<section><h2>参考链接</h2><ul>\n<li>在 7zip-bin issue 中的<a href=\"https://github.com/develar/7zip-bin/issues/8\">相关讨论</a></li>\n<li>重现的配置代码 <a href=\"https://gist.github.com/laysent/b12faceac4bcf10bee04aabfa505c244\">gist</a></li>\n<li>node-gyp 在 Alpine 中也可能会遇到类似的问题，在<a href=\"https://medium.com/devgorilla/node-gyp-support-in-alpine-linux-9374c6191140\">这里</a>可以找到相关的讨论</li>\n</ul></section>","frontmatter":{"date":"2019-12-02","title":"7zip-bin in Alpine Docker","category":"Docker"}}},{"node":{"id":"d7305a3b-e734-5c22-8369-4d8f478a7346","html":"<p>Docker 的运行环境因为一般只安装了运行程序需要的最小依赖集，因而存在各种限制。有时候需要查看日志，或是分析一些数据，直接在 Docker 中查看日志文件并不是非常方便。</p>\n<p>这个时候，可以通过 <code class=\"language-text\">docker cp</code> 命令将文件从 Docker 中拷贝出来，在外部环境中通过合适的工具直接分析。</p>\n<p><code class=\"language-text\">docker cp</code> 的使用步骤如下：</p>\n<ol>\n<li><code class=\"language-text\">docker container ls</code> 查看当前正在运行的 container，找到其中的 Container ID</li>\n<li>运行 <code class=\"language-text\">docker cp &lt;containerId&gt;:/path/in/container /host/path</code> 将数据拷贝出来</li>\n</ol>","frontmatter":{"date":"2019-09-06","title":"Copy out of Docker","category":"Docker"}}},{"node":{"id":"a8af124f-a7b7-503f-90db-e3eb67eb5c03","html":"<p>用 Docker 管理定时任务，依然可以通过 Cron 来进行。</p>\n<section><h2>Cron 配置</h2><p>可以通过以下的方式测试 Docker 中 Cron 的执行：</p><div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker run -ti --rm alpine <span class=\"token function\">sh</span> -c <span class=\"token punctuation\">\\</span>\n  <span class=\"token string\">\"echo <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>* * * * * echo hello<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> | crontab - &amp;&amp; crond -f -L /dev/stdout\"</span></code></pre></div><p>运用同样的原理，可以写一个简单的 Dockerfile 如下：</p><div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">RUN</span> touch /var/log/cron.log\n\n<span class=\"token keyword\">CMD</span> echo <span class=\"token string\">\"* * * * * echo 'Hello World' >> /var/log/cron.log 2>&amp;1\"</span> <span class=\"token punctuation\">|</span> \\\n  crontab <span class=\"token punctuation\">-</span> &amp;&amp; \\\n  crond <span class=\"token punctuation\">-</span>f <span class=\"token punctuation\">-</span>L /dev/stdout</code></pre></div><p>在上面的例子中，每一分钟都会输出一个 Hello World 到 <code class=\"language-text\">/var/log/cron.log</code> 文件中。Cron 的时间书写，可以在<a href=\"https://crontab.guru/\">这里</a> 进行直观的配置。</p></section>\n<section><h2>时区配置</h2><p>如果要进行更加复杂的 Cron 配置，很可能就会涉及到时间的问题。默认情况下，Docker 使用的 Linux Alpine 使用的是 UTC 时间。如果配置的 Cron 也需要用 UTC 来书写，显然不直观，也不方便。</p><p>简单的处理方法，就是在创建 Docker 的时候，对时区进行配置。比如，将时区设置成北京时间：</p><div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token keyword\">ARG</span> timezone=<span class=\"token string\">\"Asia/Beijing\"</span>\n\n<span class=\"token keyword\">RUN</span> apk add tzdata &amp;&amp; \\\n  cp /usr/share/zoneinfo/$timezone /etc/localtime &amp;&amp; \\\n  echo <span class=\"token string\">\"$timezone\"</span> <span class=\"token punctuation\">></span> /etc/timezone &amp;&amp; \\\n  apk del tzdata\n\n<span class=\"token keyword\">RUN</span> touch /var/log/cron.log\n\n<span class=\"token keyword\">CMD</span> echo <span class=\"token string\">\"30 8 * * * echo 'Wake Up!' >> /var/log/cron.log 2>&amp;1\"</span> <span class=\"token punctuation\">|</span> \\\n  crontab <span class=\"token punctuation\">-</span> &amp;&amp; \\\n  crond <span class=\"token punctuation\">-</span>f <span class=\"token punctuation\">-</span>L /dev/stdout</code></pre></div><p>如上，通过 tzdata 来配置时区，将时间调整成北京时间，进而再执行每日 8:30 的 cronjob，以确保在北京时间的早晨执行某一个命令。</p></section>","frontmatter":{"date":"2019-08-25","title":"Cron in Docker","category":"Docker"}}},{"node":{"id":"79d162bf-9a29-5ead-9736-40e96c0ba54d","html":"<p>在 Docker 开发的过程中，可能会产生很多无用的临时 Docker Image。这些 Image 很可能没有 Tag，在 <code class=\"language-text\">docker image ls</code> 显示的时候，Tag 一列显示为 <code class=\"language-text\">&lt;none&gt;</code>。</p>\n<p>要批量清除这些 Image，可以使用如下的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker <span class=\"token function\">rm</span> <span class=\"token variable\"><span class=\"token variable\">$(</span>docker images -f <span class=\"token string\">\"dangling=true\"</span> -q --no-trunc<span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果需要强制删除，可以将 <code class=\"language-text\">rm</code> 改为 <code class=\"language-text\">rmi</code>。</p>\n<p>这里，<code class=\"language-text\">docker images -f &quot;dangling-true&quot;</code> 命令会列出所有没有 Tag 标记的 Image，加上 <code class=\"language-text\">-q</code> 标记后，将会只列出每个 Image 的 ID，<code class=\"language-text\">--no-trunc</code> 保证显示的是完整的 ID 而不仅仅只是 ID 的前几位。</p>\n<p>再配合 <code class=\"language-text\">docker rm</code> 就可以将这批 Image 全部一次性删除了。</p>","frontmatter":{"date":"2019-08-22","title":"Remove Docker Images without Tag","category":"Docker"}}},{"node":{"id":"e2354d18-f7fe-5c38-aab3-1be6a207c601","html":"<p>在 Docker 开发的过程中，有时会有脚本出错，导致执行结果不及预期的情况。这种错误有时是环境导致的，在非 Docker 环境下无法重现。如果需要通过构建 Docker 添加诸如日志之类的信息来了解具体可能出错的原因，不免有些曲折。可以考虑直接在 Docker 环境下运行 Bash 命令，通过执行脚本中的语句，来查找可能出现问题的原因。</p>\n<p>要在 Docker 环境下执行 Bash 脚本，可以遵循以下的步骤：</p>\n<ol>\n<li>首先，需要知道当前运行 Docker 的容器 ID</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker container <span class=\"token function\">ls</span></code></pre></div>\n<p>上述命令会列出所有的容器，找到需要调试的那一个即可。</p>\n<ol start=\"2\">\n<li>在该容器环境内执行 Bash 命令</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token builtin class-name\">exec</span> -ti xxx /bin/bash</code></pre></div>\n<p>这里，<code class=\"language-text\">xxx</code> 就是第一步找到的 Container ID。上述命令用到了两个参数，<code class=\"language-text\">-t</code> 和 <code class=\"language-text\">-i</code>。<code class=\"language-text\">-t</code> 是 <code class=\"language-text\">--tty</code> 的缩写，用于让 Docker 将用户的终端和 stdin/stdout 关联起来；<code class=\"language-text\">-i</code> 是 <code class=\"language-text\">--interactive</code> 的缩写，用于让 Docker 在执行命令的时候允许用户进行交互式的输入输出。</p>\n<p>如果只是希望执行一个语句并输出结果（比如 <code class=\"language-text\">echo</code> 一个字符串），那么 <code class=\"language-text\">-t</code> 就足够了，不需要 <code class=\"language-text\">-i</code>。但是对于需要在 Docker 环境下输入 Bash 命令并检查执行结果的情况来说，<code class=\"language-text\">-i</code> 就是必须的。</p>\n<p>一个输出 Hello World 的简单例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token builtin class-name\">exec</span> -t <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hello world\"</span></code></pre></div>\n<p>另外，可以通过如下的命令知道，<code class=\"language-text\">docker exec</code> 运行的默认环境是在 <code class=\"language-text\">/</code> 下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token builtin class-name\">exec</span> -t <span class=\"token builtin class-name\">pwd</span> <span class=\"token comment\"># output: /</span></code></pre></div>\n<p>如需修改这一默认行为，可以通过 <code class=\"language-text\">-w</code> 参数（或 <code class=\"language-text\">--workdir</code>）来执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token builtin class-name\">exec</span> -w /root -t xxx <span class=\"token builtin class-name\">pwd</span> <span class=\"token comment\"># output: /root</span></code></pre></div>","frontmatter":{"date":"2019-07-25","title":"Execute Bash in Docker","category":"Docker"}}},{"node":{"id":"ba0646f1-7f98-52f0-ae94-e37849613790","html":"<p>Alpine 是 Docker 中非常流行的镜像，因为它体积小（5 MB 左右），且包管理机制友善。然而即使体积小，一旦网络条件受到限制，使用 Alpine 安装依赖依然十分费劲。这让 Docker 镜像的安装变得非常缓慢且容易失败。</p>\n<p>假设原先的 Dockerfile 如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>edge\n\n<span class=\"token keyword\">RUN</span> apk update &amp;&amp; \\\n  <span class=\"token comment\"># ...</span></code></pre></div>\n<p>那么可以考虑改用国内的镜像源来加速网络下载过程：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>edge\n\n<span class=\"token keyword\">RUN</span> echo <span class=\"token string\">'http://mirrors.aliyun.com/alpine/edge/community/'</span> <span class=\"token punctuation\">></span> \\\n    /etc/apk/repositories &amp;&amp; \\\n  echo <span class=\"token string\">'http://mirrors.aliyun.com/alpine/edge/main/'</span> <span class=\"token punctuation\">></span><span class=\"token punctuation\">></span> \\\n    /etc/apk/repositories &amp;&amp; \\\n  apk update &amp;&amp; \\\n  <span class=\"token comment\"># ...</span></code></pre></div>\n<p>除了上面提到的<a href=\"https://mirrors.aliyun.com/alpine/\">阿里镜像</a>之外，<a href=\"https://mirrors.tuna.tsinghua.edu.cn/alpine/\">清华</a>、<a href=\"https://mirrors.nju.edu.cn/alpine/\">南大</a>、<a href=\"https://mirrors.ustc.edu.cn/alpine/\">中科大</a>等镜像也可以考虑。更多镜像及其对应的网络状态可以在<a href=\"https://mirrors.alpinelinux.org/\">这里</a>找到。</p>\n<p>注意使用的镜像版本必须与 Docker 需要使用的版本保持一致。如上例中，Docker 需要基于 <code class=\"language-text\">alpine:edge</code>，那么在设置镜像的使用，也应该使用 <code class=\"language-text\">edge</code> 的版本（在 URL 中可以找到 <code class=\"language-text\">/alpine/edge/</code>）。</p>","frontmatter":{"date":"2019-07-24","title":"Alpine Mirror","category":"Docker"}}},{"node":{"id":"8cc27e26-deaf-5453-b20c-db780a4af116","html":"<p>以下介绍一些系统上安装 Docker 的步骤。</p>\n<section><h2>Raspberry Pi</h2><ol>\n<li>安装一些前置依赖</li>\n</ol><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token punctuation\">\\</span>\n  apt-transport-https ca-certificates software-properties-common -y</code></pre></div><ol start=\"2\">\n<li>安装 Docker</li>\n</ol><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -fsSL get.docker.com -o get-docker.sh <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sh</span> get-docker.sh</code></pre></div><p>这里直接使用了 <a href=\"http://get-docker.sh\">get-docker.sh</a> 提供的安装脚本。</p><ol start=\"3\">\n<li>让当前用户可以使用 Docker</li>\n</ol><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">usermod</span> -aG docker pi</code></pre></div><ol start=\"4\">\n<li>导入 Docker CPG key</li>\n</ol><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">curl</span> https://download.docker.com/linux/raspbian/gpg</code></pre></div><ol start=\"5\">\n<li>设置 Docker Repo 地址</li>\n</ol><p>在 <code class=\"language-text\">/etc/apt/sources.list</code> 中增加如下行：</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">deb https://download.docker.com/linux/raspbian/ stretch stable</code></pre></div><ol start=\"6\">\n<li>更新系统</li>\n</ol><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> update\n<span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> upgrade</code></pre></div><ol start=\"7\">\n<li>启动 Docker 服务</li>\n</ol><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">systemctl start docker.service</code></pre></div></section>\n<section><h2>MacOS</h2><p>可以直接使用 Homebrew 进行安装：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">brew cask <span class=\"token function\">install</span> docker</code></pre></div><p>安装完成后，在 Application 中找到 Docker 并启动，按提示信息一步步走就可以了。</p></section>\n<section><h2>运行</h2><p>完成后，可以试试如下的 Docker 命令，如果可以正常输出内容，安装本身就没有问题了：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker info</code></pre></div></section>\n<section><h2>参考</h2><ul>\n<li><a href=\"https://blog.docker.com/2019/03/happy-pi-day-docker-raspberry-pi/\">https://blog.docker.com/2019/03/happy-pi-day-docker-raspberry-pi/</a></li>\n</ul></section>","frontmatter":{"date":"2019-07-23","title":"Docker Installation","category":"Docker"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"Docker"}}}