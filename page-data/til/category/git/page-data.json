{"componentChunkName":"component---src-templates-til-category-js","path":"/til/category/git","webpackCompilationHash":"d0c1c456129354e33ddb","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"f512f692-4d3c-5bbc-9056-f9b0b5e9a702","html":"<p>在实际的开发过程中，经常有多分支并发操作的情况，比如：</p>\n<ol>\n<li>PC 软件需要维护多个版本，在新的版本分支上开发新功能，同时维护旧的版本以修复问题；</li>\n<li>针对 Gerrit 这类只允许单 commit 迁入的工具，一个版本开发多个功能，可能需要分成多个分支同时进行</li>\n</ol>\n<p>这种情况下，在版本间切换往往有两个常见的方式：</p>\n<ol>\n<li>将当前的代码 stash 后，切换分支，进行对应的处理，处理完了再回到原来的分支 <code class=\"language-text\">git stash pop</code> 继续原先的开发工作；</li>\n<li>直接 <code class=\"language-text\">git clone</code> 一个新的仓库，在上面完成必要的工作</li>\n</ol>\n<p>第一种方案的问题主要是，切换多次的话，很容易搞不清楚当前分支下还有哪些是 stash 的，管理起来有点麻烦。有时候方便起见，也会直接将当前的内容 commit 到分支上，再进行切换。考虑到 git hook 的存在，commit 可能还需要加上 <code class=\"language-text\">--no-verify</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> <span class=\"token function\">add</span> -A <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> commit -m <span class=\"token string\">\"wip\"</span> --no-verify</code></pre></div>\n<p>第二种方案的问题主要是，多个文件仓库重复下载了多次 <code class=\"language-text\">.git</code> 目录，在一些大型项目中，这里会导致大量的硬盘空间被浪费。</p>\n<p>Git 在 2.5 版本中提供了 worktree 的功能，用于解决这一痛点。在一个 Git 项目中，只需要执行如下的命令，就可以新创建一个文件仓库：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree <span class=\"token function\">add</span> -b new-branch-name /path/to/folder origin/branch/name</code></pre></div>\n<p>新创建的文件仓库被放在 <code class=\"language-text\">/path/to/folder</code> 中，使用的仓库名称是 <code class=\"language-text\">new-branch-name</code>，基于 <code class=\"language-text\">origin</code> 上的 <code class=\"language-text\">branch/name</code>。如果只需要使用一个已经存在的分支，可以简化成：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree <span class=\"token function\">add</span> /path/to/folder local/branch/name</code></pre></div>\n<p>之后，在 <code class=\"language-text\">/path/to/folder</code> 中就可以进行常规的开发了。值得一提的是，原 Git 目录下的 Hook 文件也会一并同步到新的工作目录下，可以直接使用。通过查看目录下的文件，不难发现 Git 的同步方式。事实上，在 WorkTree 目录下，并没有一个 <code class=\"language-text\">.git</code> 目录，取而代之的，只有一个 <code class=\"language-text\">.git</code> 文件，里面标注了真正的 <code class=\"language-text\">.git</code> 目录应该去那里查找。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">gitdir: /path/to/actual/.git/worktrees/name</code></pre></div>\n<p>也正因为如此，WorkTree 下所有的 Git 配置都是同步的。</p>\n<p>如果需要查看当前的 Git 中到底有多少个 WorkTree，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree list</code></pre></div>\n<p>命令会列出所有 WorkTree 的目录以及当前使用的分支名称。</p>\n<p>在开发完成后，如果希望删除 WorkTree，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree remove /path/to/folder</code></pre></div>\n<p>删除完成后，可以通过 <code class=\"language-text\">git worktree list</code> 来检查是否真的被删除了。</p>\n<p>延伸阅读：</p>\n<ul>\n<li><a href=\"https://git-scm.com/docs/git-worktree\">官方文档</a></li>\n<li><a href=\"https://spin.atomicobject.com/2016/06/26/parallelize-development-git-worktrees/\">Parallelize Development Using Git Worktrees</a></li>\n<li><a href=\"https://www.saltycrane.com/blog/2017/05/git-worktree-notes/\">git worktree notes</a></li>\n</ul>","frontmatter":{"date":"2019-09-22","title":"Git Worktree","category":"Git"}}},{"node":{"id":"e67d176b-9712-599d-a833-f4bdbec4db4c","html":"<p>默认情况下，使用 <code class=\"language-text\">git pull</code> 拉取最新代码的时候，Git 会触发 <code class=\"language-text\">git merge</code> 来进行远端代码和本地代码的合并。如果两份代码之间没有冲突，那么 Merge 行为可以进行 Fast Forward，最终的结果是比较“干净”的 Commit；然而，如果 Fast Forward 无法进行，那么最终的显示效果，是 git 的历史中会多出一条 Merge 的 commit。</p>\n<p>在绝大多数情况下，这类 Merge commit 都是多余的。这种时候，一般会建议使用 <code class=\"language-text\">git pull --rebase</code> 命令来拉取代码。这样，拿到最新代码后，Git 会使用 rebase 而不是 merge 来进行远端代码和本地代码的合并（关于 Merge 和 Rebase 的一些讨论，可以参考 Atlassian 的<a href=\"https://www.atlassian.com/git/tutorials/merging-vs-rebasing\">文章</a>）。</p>\n<p>当然，每次都这么写会比较繁琐。一个简单的方法，是通过 Shell 进行下面的 Git 配置：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> config --global pull.rebase <span class=\"token boolean\">true</span></code></pre></div>\n<p>或者，等价的，可以在 <code class=\"language-text\">~/.gitconfig</code> 文件中，增加如下的配置信息：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[pull]\n  rebase = true</code></pre></div>\n<p>（针对 Git 版本小于 1.7.9 的情况，配置可以参考<a href=\"https://coderwall.com/p/tnoiug/rebase-by-default-when-doing-git-pull\">这里</a>）</p>\n<p>如此一来，<code class=\"language-text\">git pull</code> 的默认行为就会从 merge 变成 rebase。</p>\n<p>在这种情况下，如果希望使用 merge 的行为，可以写 <code class=\"language-text\">git pull --no-rebase</code>。</p>","frontmatter":{"date":"2019-09-17","title":"Git Pull Rebase","category":"Git"}}},{"node":{"id":"879a3a18-a41e-536a-aa89-ce8d427e2f9a","html":"<p>可以使用 Git 命令行工具获取到当前使用的分支名称，最新的 Git Commit ID 等信息。然而，在不借助 Git 命令的情况下，依然可以通过 .git 文件，找到这些信息。</p>\n<p>在 .git 文件夹中，<code class=\"language-text\">HEAD</code> 文件记录了当前分支的指向。文件内容 <code class=\"language-text\">refs</code> 后面跟着的就是分支名。这个分支名亦是一个路径，在 .git 目录下使用这个相对路径可以得到当前分支指向的头部 Commit ID。</p>\n<p>举个例子：</p>\n<p>发现 <code class=\"language-text\">./.git/HEAD</code> 中的内容是：<code class=\"language-text\">ref: refs/heads/master</code>，通过查看 <code class=\"language-text\">./.git/refs/heads/master</code> 文件中的内容，就可以知道当前的头部 Commit ID。同样，去除 <code class=\"language-text\">refs/heads</code> 之后，就可以得到当前的分支名称，即 <code class=\"language-text\">master</code>。</p>\n<p>对应的 Node.js 代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> git <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span><span class=\"token function\">cwd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'.git'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> head <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>git<span class=\"token punctuation\">,</span> <span class=\"token string\">'HEAD'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ref <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ref: '</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> commit <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>git<span class=\"token punctuation\">,</span> ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> branch <span class=\"token operator\">=</span> ref<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token string\">'refs/heads/'</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>branch<span class=\"token punctuation\">,</span> commit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-07-22","title":"Get Branch Name & Commit ID without Git","category":"Git"}}},{"node":{"id":"a986b885-43e4-5bbb-bf5b-22e92eea167f","html":"<p>在 Git 的一些操作中，可能会中途停下来，等待用户输入的操作。比如，<code class=\"language-text\">git rebase -i</code> 或 <code class=\"language-text\">git ammend</code> 的时候。在完成操作前，Git 会打开 Vim（或其他默认的编辑器）等待用户对 commit message 做最后的处理。只要用户保存并退出，rebase 的过程就完成了。</p>\n<p>如果在这个等待确认的过程中，希望可以中断整个过程，使用 <code class=\"language-text\">Ctrl+C</code> 是不行的。如果使用 <code class=\"language-text\">Ctrl+C</code>，Vim 可能会提示用 <code class=\"language-text\">qa!</code> 来放弃所有修改并退出 Vim。但这个只是退出了 Vim，Git 依然会继续接下来的流程，并没有真正达到中断 Git 的目的。</p>\n<p>事实上，Vim 允许以 error code 退出，使用如下的命令：<code class=\"language-text\">:cq</code>。</p>\n<p>更多关于这个命令的说明，可以使用  <code class=\"language-text\">:help cq</code> 来查看。以 error code 退出之后，Git 就不会再继续接下来的流程了。</p>","frontmatter":{"date":"2019-07-14","title":"Abort Git Rebase Process","category":"Git"}}},{"node":{"id":"566acf1c-1dd4-5534-8451-e62f063b53eb","html":"<p><code class=\"language-text\">rev-parse</code> 并不是 Git 中一个不常用的命令。Git 的一些命令底层会使用 <code class=\"language-text\">rev-parse</code> 来处理输入的参数。</p>\n<p>通过 <code class=\"language-text\">rev-parse</code> 可以获得一些有用的 Git 数据，比如：</p>\n<ul>\n<li>获取当前的 commit id</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rev-parse HEAD</code></pre></div>\n<ul>\n<li>获取当前的分支名</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rev-parse --symbolic-full-name --abbrev-ref HEAD</code></pre></div>","frontmatter":{"date":"2019-07-08","title":"git rev-parse","category":"Git"}}},{"node":{"id":"c055ca35-123a-5708-b99a-56d5c8900e2a","html":"<p>对于有多个 Git 仓库的情况，不同的仓库可能需要配置不同的用户信息。</p>\n<p>一种麻烦的方案是，每个仓库都配置一个本地的 Git 配置，不使用全局的设置，就不会有问题。但是这样配置非常的麻烦，也容易忘。Git 提供了配置覆盖的功能，可以指定某一子目录，使用另外一个指定的 Git 配置覆盖默认的全剧配置。</p>\n<p>如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[includeIf &quot;gitdir:~/work/github/&quot;]\n    path = ~/work/github/.gitconfig</code></pre></div>\n<p>这个配置指定了在 <code class=\"language-text\">~/work/github/</code> 目录下，除了全局的 <code class=\"language-text\">.gitconfig</code> 文件之外，读取 <code class=\"language-text\">~/work/github/.gitconfig</code> 文件对配置进行覆盖改写。在 <code class=\"language-text\">~/work/github/.gitconfig</code> 的优先级高于 <code class=\"language-text\">~/.gitconfig</code> 的配置，会优先使用，没有定义的部分才会去全局中找。</p>","frontmatter":{"date":"2019-05-19","title":"Multiple Git Configuration","category":"Git"}}},{"node":{"id":"12c6876d-9c2a-557c-829e-8ca5da20129a","html":"<p>下面的脚本，执行之后，可以完成 <code class=\"language-text\">git clone</code> 并 <code class=\"language-text\">cd</code> 至目标文件夹内。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">!</span>f<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  local tmp<span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>mktemp<span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span>\n  local repo_name<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">git</span> clone <span class=\"token variable\">$@</span> --progress 2<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span>1 <span class=\"token operator\">|</span> <span class=\"token function\">tee</span> <span class=\"token variable\">$tmp</span><span class=\"token punctuation\">;</span>\n  repo_name<span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">awk</span> -F\\<span class=\"token string\">' '</span>/Cloning into/ <span class=\"token punctuation\">{</span>print $2<span class=\"token punctuation\">}</span>' $tmp<span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">rm</span> <span class=\"token variable\">$tmp</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">cd</span> <span class=\"token variable\">$repo_name</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nf</code></pre></div>\n<p>一些说明：</p>\n<ul>\n<li><code class=\"language-text\">mktemp</code> 可以创建一个临时文件，文件路径存放在 <code class=\"language-text\">tmp</code> 变量中</li>\n<li><code class=\"language-text\">git clone $@</code> 中的 <code class=\"language-text\">$@</code> 是执行脚本时候所有的传入参数</li>\n<li><code class=\"language-text\">---progress 2&gt;&amp;1</code> 会将 Git clone 命令的结果输出。这里，默认情况下，clone 的过程数据只有在 error stream 输出到 terminal 的时候，才会显示。因为这里的命令需要将内容通过管道输出到 <code class=\"language-text\">tmp</code> 临时文件中，所以默认情况下 Git 就不会输出过程的数据了。为了能够让 Git 输出这部分内容，需要加上 <code class=\"language-text\">--progress</code></li>\n<li><code class=\"language-text\">tee $tmp</code> 将管道的数据输出到临时文件中</li>\n<li><code class=\"language-text\">awk -F\\&#39; &#39;/Cloning into/ {print $2}&#39; $tmp</code> 的部分，会从输出的数据中，寻找 <code class=\"language-text\">Cloning into</code> 的输出，然后找到具体 clone 到了哪个文件夹中</li>\n</ul>","frontmatter":{"date":"2019-05-17","title":"Command to enter folder after git clone","category":"Git"}}},{"node":{"id":"9317a27f-2a9e-5e2c-83e9-748235da9f67","html":"<p>假设发现一个文件在历史版本中存在，但是当前不存在了，那么可能就需要知道是在什么时候，因为什么原因对文件做了删除。下面的命令可以一次性找出某一个文件的所有记录：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> log --full-history -- <span class=\"token punctuation\">[</span>file path<span class=\"token punctuation\">]</span></code></pre></div>\n<p>如果只需要看最后一条记录（也就是被删除的那条记录），可以用：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> log --full-history -1 -- <span class=\"token punctuation\">[</span>file path<span class=\"token punctuation\">]</span></code></pre></div>","frontmatter":{"date":"2019-05-15","title":"Deletion of file in git","category":"Git"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"Git"}}}