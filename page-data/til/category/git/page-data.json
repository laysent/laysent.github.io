{"componentChunkName":"component---src-templates-til-category-js","path":"/til/category/git","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"cb888251-ad71-502a-a55d-4f215d5bba15","html":"<p>在 <code class=\"language-text\">~/.gitconfig</code> 中进行如下配置（或者使用命令：<code class=\"language-text\">git config --global diff.noprefix true</code>）：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">[diff]\n    noprefix = true</code></pre></div>\n<p>之后，Git 输出的 diff 内容，比较的文件名前将不再包含 <code class=\"language-text\">a/</code> 和 <code class=\"language-text\">b/</code> 这样的前缀。</p>\n<p>举例来说，在配置前，使用 <code class=\"language-text\">git diff</code> 命令，看到的输出可能如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">diff --git a/package.json b/package.json\nindex ac6f0b2..f937b7b 100644\n<span class=\"token coord\">--- a/package.json</span>\n<span class=\"token coord\">+++ b/package.json</span>\n<span class=\"token coord\">@@ -13,7 +13,7 @@</span>\n<span class=\"token unchanged\">   \"bugs\": {\n     \"url\": \"https://github.com/laysent/some-codemod/issues\"\n   },\n</span><span class=\"token deleted-sign deleted\">-  \"version\": \"0.1.2\",\n</span><span class=\"token inserted-sign inserted\">+  \"version\": \"0.2.0\",\n</span><span class=\"token unchanged\">   \"license\": \"MIT\",\n   \"scripts\": {\n     \"test\": \"jest\"</span></code></pre></div>\n<p>而进行了配置之后，输出如下：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\"><span class=\"gatsby-highlight-code-line\">diff --git package.json package.json</span>index ac6f0b2..f937b7b 100644\n<span class=\"token coord\">--- package.json</span>\n<span class=\"token coord\">+++ package.json</span>\n<span class=\"token coord\">@@ -13,7 +13,7 @@</span>\n<span class=\"token unchanged\">   \"bugs\": {\n     \"url\": \"https://github.com/laysent/some-codemod/issues\"\n   },\n</span><span class=\"token deleted-sign deleted\">-  \"version\": \"0.1.2\",\n</span><span class=\"token inserted-sign inserted\">+  \"version\": \"0.2.0\",\n</span><span class=\"token unchanged\">   \"license\": \"MIT\",\n   \"scripts\": {\n     \"test\": \"jest\"</span></code></pre></div>\n<p>此时，无论是直接在终端复制这个文件名，还是直接点击文件名跳转打开，都比较容易。</p>\n<p>（来源：<a href=\"https://twitter.com/brandur/status/1182066723337293828\">tweet</a> from <a href=\"https://twitter.com/brandur\">@brandur</a>）</p>\n<p>需要注意的一点是，如果配置了 <code class=\"language-text\">noprefix</code>，那么在进行 <code class=\"language-text\">git diff</code> 创建 Patch 文件并通过 <code class=\"language-text\">git apply</code> 提交修改的时候，可能会遇到 Git 的报错：</p>\n<blockquote>\n<p>error: git diff header lacks filename information when removing 1 leading pathname component (line 5)</p>\n</blockquote>\n<p>原因就是生成的 Patch 文件，目录名称没有了前缀。针对这种情况，可以改用下面的方案进行 <code class=\"language-text\">git apply</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> apply -p0 change.patch</code></pre></div>\n<p>这里，<code class=\"language-text\">-p0</code> 表示 Git 在进行补丁操作的时候，需要先删除<strong>零</strong>层前缀字符，然后再读取真实的目录地址。这里，Git 会根据 <code class=\"language-text\">/</code> 字符将目录地址拆分开来，然后删除必要的层数，将剩下的部分作为文件地址。默认值是 <code class=\"language-text\">1</code>，也就是会将 <code class=\"language-text\">a/package.json</code> 当作 <code class=\"language-text\">package.json</code> 目录进行处理。如果改成 <code class=\"language-text\">-p2</code>，那么 <code class=\"language-text\">a/dir/file</code> 会被当成 <code class=\"language-text\">file</code> 目录进行处理。</p>\n<p>相关的说明可以参考 <a href=\"https://git-scm.com/docs/git-apply#Documentation/git-apply.txt--pltngt\">Git 文档</a>。</p>","frontmatter":{"date":"2019-12-12","title":"Git Diff Filenames","category":"Git"}}},{"node":{"id":"dd6397f0-93cc-5c70-af8e-6a02ee16d25b","html":"<p>在实际开发过程中，可能会遇到这样的问题：因为重构，一些文件从 A 目录移动到了 B 目录，而后又对文件内容做了修改。这时，如果希望将其中的某些修改（比如和安全相关的布丁）应用回重构前的代码，就显得比较困难了。直接通过 Git 进行 cherry-pick 并不顺利，因为具体修改的 commit 中并不包含文件目录移动的信息。</p>\n<p>可以简单使用下面的命令来构建一个场景：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> init<span class=\"token punctuation\">;</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"console.log('hello world');\"</span> <span class=\"token operator\">></span> origin.js<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> -A<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"first commit\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">git</span> checkout -b <span class=\"token string\">\"new_branch\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">mv</span> origin.js modified.js<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> -A<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"rename commit\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"console.log('hi')\"</span> <span class=\"token operator\">>></span> origin.js<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> -A<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"modify commit\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">git</span> checkout master<span class=\"token punctuation\">;</span></code></pre></div>\n<p>这时候，希望直接将 <code class=\"language-text\">new_branch</code> 中最后一个 commit cherry-pick 到 master 是比较困难的。</p>\n<p>针对这种情况，可以考虑使用 Git Patch 功能。首先将修改的部分生成 Patch 文件，然后手动将 Patch 中的目录映射关系处理正确，最终将修改后的 Patch 应用到重构前的某个旧版本中。</p>\n<section><h2>创建 Patch</h2><p><code class=\"language-text\">git diff</code> 命令输出的结果就是一个 Patch，可以简单的将输出的内容存储到文件中，就生成了一个当前未签入内容的 Patch 文件：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">diff</span> <span class=\"token operator\">></span> change.patch</code></pre></div><p>如果希望只是将部分修改的文件生成 Patch，可以先将需要的部分放入缓冲区中（<code class=\"language-text\">git add</code>），然后通过 <code class=\"language-text\">git diff --cached</code> 命令，仅针对缓冲区中的修改生成 Patch 文件。</p><p>以上这些生成的方案，比较适合为没有写权限的 Git 仓库提交修改的场景。直接将 Patch 文件通过 email 的形式发送，就可以进行修改的讨论了。</p><p>注：如果改动包含了二进制文件的修改，可以通过增加 <code class=\"language-text\">--binary</code> 命令来获取到这部分文件的修改 Patch。</p><p>针对已经签入的提交，也可以通过 <code class=\"language-text\">git format-patch</code> 或 <code class=\"language-text\">git show</code> 命令来生成 commit 对应的 Patch 文件。</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> show commit-id <span class=\"token operator\">></span> change.patch</code></pre></div><p>可以生成单个 commit 的 Patch 文件；如果希望生成一组 commit 的 Patch，可以使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> format-patch A<span class=\"token punctuation\">..</span>B</code></pre></div><p>上面的命令会生成为从 A 到 B 之间的所有 commit 生成对应的 Patch 文件（包含 B commit，但是不包含 A commit；如果需要包含 A，可以使用 <code class=\"language-text\">A^..B</code> 命令）。或者，如果希望将所有的改动合成到一个 Patch 文件中，可以使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> format-patch A<span class=\"token punctuation\">..</span>B --stdout <span class=\"token operator\">></span> changes.patch</code></pre></div><p>上面的 A 和 B 除了可以是 commit id 之外，也可以是 Branch 或者 Tag。</p></section>\n<section><h2>应用 Patch</h2><p>将生成的 Patch 文件应用到当前的代码中，只需要使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> apply change.patch</code></pre></div><p>Git 会将 Patch 中提到的修改应用到当前的项目中，但改动不会被自动提交；如果希望直接将 Patch 以 commit 的形式进行提交，可以直接使用：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> am change.patch</code></pre></div></section>\n<section><h2>关于 Patch</h2><p>Git 生成的 Patch 文件，除了提交作者、commit message 这些信息外，核心的部分是通过 <code class=\"language-text\">diff</code> 命令生成的修改内容。如果只是需要修改一下文件的位置，应该可以通过观察文件直接找到。更多关于 <code class=\"language-text\">diff</code> 命令生成的补丁文件的格式，可以参考 <a href=\"https://en.wikipedia.org/wiki/Diff\">Wikipedia</a> 中的相关描述。</p></section>","frontmatter":{"date":"2019-12-11","title":"Apply Git Patch","category":"Git"}}},{"node":{"id":"93b6f6b5-db64-5bd8-827b-e4d39247908f","html":"<p>在 Git 中，可以通过 <code class=\"language-text\">cherry-pick</code> 命令将某一个 commit 选到当前的分支上。在 Git 1.7.2+ 中，可以支持将一组连续的 commit 全部都选到当前的分支上。</p>\n<p>使用的语法是：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> cherry-pick A<span class=\"token punctuation\">..</span>B</code></pre></div>\n<p>或者</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> cherry-pick A^<span class=\"token punctuation\">..</span>B</code></pre></div>\n<p>这里，<code class=\"language-text\">A..B</code> 要求 A 是在 B 的前面（更老）。在实际挑选的过程中，A 并不会被选入，实际选入的是 A 之后的下一个 commit，直到 B 为止。如果希望选择也包括 A 这个提交，可以使用 <code class=\"language-text\">A^..B</code> 的语法。</p>","frontmatter":{"date":"2019-12-10","title":"Cherry-pick Range of Git Commits","category":"Git"}}},{"node":{"id":"b35a1817-487c-5f69-97a0-2421bd23089a","html":"<p>在 Git 中，可以通过 <code class=\"language-text\">git checkout -</code> 切换会上一个分支。重复使用该命令，就会在最近的两个切换的分支上往复。</p>\n<p>需要注意的一点是，虽然 git worktree 之间是共用同一个 <code class=\"language-text\">.git</code> 数据的，但是切换的分支也是当前目录下最新使用的两个分支。其他 worktree 上的分支切换记录不会影响到当前目录的切换行为。</p>","frontmatter":{"date":"2019-12-09","title":"Checkout Previous Branch","category":"Git"}}},{"node":{"id":"f512f692-4d3c-5bbc-9056-f9b0b5e9a702","html":"<p>在实际的开发过程中，经常有多分支并发操作的情况，比如：</p>\n<ol>\n<li>PC 软件需要维护多个版本，在新的版本分支上开发新功能，同时维护旧的版本以修复问题；</li>\n<li>针对 Gerrit 这类只允许单 commit 迁入的工具，一个版本开发多个功能，可能需要分成多个分支同时进行</li>\n</ol>\n<p>这种情况下，在版本间切换往往有两个常见的方式：</p>\n<ol>\n<li>将当前的代码 stash 后，切换分支，进行对应的处理，处理完了再回到原来的分支 <code class=\"language-text\">git stash pop</code> 继续原先的开发工作；</li>\n<li>直接 <code class=\"language-text\">git clone</code> 一个新的仓库，在上面完成必要的工作</li>\n</ol>\n<p>第一种方案的问题主要是，切换多次的话，很容易搞不清楚当前分支下还有哪些是 stash 的，管理起来有点麻烦。有时候方便起见，也会直接将当前的内容 commit 到分支上，再进行切换。考虑到 git hook 的存在，commit 可能还需要加上 <code class=\"language-text\">--no-verify</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> <span class=\"token function\">add</span> -A <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> commit -m <span class=\"token string\">\"wip\"</span> --no-verify</code></pre></div>\n<p>第二种方案的问题主要是，多个文件仓库重复下载了多次 <code class=\"language-text\">.git</code> 目录，在一些大型项目中，这里会导致大量的硬盘空间被浪费。</p>\n<p>Git 在 2.5 版本中提供了 worktree 的功能，用于解决这一痛点。在一个 Git 项目中，只需要执行如下的命令，就可以新创建一个文件仓库：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree <span class=\"token function\">add</span> -b new-branch-name /path/to/folder origin/branch/name</code></pre></div>\n<p>新创建的文件仓库被放在 <code class=\"language-text\">/path/to/folder</code> 中，使用的仓库名称是 <code class=\"language-text\">new-branch-name</code>，基于 <code class=\"language-text\">origin</code> 上的 <code class=\"language-text\">branch/name</code>。如果只需要使用一个已经存在的分支，可以简化成：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree <span class=\"token function\">add</span> /path/to/folder local/branch/name</code></pre></div>\n<p>之后，在 <code class=\"language-text\">/path/to/folder</code> 中就可以进行常规的开发了。值得一提的是，原 Git 目录下的 Hook 文件也会一并同步到新的工作目录下，可以直接使用。通过查看目录下的文件，不难发现 Git 的同步方式。事实上，在 WorkTree 目录下，并没有一个 <code class=\"language-text\">.git</code> 目录，取而代之的，只有一个 <code class=\"language-text\">.git</code> 文件，里面标注了真正的 <code class=\"language-text\">.git</code> 目录应该去那里查找。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">gitdir: /path/to/actual/.git/worktrees/name</code></pre></div>\n<p>也正因为如此，WorkTree 下所有的 Git 配置都是同步的。</p>\n<p>如果需要查看当前的 Git 中到底有多少个 WorkTree，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree list</code></pre></div>\n<p>命令会列出所有 WorkTree 的目录以及当前使用的分支名称。</p>\n<p>在开发完成后，如果希望删除 WorkTree，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> worktree remove /path/to/folder</code></pre></div>\n<p>删除完成后，可以通过 <code class=\"language-text\">git worktree list</code> 来检查是否真的被删除了。</p>\n<p>延伸阅读：</p>\n<ul>\n<li><a href=\"https://git-scm.com/docs/git-worktree\">官方文档</a></li>\n<li><a href=\"https://spin.atomicobject.com/2016/06/26/parallelize-development-git-worktrees/\">Parallelize Development Using Git Worktrees</a></li>\n<li><a href=\"https://www.saltycrane.com/blog/2017/05/git-worktree-notes/\">git worktree notes</a></li>\n</ul>","frontmatter":{"date":"2019-09-22","title":"Git Worktree","category":"Git"}}},{"node":{"id":"e67d176b-9712-599d-a833-f4bdbec4db4c","html":"<p>默认情况下，使用 <code class=\"language-text\">git pull</code> 拉取最新代码的时候，Git 会触发 <code class=\"language-text\">git merge</code> 来进行远端代码和本地代码的合并。如果两份代码之间没有冲突，那么 Merge 行为可以进行 Fast Forward，最终的结果是比较“干净”的 Commit；然而，如果 Fast Forward 无法进行，那么最终的显示效果，是 git 的历史中会多出一条 Merge 的 commit。</p>\n<p>在绝大多数情况下，这类 Merge commit 都是多余的。这种时候，一般会建议使用 <code class=\"language-text\">git pull --rebase</code> 命令来拉取代码。这样，拿到最新代码后，Git 会使用 rebase 而不是 merge 来进行远端代码和本地代码的合并（关于 Merge 和 Rebase 的一些讨论，可以参考 Atlassian 的<a href=\"https://www.atlassian.com/git/tutorials/merging-vs-rebasing\">文章</a>）。</p>\n<p>当然，每次都这么写会比较繁琐。一个简单的方法，是通过 Shell 进行下面的 Git 配置：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> config --global pull.rebase <span class=\"token boolean\">true</span></code></pre></div>\n<p>或者，等价的，可以在 <code class=\"language-text\">~/.gitconfig</code> 文件中，增加如下的配置信息：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[pull]\n  rebase = true</code></pre></div>\n<p>（针对 Git 版本小于 1.7.9 的情况，配置可以参考<a href=\"https://coderwall.com/p/tnoiug/rebase-by-default-when-doing-git-pull\">这里</a>）</p>\n<p>如此一来，<code class=\"language-text\">git pull</code> 的默认行为就会从 merge 变成 rebase。</p>\n<p>在这种情况下，如果希望使用 merge 的行为，可以写 <code class=\"language-text\">git pull --no-rebase</code>。</p>","frontmatter":{"date":"2019-09-17","title":"Git Pull Rebase","category":"Git"}}},{"node":{"id":"879a3a18-a41e-536a-aa89-ce8d427e2f9a","html":"<p>可以使用 Git 命令行工具获取到当前使用的分支名称，最新的 Git Commit ID 等信息。然而，在不借助 Git 命令的情况下，依然可以通过 .git 文件，找到这些信息。</p>\n<p>在 .git 文件夹中，<code class=\"language-text\">HEAD</code> 文件记录了当前分支的指向。文件内容 <code class=\"language-text\">refs</code> 后面跟着的就是分支名。这个分支名亦是一个路径，在 .git 目录下使用这个相对路径可以得到当前分支指向的头部 Commit ID。</p>\n<p>举个例子：</p>\n<p>发现 <code class=\"language-text\">./.git/HEAD</code> 中的内容是：<code class=\"language-text\">ref: refs/heads/master</code>，通过查看 <code class=\"language-text\">./.git/refs/heads/master</code> 文件中的内容，就可以知道当前的头部 Commit ID。同样，去除 <code class=\"language-text\">refs/heads</code> 之后，就可以得到当前的分支名称，即 <code class=\"language-text\">master</code>。</p>\n<p>对应的 Node.js 代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> git <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span><span class=\"token function\">cwd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'.git'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> head <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>git<span class=\"token punctuation\">,</span> <span class=\"token string\">'HEAD'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ref <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ref: '</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> commit <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>git<span class=\"token punctuation\">,</span> ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> branch <span class=\"token operator\">=</span> ref<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token string\">'refs/heads/'</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>branch<span class=\"token punctuation\">,</span> commit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"2019-07-22","title":"Get Branch Name & Commit ID without Git","category":"Git"}}},{"node":{"id":"a986b885-43e4-5bbb-bf5b-22e92eea167f","html":"<p>在 Git 的一些操作中，可能会中途停下来，等待用户输入的操作。比如，<code class=\"language-text\">git rebase -i</code> 或 <code class=\"language-text\">git ammend</code> 的时候。在完成操作前，Git 会打开 Vim（或其他默认的编辑器）等待用户对 commit message 做最后的处理。只要用户保存并退出，rebase 的过程就完成了。</p>\n<p>如果在这个等待确认的过程中，希望可以中断整个过程，使用 <code class=\"language-text\">Ctrl+C</code> 是不行的。如果使用 <code class=\"language-text\">Ctrl+C</code>，Vim 可能会提示用 <code class=\"language-text\">qa!</code> 来放弃所有修改并退出 Vim。但这个只是退出了 Vim，Git 依然会继续接下来的流程，并没有真正达到中断 Git 的目的。</p>\n<p>事实上，Vim 允许以 error code 退出，使用如下的命令：<code class=\"language-text\">:cq</code>。</p>\n<p>更多关于这个命令的说明，可以使用  <code class=\"language-text\">:help cq</code> 来查看。以 error code 退出之后，Git 就不会再继续接下来的流程了。</p>","frontmatter":{"date":"2019-07-14","title":"Abort Git Rebase Process","category":"Git"}}},{"node":{"id":"566acf1c-1dd4-5534-8451-e62f063b53eb","html":"<p><code class=\"language-text\">rev-parse</code> 并不是 Git 中一个不常用的命令。Git 的一些命令底层会使用 <code class=\"language-text\">rev-parse</code> 来处理输入的参数。</p>\n<p>通过 <code class=\"language-text\">rev-parse</code> 可以获得一些有用的 Git 数据，比如：</p>\n<ul>\n<li>获取当前的 commit id</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rev-parse HEAD</code></pre></div>\n<ul>\n<li>获取当前的分支名</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rev-parse --symbolic-full-name --abbrev-ref HEAD</code></pre></div>","frontmatter":{"date":"2019-07-08","title":"git rev-parse","category":"Git"}}},{"node":{"id":"c055ca35-123a-5708-b99a-56d5c8900e2a","html":"<p>对于有多个 Git 仓库的情况，不同的仓库可能需要配置不同的用户信息。</p>\n<p>一种麻烦的方案是，每个仓库都配置一个本地的 Git 配置，不使用全局的设置，就不会有问题。但是这样配置非常的麻烦，也容易忘。Git 提供了配置覆盖的功能，可以指定某一子目录，使用另外一个指定的 Git 配置覆盖默认的全剧配置。</p>\n<p>如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[includeIf &quot;gitdir:~/work/github/&quot;]\n    path = ~/work/github/.gitconfig</code></pre></div>\n<p>这个配置指定了在 <code class=\"language-text\">~/work/github/</code> 目录下，除了全局的 <code class=\"language-text\">.gitconfig</code> 文件之外，读取 <code class=\"language-text\">~/work/github/.gitconfig</code> 文件对配置进行覆盖改写。在 <code class=\"language-text\">~/work/github/.gitconfig</code> 的优先级高于 <code class=\"language-text\">~/.gitconfig</code> 的配置，会优先使用，没有定义的部分才会去全局中找。</p>","frontmatter":{"date":"2019-05-19","title":"Multiple Git Configuration","category":"Git"}}},{"node":{"id":"12c6876d-9c2a-557c-829e-8ca5da20129a","html":"<p>下面的脚本，执行之后，可以完成 <code class=\"language-text\">git clone</code> 并 <code class=\"language-text\">cd</code> 至目标文件夹内。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">!</span><span class=\"token function-name function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">tmp</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>mktemp<span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin class-name\">local</span> repo_name<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">git</span> clone <span class=\"token variable\">$@</span> --progress <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span> <span class=\"token operator\">|</span> <span class=\"token function\">tee</span> <span class=\"token variable\">$tmp</span><span class=\"token punctuation\">;</span>\n  <span class=\"token assign-left variable\">repo_name</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">awk</span> -F<span class=\"token punctuation\">\\</span><span class=\"token string\">' '</span>/Cloning into/ <span class=\"token punctuation\">{</span>print $2<span class=\"token punctuation\">}</span>' $tmp<span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">rm</span> <span class=\"token variable\">$tmp</span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin class-name\">cd</span> <span class=\"token variable\">$repo_name</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nf</code></pre></div>\n<p>一些说明：</p>\n<ul>\n<li><code class=\"language-text\">mktemp</code> 可以创建一个临时文件，文件路径存放在 <code class=\"language-text\">tmp</code> 变量中</li>\n<li><code class=\"language-text\">git clone $@</code> 中的 <code class=\"language-text\">$@</code> 是执行脚本时候所有的传入参数</li>\n<li><code class=\"language-text\">---progress 2&gt;&amp;1</code> 会将 Git clone 命令的结果输出。这里，默认情况下，clone 的过程数据只有在 error stream 输出到 terminal 的时候，才会显示。因为这里的命令需要将内容通过管道输出到 <code class=\"language-text\">tmp</code> 临时文件中，所以默认情况下 Git 就不会输出过程的数据了。为了能够让 Git 输出这部分内容，需要加上 <code class=\"language-text\">--progress</code></li>\n<li><code class=\"language-text\">tee $tmp</code> 将管道的数据输出到临时文件中</li>\n<li><code class=\"language-text\">awk -F\\&#39; &#39;/Cloning into/ {print $2}&#39; $tmp</code> 的部分，会从输出的数据中，寻找 <code class=\"language-text\">Cloning into</code> 的输出，然后找到具体 clone 到了哪个文件夹中</li>\n</ul>","frontmatter":{"date":"2019-05-17","title":"Command to enter folder after git clone","category":"Git"}}},{"node":{"id":"9317a27f-2a9e-5e2c-83e9-748235da9f67","html":"<p>假设发现一个文件在历史版本中存在，但是当前不存在了，那么可能就需要知道是在什么时候，因为什么原因对文件做了删除。下面的命令可以一次性找出某一个文件的所有记录：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> log --full-history -- <span class=\"token punctuation\">[</span>file path<span class=\"token punctuation\">]</span></code></pre></div>\n<p>如果只需要看最后一条记录（也就是被删除的那条记录），可以用：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> log --full-history -1 -- <span class=\"token punctuation\">[</span>file path<span class=\"token punctuation\">]</span></code></pre></div>","frontmatter":{"date":"2019-05-15","title":"Deletion of file in git","category":"Git"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"Git"}}}