{"componentChunkName":"component---src-templates-til-category-js","path":"/til/category/node.js","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"65cd384a-ec80-5942-bc9e-9ab8ad9814f5","html":"<p>Node.js 中的 <code class=\"language-text\">require</code> API 在加载 commonjs 模块的时候，会做两个事情：</p>\n<ol>\n<li>根据 Node.js 的算法，查找到对应的模块文件；</li>\n<li>加载查找到的模块文件并运行。</li>\n</ol>\n<p>这里，如果只是想执行第一步，但并不真的运行这个被找到的模块，可以使用 Node.js 提供的 <code class=\"language-text\">require.resolve</code> API。具体的调用示例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> modulePath <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>modulePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上面代码中，<code class=\"language-text\">modulePath</code> 是一个完整的文件路径，指向的位置就是 <code class=\"language-text\">some-package</code> 这个模块的 entry 文件（定义在 package.json 的 <code class=\"language-text\">main</code> 中）。默认情况下，这个 <code class=\"language-text\">require.resolve</code> 的查找路径是和 <code class=\"language-text\">require</code> API 一致的：在查找的时候，会从当前文件的目录开始，逐级往上查找 <code class=\"language-text\">node_modules</code> 目录下是否有需要的库。</p>\n<p>举例来说，假设有下面这样一个目录结构：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">A.js\nnode_modules\n|- some-package\n   |- index.js\n|- other-package\n   |- index.js\nutils\n|- B.js\n   node_modules\n   |- some-package\n      |- index.js</code></pre></div>\n<p>且，假设 A.js 的代码为：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./utils/B'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'A: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'A: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'other-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>B.js 的代码为：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'B: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'B: '</span><span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'other-package'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>那么，输出的结果为：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">B: utils/node_modules/some-package/index.js\nB: node_modules/other-package/index.js\nA: node_modules/some-package/index.js\nA: node_modules/other-package/index.js</code></pre></div>\n<p>但有的时候，只是希望可以使用 Node.js 的查找算法，但是查找的目录位置，并不一定是从当前文件所在的目录开始的。这种时候，就需要用到 <code class=\"language-text\">require.resolve</code> 的第二个参数了：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-package'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  paths<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'where-to-start-searching'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'other-possible-search-location'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，<code class=\"language-text\">paths</code> 是一个数组，表示所有的搜索起始位置。Node.js 会依次以这些路径为起始点，查找各个层级往上的 node_modules 目录。一旦找到需要的库，就停止查找，否则就会一直往上直到根目录。到达根目录后，当前的查找就以失败告终。如果还有其他的查找路径，就会继续上面的操作，否则程序会抛出异常。</p>\n<p>第二个参数的一个实际应用场景如下：假设有一个 CLI 可以用于代理执行 Webpack 命令，这时候就需要首先通过 <code class=\"language-text\">require.resolve</code> 命令找出当前执行 CLI 命令的目录内，Webpack 库在什么位置。然后才可以用 <code class=\"language-text\">require</code> 命令去加载真正在项目中使用到的 Webpack 版本，而不是 CLI 内部可能依赖的一个 Webpack 版本。</p>\n<p>更多关于 <code class=\"language-text\">require.resolve</code> 命令的说明，可以参考官方的<a href=\"https://nodejs.org/api/modules.html#modules_require_resolve_request_options\">文档</a>。</p>","frontmatter":{"date":"2019-11-12","title":"Require Resolve","category":"Node.js"}}},{"node":{"id":"0e49e733-98a8-5e79-bcb5-c4ef0b27aaf8","html":"<p>在 Node.js 中，可以通过使用 Performance API 来对 <code class=\"language-text\">require</code> 模块的性能进行检测。这里的 Performance 模块，是 Node.js 根据 <a href=\"https://w3c.github.io/performance-timeline/\">W3C Performance Timeline 规范</a>，实现的一套和 Web 相同的 API 接口集合。一般的时间测量，可以通过 <code class=\"language-text\">Performance.mark</code> 和 <code class=\"language-text\">Performance.measure</code> 的组合来进行，使用的方法大体上和 Web 中一致（但是需要使用 <code class=\"language-text\">PerformanceObserver</code> 来获取测量的结果，这一点和 Web 不太相同，具体可以参考官方的<a href=\"https://nodejs.org/api/perf_hooks.html\">文档</a>）。</p>\n<p>和 Web 不同的是，在 Node.js 的 Performance 模块中，还提供了一个 <a href=\"https://nodejs.org/api/perf_hooks.html#perf_hooks_performance_timerify_fn\">timerify</a> 的接口，可以简便的对一个函数进行封装，从而测量出这个函数的实际调用时间。</p>\n<p>有了这个接口，就可以很容易的测量 Node.js 中加载模块的耗时了。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">,</span>\n  PerformanceObserver\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'perf_hooks'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> mod <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'module'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmod<span class=\"token punctuation\">.</span><span class=\"token class-name\">Module</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>require <span class=\"token operator\">=</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">timerify</span><span class=\"token punctuation\">(</span>mod<span class=\"token punctuation\">.</span><span class=\"token class-name\">Module</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>require<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> obs <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PerformanceObserver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">list</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> entries <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">getEntries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  fs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./profile.json'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>entries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  obs<span class=\"token punctuation\">.</span><span class=\"token function\">disconnect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobs<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  entryTypes<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'function'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Module.require'</span><span class=\"token punctuation\">,</span>\n  buffered<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some-path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里有几点可以说明一下：</p>\n<ol>\n<li><code class=\"language-text\">mod.Module.prototype.require</code> 被 <code class=\"language-text\">timerify</code> 之后，所有模块在 <code class=\"language-text\">require</code> 的时候，都会使用被 <code class=\"language-text\">timerify</code> 过的版本；</li>\n<li>PerformanceObserver 的作用是获取 entries 的结果；</li>\n<li><code class=\"language-text\">obs.disconnect</code> 用于解除连接，不再进行后续的接听；</li>\n<li><code class=\"language-text\">obs.observer</code> 设置 <code class=\"language-text\">entryTypes: [&#39;function&#39;]</code>，确保这里 <code class=\"language-text\">timerify</code> 的结果都可以被获取到；</li>\n<li><code class=\"language-text\">obs.observer</code> 中设置 <code class=\"language-text\">buffered: true</code>，确保 observer 的回调函数不会被立刻执行，而是用 <code class=\"language-text\">setImmediate</code> 延迟调用。这样的好处是，一次 <code class=\"language-text\">require</code> 后，该模块的调用时间和该模块内部调用子模块的耗时都会一次性通过回调函数返回。（注：默认这里的值是 <code class=\"language-text\">false</code>，见<a href=\"https://nodejs.org/docs/latest-v10.x/api/perf_hooks.html#perf_hooks_performanceobserver_observe_options\">文档</a>）;</li>\n<li>官方给出的示例，还 <code class=\"language-text\">timerify</code> 了 <code class=\"language-text\">require</code> 函数（见<a href=\"https://nodejs.org/api/perf_hooks.html#perf_hooks_measuring_how_long_it_takes_to_load_dependencies\">这里</a>），这样做会导致当前模块中 <code class=\"language-text\">require</code> 的调用，生成两份 Performance 数据（一份来自 <code class=\"language-text\">require</code>，一份来自 <code class=\"language-text\">Module.require</code>）。出于精简的考虑，上面的示例代码中去掉了对 <code class=\"language-text\">require</code> 函数的 <code class=\"language-text\">timerify</code>。</li>\n</ol>\n<p>在上面的示例代码中，最终得到的结果，存放在了一个 JSON 文件内，大体的格式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"0\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"required-module-name\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Module.require\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"entryType\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"startTime\"</span><span class=\"token operator\">:</span> <span class=\"token number\">7397.399892</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"duration\"</span><span class=\"token operator\">:</span> <span class=\"token number\">112.681678</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>这里，<code class=\"language-text\">0</code> 表示第一个参数的值，对于 <code class=\"language-text\">require</code> 来说就是具体引用的模块的名称/地址；<code class=\"language-text\">name</code> 表示是哪个函数的调用，在示例中就是被 <code class=\"language-text\">timerify</code> 过的 <code class=\"language-text\">Module.require</code> 函数；<code class=\"language-text\">entryType</code> 是固定的 <code class=\"language-text\">function</code>，因为这个值是通过 <code class=\"language-text\">timerify</code> 拿到的；<code class=\"language-text\">startTime</code> 和 <code class=\"language-text\">duration</code> 分别表示调用开始的时间以及实际调用的耗时。</p>","frontmatter":{"date":"2019-11-03","title":"Require Performance in Node.js","category":"Node.js"}}},{"node":{"id":"c1119f9b-baa9-5f9c-924d-331dee578810","html":"<p>在编写 Bash 脚本的过程中，难免会遇到一些单纯用 Linux 命令很难实现的功能，比如，希望将一个文件的内容作为 JSON 的一个字段，并通过 <code class=\"language-text\">curl</code> 将这个 JSON 数据发送给服务器。如果单纯使用 Linux 的命令来拼接这个 JSON 字符串，在转意上会遇到很大的问题。但其实同样的需求，在 JavaScript 中可以通过一行命令完成：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> text<span class=\"token punctuation\">:</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>对于这样的情况，如果正好环境中有 Node.js（比如基于 Node 的 Docker 环境），就可以很方便的通过直接调用 Node 来处理这部分的需求。</p>\n<p>需要用到 <code class=\"language-text\">node.js</code> 内建的参数 <code class=\"language-text\">-e</code> 或 <code class=\"language-text\">-p</code>。</p>\n<p>对于 <code class=\"language-text\">-e</code> 这个参数（或 <code class=\"language-text\">--eval</code>），Node 会执行参数后面的字符串。类似于 <code class=\"language-text\">node file.js</code> 可以让 Node.js 执行 file.js 这个文件，<code class=\"language-text\">node -e &quot;script&quot;</code> 可以让 Node.js 执行 <code class=\"language-text\">script</code> 这串语句。需要注意的几点：</p>\n<ol>\n<li>Windows 的 CMD 不能使用单引号，只能使用双引号；Powershell 的的话，两者都是支持的；</li>\n<li><code class=\"language-text\">-e</code> 指令并不会将执行的结果输出到终端，因而如果需要 Bash 中能够用变量保存运行结果的话，需要额外使用 <code class=\"language-text\">console.log</code> 将结果输出到 stdout，然后再由 Bash 传递给需要赋值的变量。</li>\n</ol>\n<p>综上所述，上面这个 JSON 序列化的需求，就可以写成下面的这种形式：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">node -e <span class=\"token string\">\"console.log(JSON.stringify({ text: fs.readFileSync(file, 'utf8') }))\"</span></code></pre></div>\n<p>显然，对于需要赋值的情况，每次都加上 console.log 去输出结果比较的繁琐。Node.js 为此提供了另外一个可用的参数 <code class=\"language-text\">-p</code>。这个参数的表现形式和 <code class=\"language-text\">-e</code> 几乎是一样的，唯一的区别是，<code class=\"language-text\">-p</code> 会将结果默认输出到 stdout 中，不需要额外套一层 console.log 来完成这个操作。<code class=\"language-text\">-p</code> 也可以写作 <code class=\"language-text\">--print</code>。</p>\n<p>下面用一个例子来说明两者的区别：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\"><span class=\"token variable\">$(</span>node -e <span class=\"token string\">\"true\"</span><span class=\"token variable\">)</span></span></code></pre></div>\n<p>上面这个命令运行的结果将输出空字符串；而下面这个命令，则会在终端输出 <code class=\"language-text\">true</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\"><span class=\"token variable\">$(</span>node -p <span class=\"token string\">\"true\"</span><span class=\"token variable\">)</span></span></code></pre></div>\n<p>如此一来，上面的例子可以进一步转化为：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">node -p <span class=\"token string\">\"JSON.stringify({ text: fs.readFileSync(file, 'utf8') })\"</span></code></pre></div>\n<p>配合 <code class=\"language-text\">curl</code> 最终的命令大体上如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -X POST <span class=\"token punctuation\">\\</span>\n  -H <span class=\"token string\">\"Content-Type: application/json\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token variable\">$URL</span> <span class=\"token punctuation\">\\</span>\n  --data-binary <span class=\"token punctuation\">\\</span>\n    <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>node -p 'JSON.stringify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>text:fs.readFileSync<span class=\"token punctuation\">(</span><span class=\"token string\">\"filepath\"</span>,<span class=\"token string\">\"utf8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token variable\">)</span></span>')\"</span></code></pre></div>","frontmatter":{"date":"2019-09-03","title":"Eval Script via Nodejs","category":"Node.js"}}},{"node":{"id":"bdda9cc6-cfb0-59d7-9cfb-e61fc78c79e2","html":"<p>在进行网络请求的时候，有可能会遇上服务器指定链接跳转的情况。此时，无论是 301（永久转移）还是 302（暂时转移），在请求页面的时候都需要根据服务器的指示，去访问下一个链接。当然，这里下一个链接依然有可能是跳转链接，需要继续执行跳转操作。</p>\n<p>一段可用的 Node.js 代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> https <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">link</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> link<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> https <span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>link<span class=\"token punctuation\">,</span> <span class=\"token parameter\">response</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>statusCode <span class=\"token operator\">>=</span> <span class=\"token number\">300</span> <span class=\"token operator\">&amp;&amp;</span> response<span class=\"token punctuation\">.</span>statusCode <span class=\"token operator\">&lt;</span> <span class=\"token number\">400</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> location <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">[</span><span class=\"token string\">'set-cookie'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里，Node.js 处理 HTTP 和 HTTPs 请求使用的模块是不相同的，因而需要根据链接地址的 protocol 进行按需索取。同时，如果是 3xx 的 HTTP 结果，则需要进行链接跳转。可以直接读取 headers 中的 <code class=\"language-text\">location</code> 数据，找到下一步需要跳转到的位置。</p>","frontmatter":{"date":"2019-07-31","title":"Follow Redirection","category":"Node.js"}}},{"node":{"id":"0bf27b9f-dd15-55b1-b4a3-6b8583529343","html":"<p>在 Node.js 中，可以通过 <code class=\"language-text\">os.cpus()</code> 这个函数，来了解当前状态下，计算机 CPU 的一些状态。以 MacBookPro 2019 款为例，以下是一份输出的结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    model<span class=\"token punctuation\">:</span> <span class=\"token string\">'Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz'</span><span class=\"token punctuation\">,</span>\n    speed<span class=\"token punctuation\">:</span> <span class=\"token number\">2200</span><span class=\"token punctuation\">,</span>\n    times<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      user<span class=\"token punctuation\">:</span> <span class=\"token number\">239572260</span><span class=\"token punctuation\">,</span>\n      nice<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n      sys<span class=\"token punctuation\">:</span> <span class=\"token number\">133555650</span><span class=\"token punctuation\">,</span>\n      idle<span class=\"token punctuation\">:</span> <span class=\"token number\">644681690</span><span class=\"token punctuation\">,</span>\n      irq<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// 省略类似的其他十一个...</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>在这个返回的数组中，每一个元素代表一个 CPU 的线程。这台 MacBookPro 是六核（core）十二线程（processor），所以返回的数组长度是十二。具体来看每一个元素：</p>\n<ul>\n<li><code class=\"language-text\">model</code>，表示了当前 CPU 的型号</li>\n<li><code class=\"language-text\">speed</code>，表示 CPU 的运算速度，单位是 MHz</li>\n<li>\n<p><code class=\"language-text\">times</code> 表示 CPU 的使用情况，分别记录了一些时间（单位是毫秒）：</p>\n<ul>\n<li><code class=\"language-text\">user</code> 表示进程在用户模式（user mode）下使用的时间；</li>\n<li><code class=\"language-text\">nice</code> 表示被调整优先级（nice）的进程在用户模式下使用的时间。这里，nice 用于表示执行的优先级，从 -20（最高优先级）到 19（最低优先级）。默认的程序，优先级是 0；（注：这是一个 Unix 特有的功能，对于 Windows 用户来说，这个值永远是 0）</li>\n<li><code class=\"language-text\">sys</code> 表示进程在内核模式下使用的时间；</li>\n<li><code class=\"language-text\">idle</code> 表示空闲的时间；</li>\n<li><code class=\"language-text\">irq</code> 表示硬中断请求花费的时间。硬中断也叫外部中断，由外部硬件产生，如鼠标、键盘等。</li>\n</ul>\n</li>\n</ul>\n<p>有了以上的数据，就可以在 Node / Electron 程序中查看 CPU 的使用，从而对当前程序的执行情况有一个客观的了解。</p>","frontmatter":{"date":"2019-07-19","title":"CPU Usage via Nodejs","category":"Node.js"}}},{"node":{"id":"1362bb80-5413-560a-87cc-b09d62f95b50","html":"<p>在使用服务器编译上线包的过程中，可能会使用 nvm 来管理编译使用的 Node.js 版本。此时，运行时 Node.js 的二进制文件和实际服务器本身的 Node.js 文件将会是不同的。</p>\n<p>这样做的好处是可以隔离，保证编译的环境是稳定的。</p>\n<p>但是，当 npm 试图运行 Node.js 的时候，就要格外小心了。默认情况下，npm 会使用 path 中定义的 Node.js 版本。而对于打包服务器来说，这个 path 上的 Node.js 很可能并不是 nvm 管理的那个版本。</p>\n<p>举个例子，如果 <code class=\"language-text\">package.json</code> 中定义了 <code class=\"language-text\">postinstall</code> 的脚本，如下；</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"postinstall\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"some-cli\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那么，在 <code class=\"language-text\">yarn install</code> 之后，执行这个 <code class=\"language-text\">postinstall</code> 的过程中，<code class=\"language-text\">some-cli</code> 需要 Node.js 来执行，而 npm 使用的 Node.js 是 path 上的默认版本，和 nvm 管理的并不是同一个。命令行会有如下的报错：</p>\n<blockquote>\n<p>npm WARN lifecycle The node binary used for scripts is xxx but npm is using xxx itself. Use the <code class=\"language-text\">--scripts-prepend-node-path</code> option to include the path for the node binary npm was executed with.</p>\n</blockquote>\n<p>正如报错指出的，为了修正这个问题，需要用到 <code class=\"language-text\">scripts-prepend-node-path</code>。这样，当 npm 需要 Node.js 来执行代码的时候，会选择和自身匹配的 Node.js 版本，而不是默认 path 上的版本。（<a href=\"https://docs.npmjs.com/cli/run-script.html\">文档</a>）</p>\n<p>除了每次运行时加上命令行参数之外，一个比较简单的方法是使用 npm config 设置相对应的参数：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> config <span class=\"token builtin class-name\">set</span> scripts-prepend-node-path<span class=\"token operator\">=</span>true</code></pre></div>\n<p>或是在 .npmrc 中加上</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">scripts-prepend-node-path true</code></pre></div>\n<p>设置完后，就不会再有报错了。</p>","frontmatter":{"date":"2019-06-26","title":"scripts-prepend-node-path","category":"Node.js"}}},{"node":{"id":"734ea8a8-a015-503a-b7bb-cf9c28d3bda4","html":"<p>在 Node.js 中，<code class=\"language-text\">utils</code> 提供了 <code class=\"language-text\">debuglog</code> 模块可以用于调试信息的输出。默认情况下，<code class=\"language-text\">debuglog</code> 的内容是不会输出的，只有当 <code class=\"language-text\">NODE_DEBUG</code> 这个环境变量设置了合适的值，输出才会显示。这样，调试信息不会影响正常的使用，同时也依然保留了调试的需求。</p>\n<p>具体的使用如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> debuglog <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'util'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">debuglog</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">debuglog</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello world: [%d]'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上面的例子中，如果直接运行，是不会包含 <code class=\"language-text\">hello world: 1</code> 的输出的。如果设置 <code class=\"language-text\">NODE_DEBUG</code> 为 <code class=\"language-text\">name</code>（也就是 <code class=\"language-text\">debuglog</code> 函数调用时设置的值），那么再次运行，<code class=\"language-text\">hello world: 1</code> 就会输出了。</p>\n<p>同时，可以用逗号分隔的方式一次性为 <code class=\"language-text\">NODE_DEBUG</code> 设置多个值，比如：<code class=\"language-text\">NODE_DEBUG=foo,bar</code>。</p>\n<p>在 Mac 下，一次性设置 <code class=\"language-text\">NODE_DEBUG</code> 可以输入：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">NODE_DEBUG</span><span class=\"token operator\">=</span>name node ./index.js</code></pre></div>\n<p>在 Windows 下（Powershell），设置 <code class=\"language-text\">NODE_DEBUG</code> 可以输入：</p>\n<div class=\"gatsby-highlight\" data-language=\"powershell\"><pre class=\"language-powershell\"><code class=\"language-powershell\"><span class=\"token variable\">$env</span>:NODE_DEBUG=<span class=\"token string\">\"name\"</span><span class=\"token punctuation\">;</span> node <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>index<span class=\"token punctuation\">.</span>js</code></pre></div>\n<p>设置完成之后，<code class=\"language-text\">NODE_DEBUG</code> 会一直保留着，直到 powershell 被关闭。需要删掉原先设置的 <code class=\"language-text\">NODE_DEBUG</code>，可以输入：</p>\n<div class=\"gatsby-highlight\" data-language=\"powershell\"><pre class=\"language-powershell\"><code class=\"language-powershell\"><span class=\"token function\">Remove-Item</span> env:\\NODE_DEBUG</code></pre></div>","frontmatter":{"date":"2019-05-08","title":"debuglog in node.js","category":"Node.js"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"Node.js"}}}