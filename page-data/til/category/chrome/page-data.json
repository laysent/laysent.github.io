{"componentChunkName":"component---src-templates-til-category-js","path":"/til/category/chrome","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"6f7bce64-d072-5ef5-abd7-98cd4c6118b3","html":"<p>要知道一个网页中的文本，具体是使用什么字体渲染出来的，并不是非常简单的事情，可以有以下一些方案进行尝试。</p>\n<section><h2>getComputedStyle</h2><p>使用 <code class=\"language-text\">window.getComputedStyle</code> 属性获取对应元素的 <code class=\"language-text\">font-family</code> 字段。因为字体的设置一般是通过顶层配置，子元素继承的方式完成的，因此在大多数的元素上，并没有 <code class=\"language-text\">font-family</code> 设置。即使有，大概率也是通过 CSS 完成的，因此从 <code class=\"language-text\">.style</code> 或者 <code class=\"language-text\">.attributeStyleMap</code> 无法拿到需要的数据。<code class=\"language-text\">getComputedStyle</code> 可以获取当前元素上样式的最终计算值，因此即使字体实际来自于继承或者系统默认字体，都可以通过该 API 获取到。比如，在一个没有 CSS 设置的页面上，可以通过下面的代码知道具体使用的系统默认字体是什么：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">window<span class=\"token punctuation\">.</span><span class=\"token function\">getComputedStyle</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>fontFamily<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// MacOS (Chrome): Times</span>\n<span class=\"token comment\">// Windows (Chrome): Microsoft YaHei</span></code></pre></div><p>非编程的方案，可以在 Chrome DevTools 中直接找到 Elements 下的 Computed 部分，查看实际使用的 CSS 属性值。注：如果 <code class=\"language-text\">font-family</code> 并没有被定义过，可以勾选 All 来查看系统默认的属性值。</p><p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2f6b9b41cfadb16613696e96a940262e/cb0d3/2019-12-04-computed-style.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 130.95975232198143%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAABYlAAAWJQFJUiTwAAAD40lEQVRIx5WVi2/aVhjF+Uv336ybFjKSNMnWbR1dq6pb1ocqVVMndWuabqFZIh62IZSHedoY24BtwOAXZ9+9EAYk1VpLB/va3OPfvd/1uTHXddFut1EsFlEqlTAYDKB1VOQlAYW8CLlawXg0Qr3egCSJME0ThmHw84juO47Dxfr1ej3EuIGmodPpoKt1oOs6qi0TUrmNS7mDgtyF0u1B73b5i9lz1rHf73MT27ZhWRZvM8UajQYymQw3VDUDFxkRZ2kJqQsBTdVEvalAlPKQ5Srevy8in5egKHNjBjIcDrnplWKe52E6nXIZtgfN8qDbPp199IYBgsCH7/vwvIX8FVHfTcVw0xF59BMAMx9R4GEW+iRvTez+TUdsNpthKboRei5aJ0mkn+9C/uM79M9+gn6ahJFKwkzdo/M99E7vwkw/5f9f609aErIGh/MnUI73UX71JaTfvoB5tgcnvY/B+W3YF/v82kxtQ0vdX/a76ssJNw1DbwLt7SE0cR9/v72FdOoWikIc8mWC9DUqhV30hD0yfPDxhuqbA7TEBB78voOthwfYe3yA5Mvvcfflj3iR2oOajn+aoXJMhsI2Hh0nkXj2DIknjxA/eoivjh7j+V930ElvoXP6CYbaySEU6TZSmS2c57bwTy6Oc4GJXW+jm91F991HGrKitGnIjkTKf0vnb2CJh1w2XQ8LdzDI7KLzoSGvlnxOOIZGVe4eJ6C/2eHSXieovbNoE92fcRjv7vNlg81ls/mGKAzg6jI8s/afDGrr1YUqXK5Rx2xldNfWYRRFcy3MZ/+jqz7XvhSWGCalx9KQFBIlF33HIZsGpYrw9RHCFz8g/HUX0eefIfplGz49sxZptUwbhxKiT9kW0MceBswoXBd7wdRFaCgI60WEpTSCVz/Dz57AJ1SWlSwfWaTxtDFbLYwokgYUYXa5jAklhjuZzEXhyzWZwvVpbsMILBKafQdCpU5G5iKJVtKmryoY5/MYCgJ8wmeUAZkt6VZpA5ZAEQ9bQZCIyOGFCFZGFtObDViZNCwhB7t4yc+WKGA86GNCGTkhwgm9YLIgZkTliox6o8mJ3JXnTLGBqmIsinzYbqOOMe0rXr/Hq705n0EY8krKtL+0FXW+bjf+E9Mbc8JBLgunViNCAQ7FPadbefMVISteqVzlhIz2ZkJJwpCG6ZIhI+TV3pw/RsjmkA5m1mi2rq8IRmjQTuaQoV0uwcpmiE5em7dNQjZvakdDJieiVKEvx5tuENJuxwgZ3Yh2NZeK9CFCJvbtdnUDWapyrd7kVV4jNInQpqI4NXk5H8v1d4PY7qjTQs4XiqjKNd5eff4vE5Ka/A6hyHoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Screenshot of Chrome DevTools > Elements > Computed\"\n        title=\"\"\n        src=\"/static/2f6b9b41cfadb16613696e96a940262e/b9e4f/2019-12-04-computed-style.png\"\n        srcset=\"/static/2f6b9b41cfadb16613696e96a940262e/cf440/2019-12-04-computed-style.png 148w,\n/static/2f6b9b41cfadb16613696e96a940262e/d2d38/2019-12-04-computed-style.png 295w,\n/static/2f6b9b41cfadb16613696e96a940262e/b9e4f/2019-12-04-computed-style.png 590w,\n/static/2f6b9b41cfadb16613696e96a940262e/cb0d3/2019-12-04-computed-style.png 646w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p></section>\n<section><h2>Rendered Fonts</h2><p>使用 <code class=\"language-text\">getComputedStyle</code> 只能得到实际使用的 CSS 属性值，有时候并不能准确表达实际真实使用的具体字体类型。</p><p>举例来说，一个 <code class=\"language-text\">font-family</code> 定义可能是：</p><div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">body</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span>\n    <span class=\"token string\">'Rubik'</span><span class=\"token punctuation\">,</span>\n    -apple-system<span class=\"token punctuation\">,</span> <span class=\"token string\">'system-ui'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'BlinkMacSystemFont'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'PingFang SC'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Segoe UI'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Roboto'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Oxygen'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Ubuntu'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Cantarell'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Fira Sans'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Droid Sans'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Helvetica Neue'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Helvetica'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Arial'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Hiragino Sans GB'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Microsoft Yahei'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'WenQuanYi Micro Hei'</span><span class=\"token punctuation\">,</span> sans-serif；\n<span class=\"token punctuation\">}</span></code></pre></div><p>在如此众多的定义中，具体浏览器使用了哪一款字体，并不容易知道。这其中涉及到了大量的变量。用户使用的系统环境、字体下载情况、正在阅读的文字是中文还是英文等，这些都有可能影响到最终浏览器所选用的字体。甚至在不复杂的 <code class=\"language-text\">font-family</code> 设置下，最终的选用字体依然可能并不直观。举例来说，如果设置 CSS 为：<code class=\"language-text\">font-family: system-ui</code>，具体使用的字体并没有从设置的字段中直观的反馈出来。</p><p>Chrome DevTools 提供了一个 Rendered Fonts 功能，可以帮助开发者了解当前真实使用的字体。示意图如下：</p><p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dc6b98d142218bfc4e588ffbe34ab2d0/26dcc/2019-12-04-rendered-fonts.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 538px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 187.36059479553904%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAlCAYAAABCr8kFAAAACXBIWXMAABYlAAAWJQFJUiTwAAAFB0lEQVRIx51WyW4bRxCdjw5yygfkB5KD7zkFCAIYQbwFgeEttixS3HeJ5HAdchbOvvLlVZMjUbJkC27goXt6ZqpreVXVWhAE2Gw26PV6GI1GGA6H0HUdnh9gZjj4XO/hvN5HpdHHYLyC4/pYr1YIwxDyr+d52O12sCxLydGWyyUGgwEmk4l6sd0YuLocot/voUohnaGO+cZFpTnEh/M2qvUWut0uqtUqarUarq6ulKDFYqGEa9vtVmk36PdhmhauZgZqrQEq9S7RRrM7xMa00e92UK9dUFgHrVZLCRSMx2Ol3Ypa+74PLc9zlCPNcpgB4EQH7GLAljks8NAoigJZll3Pmmzu93tCrbAvMs65Whd5gjyLOadI0+QWkkSQqn9Ph3YQdtiUE1zXw2K1wehqBj/kT+keYZwjIuK0QJwckGYFgxJSeIobpfY3GsoQ813XRaf+Bp/fP8V08B/MRQ3bWRXm/AIW1/JsLWswZnX4DEKaZTiVcUug+MG2LTjT59Dbf6BX+R3R6iUK818k65dIN6+QGv8g5+zpTxlEg0oUDwvMRaBlwtFfIfaXGF1ekgFdzGa68qP4MxP/RQ682QtY5gbZ1wQWxZ4UOAiMfAMrw8RkqqM/GMFxdjBJDz+IKNA7CvyGhiJwu93AHL9A6K4YkAxbc0vyjrE2eMB6Ta4FCDybbnnGJFg9wmT60J6+Qp44KsLCzYwRTdJyZoSTEO7s5eNNdvVn2NtvkFsfUNgfkJrvkJnvkXOtYL1FMP/r2yYfaLODMT2DM38He0ZwtvS3CuqZkHfG5D1z36HW+W2Bd4kdhpEyL4i4FsQZCZ4iIGQdHvfjhGSPoq8TW+YojhETScI5KdfJzd7JHFKgcPcLDcsNeVme9BjcNzQpkpZpImLBFB+K2QK1Vs/59b7MYqJAtJYia9ukkOOolBVoATcnrNA+1T+q+mCpuquVPM/nM2bSTNVDg1zVRGrIhT+dIuBJEUuSaCsOP4VYIi5pt9t4/fo1ib7BJQlv2w7Jb1LgmpSzoRlkv91swm2werD6xqy6ydGkU0gQZEi1/vvZc3S6fZWWko4GW4BkkgjXXPYRj/0jYAvwW01E1DSnQIFoJH4rISa6no/Fco2pPlN7KsongdWkg1ntFmz2ix2ri/nxI6xKBTtqGx5NLRHHkTKt0WxTwx5anS4Lx1AV5fIbRZuc2ZFRdcGpw++jSRwnLBKG4ut932oBfebQ0Q59s2P3c6Wdsk0GrMaioVCj7MHiS302R6PVVi2z3C+/EWgZfeV3OtidfYLXaChfevUaYgYr54klL7NjqZ/Pl8rkIs9v8baEllB1f0Q/NBvwhwNWkTmCxRwhfZsKkZPkmsgSgDUPavaGvFn41yQ/hSacC8ijgA0/pBkxT4n4QuGEj2J+HAbYRTHmrRqW0wn34i/4eqg2pXPvOPh2Rz9eCFYT4O2fN1l1ty/jUeP4U+gBv/0MRMGDX2oWk1vYLrMwXa2ZQnJxKqMoDT0MfGS//ICw9g4iLjhG+S60erOFT2fn+Fyp4rxygWa7g8pFDbV6U1Vvhwfs2EeSX39E/OQn2BTmsHE5PFCqjKUUuIEmoV6S/XNexwTS2URbOU0iqa541NhsVeCy38heeSf074m0un1VLuoqjc7Oq7igZv3hSHFMTB9djjEYXmKoL7DZmtiwCMxJLYFJdnzhw/1X6t+jwnUnPbXvLf8PtQHte4Q8BFHqf1USFQCODxGiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Screenshot of Chrome DevTools > Elements > Computed > Rendered Fonts\"\n        title=\"\"\n        src=\"/static/dc6b98d142218bfc4e588ffbe34ab2d0/26dcc/2019-12-04-rendered-fonts.png\"\n        srcset=\"/static/dc6b98d142218bfc4e588ffbe34ab2d0/cf440/2019-12-04-rendered-fonts.png 148w,\n/static/dc6b98d142218bfc4e588ffbe34ab2d0/d2d38/2019-12-04-rendered-fonts.png 295w,\n/static/dc6b98d142218bfc4e588ffbe34ab2d0/26dcc/2019-12-04-rendered-fonts.png 538w\"\n        sizes=\"(max-width: 538px) 100vw, 538px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p><p>Chrome 会将当前选中元素真实使用的所有字体都列出来。需要注意两点：</p><ol>\n<li>需要选中一个有文字内容的元素，不然这里并不会显示；</li>\n<li>\n<p>选中的文字内容可能需要多种字体类型共同配合渲染，Chrome 会讲所有用到的元素都列举出来。</p>\n<p>比如，<code class=\"language-text\">笑，😊，smile</code> 这样一段文字，在 MacOS Chrome 下，默认就需要以下三种字体来进行渲染：</p>\n<ul>\n<li>Times（渲染英文）</li>\n<li>Songti SC（渲染中文）</li>\n<li>Apple Color Emoji（渲染 emoji）</li>\n</ul>\n<p>以上三种字体在 Rendered Fonts 中都会被列举出来。</p>\n</li>\n</ol><p>Chrome 的 Blog 介绍可以查看<a href=\"https://developers.google.com/web/updates/2013/09/DevTools-answers-What-font-is-that\">这里</a>。</p><p>这一方案暂时没有 JavaScript API 可以直接调用，无法在程序运行时进行自动的判断。</p></section>","frontmatter":{"date":"2019-12-04","title":"Rendered Fonts","category":"Chrome"}}},{"node":{"id":"e3c0f3bd-e7cf-579e-8fb1-d24187f5acdb","html":"<p>Google Chrome 的 DevTools 本质上也是一个由 Web 技术编写的应用，在必要的时候，可以通过以下的方式打开 DevTools 的 DevTools：</p>\n<ol>\n<li>首先打开 DevTools；</li>\n<li>选择将 DevTools 在独立窗口中打开，然后按下 Cmd + Opt + I（Mac）或 Ctrl + Shift + I（Windows）</li>\n</ol>\n<p>这样，就可以打开 DevTools 的 DevTools 了。</p>\n<p>注：这里一定要选择将最开始的 DevTools 在独立窗口打开，然后再按 Cmd + Opt + I；否则对于嵌入在页面中的 DevTools 来说，按下上面这个组合键，会将 DevTools 收回，而不是打开 DevTools 的 DevTools。</p>\n<p>另一个稍微麻烦一些的方法是：</p>\n<ol>\n<li>打开一个 DevTools；</li>\n<li>在 Chrome 中打开：<a href=\"chrome://inspect\">chrome://inspect</a>；</li>\n<li>选择 Other，就可以找到刚才打开的 DevTools 了，点击 <code class=\"language-text\">inspect</code> 链接，就可以打开这个指定 DevTools 的 DevTools 了。</li>\n</ol>\n<p>一个可以在 DevTools 的 DevTools 中进行的操作，是查看和修改 DevTools 中记录的 snippets。对应的 API 分别是：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">InspectorFrontendHost<span class=\"token punctuation\">.</span><span class=\"token function\">getPreferences</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">_</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">.</span>scriptSnippets<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nInspectorFrontendHost<span class=\"token punctuation\">.</span><span class=\"token function\">setPreference</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'scriptSnippets'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>yourSnippets<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>关于通过代码来管理 Chrome DevTools 中的 snippets，可以参考 GitHub 上的这个<a href=\"https://github.com/bahmutov/code-snippets/issues/23\">讨论</a>。</p>\n<p>同时，Chrome DevTools 本身也是开源的，代码可以在 <a href=\"https://github.com/ChromeDevTools/devtools-frontend\">GitHub</a> 上找到。</p>","frontmatter":{"date":"2019-11-15","title":"DevTools of DevTools","category":"Chrome"}}},{"node":{"id":"4728f0b5-54c6-5426-bf7a-4f6ed51ae6b6","html":"<p>在 Web 环境中，一般对内容的存储都是依托于 Cookie 或是 LocalStorage 进行的（个别会使用 IndexDB）。其实，在早些时候，Web 曾推出过一个 FileSystem 的标准（已经废弃），用于将数据直接存储到本地的沙盒环境中，方便日后的使用。这个 API 目前只有 Chrome 进行了实现。</p>\n<p><a href=\"https://www.html5rocks.com/en/tutorials/file/filesystem/\">这篇文章</a> 针对 FileSystem API 做了详细的介绍。<a href=\"https://github.com/summera/chromestore.js\">这个 GitHub 仓库</a> 则在 FileSystem 原生 API 的基础上，进行了二次封装。（注：第一个链接给出的文章，部分代码有误，可能无法正常运行。实际使用过程中，可以参考第二个链接给出的 GitHub 仓库中的相关代码进行调整）</p>\n<p>假设，需要实现一个分片的文件下载功能，即文件被服务器分割成很多块，通过 JavaScript 依次下载这些内容，再在本地拼接后提交给用户。这里，考虑到文件可能非常大，如果只是存储在内存中，一旦用户刷新页面或是遇到其他问题，已经下载的内容就都失效了，只能重新再来一次。这种情况下，可以考虑使用 FileSystem API 将分片的文件内容下载后先存放在本地的沙盒文件中，等到全部下载完成之后，再将拼接好的内容提交给用户。</p>\n<p>下面给出一个实例代码，用以介绍 FileSystem API 的可能使用方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/**\n * 实际中 Chrome 给出的 API 只用 window.webkitRequestFileSystem\n */</span>\n<span class=\"token keyword\">const</span> requestFileSystem <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>requestFileSystem <span class=\"token operator\">||</span>\n  window<span class=\"token punctuation\">.</span>webkitRequestFileSystem<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 下载 Link 并保存文件为 filename\n * 只是示例代码，实际的可行方案请参考 file-saver 的实现\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">download</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">link<span class=\"token punctuation\">,</span> filename</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  a<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> link<span class=\"token punctuation\">;</span>\n  a<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> <span class=\"token string\">'_blank'</span><span class=\"token punctuation\">;</span>\n  a<span class=\"token punctuation\">.</span>download <span class=\"token operator\">=</span> filename<span class=\"token punctuation\">;</span>\n  a<span class=\"token punctuation\">.</span><span class=\"token function\">click</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">blob<span class=\"token punctuation\">,</span> filename</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">errorHandler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fs</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/**\n     * 获取名为 filename 的文件，{ create: true } 表示如果文件不存在，就创建一个\n     * fileEntry 中包含的 API 可以用于对这个文件进行操作\n     */</span>\n    fs<span class=\"token punctuation\">.</span>root<span class=\"token punctuation\">.</span><span class=\"token function\">getFile</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> create<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">fileEntry</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      fileEntry<span class=\"token punctuation\">.</span><span class=\"token function\">createWriter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">writer</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">/**\n         * 指定文件的写入位置在当前文件内容的末尾\n         */</span>\n        writer<span class=\"token punctuation\">.</span><span class=\"token function\">seek</span><span class=\"token punctuation\">(</span>writer<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        writer<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onwriteend</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">/**\n           * FileSystem 中的文件，可以通过类似如下的 Link 获取到：\n           * filesystem:https://xxx.com/persistent/filename\n           * 具体的 URL 地址通过 `fileEntry.toURL()` 获取\n           */</span>\n          <span class=\"token keyword\">const</span> url <span class=\"token operator\">=</span> fileEntry<span class=\"token punctuation\">.</span><span class=\"token function\">toURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">download</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        writer<span class=\"token punctuation\">.</span>onerror <span class=\"token operator\">=</span> console<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">;</span>\n        writer<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>blob<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> errorHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> errorHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">/**\n   * 对于 PERSISTENT 存储的文件，需要事先通过浏览器询问权限\n   * 声明需要使用的大小为 blob.size\n   * 第二个参数是 success callback，在成功后调用，可以在这里进行文件读写\n   * 第三个参数是 error callback，用于处理报错\n   */</span>\n  navigator<span class=\"token punctuation\">.</span>webkitPersistentStorage<span class=\"token punctuation\">.</span><span class=\"token function\">requestQuota</span><span class=\"token punctuation\">(</span>\n    blob<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">,</span>\n    <span class=\"token parameter\">grantedBytes</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">/**\n       * 以 PERSISTENT 的方式，写入 grantedBytes 这么多的内容\n       * 允许写入会执行 handler，否则会执行 errorHandler\n       */</span>\n      <span class=\"token function\">requestFileSystem</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span><span class=\"token constant\">PERSISTENT</span><span class=\"token punctuation\">,</span> grantedBytes<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">,</span> errorHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    console<span class=\"token punctuation\">.</span>error\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * 示例代码的调用，将 hello world 写入到 output.txt 文件中\n */</span>\n<span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Blob</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'hello world'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> type<span class=\"token punctuation\">:</span> <span class=\"token string\">'text/plain'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'output.txt'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>上面这个例子，展示了如何将 Blob / File 写入到本地沙盒的文件中（例子中写入到了 <code class=\"language-text\">output.txt</code> 文件内）。有几点需要注意：</p>\n<ol>\n<li>文件是写入到沙盒环境中的，因而虽然 <code class=\"language-text\">fileEntry.fullPath</code> 的值是 <code class=\"language-text\">/output.txt</code>，并不代表真的可以在根目录下找到 output.txt 文件</li>\n<li><code class=\"language-text\">window.PERSISTENT</code> 和 <code class=\"language-text\">window.TEMPORARY</code> 是两种可能的存储方式。如果是 <code class=\"language-text\">PERSISTENT</code> 的，那么需要用户授权（也就是 <code class=\"language-text\">requestQuota</code> 做的事情）且清理需要程序或用户手动执行；如果是 <code class=\"language-text\">TEMPORARY</code> 类型的存储方式，那么浏览器可能会在某些情况下自动清理文件（比如，当空间不够的时候）</li>\n<li>通过 <code class=\"language-text\">fileEntry.toURL</code> API 可以拿到当前文件存储对应的 URL 地址，进而可以通过常规手段将这个内容下载到本地</li>\n<li>代码中的 <code class=\"language-text\">errorHandler</code> 函数写的比较粗糙，更丰富的 Error Handler 写法，可以参考 <a href=\"https://github.com/summera/chromestore.js/blob/e0981728534a28ce0a2cf80ed54d9f9f90279943/chromestore.js#L16\">chromestore.js</a> 中的代码</li>\n</ol>\n<p><a href=\"https://www.myairbridge.com/en/\">MyAirBridge</a> 网站可能使用了类似上面提到的技术来存储下载中的文件内容。</p>","frontmatter":{"date":"2019-09-12","title":"Save file in Chrome","category":"Chrome"}}},{"node":{"id":"c57bde4a-6b6b-53ad-91ee-62bfa1c36350","html":"<p>在前端组件中，有不少组件对鼠标的响应并不是通过 CSS 的 hover 来触发的，而是通过 JavaScript 监听对应的鼠标事件，然后再进一步修改 DOM 的结构。比如，Ant Design 中的 <a href=\"https://ant.design/components/popover/\">Popover</a> 控件，在鼠标移上去后，会在 DOM 中插入一组元素，并在鼠标移开后删除。</p>\n<p>在这种情况下，一旦出现样式上的问题，就不容易在 DevTool 中对样式进行查看了。因为只要一点击右键审查元素，Popover 的内容很可能就会因为触发了鼠标事件而消失不见。</p>\n<p>对于这种情况，没法直接用 DevTool 中的 CSS 模拟来强制样式显示。如果需要通过触发事件来触发 DOM 的修改机制（不论是 <code class=\"language-text\">dispatchEvent</code> 还是在 React Extension 中触发回调），总体上是比较麻烦的。因为组件的层级结构很可能很复杂，知道应该往哪儿触发什么事件，也不是个容易的事情。</p>\n<p>既然从程序的角度触发比较复杂，不如换个思路，考虑从行为的角度来触发。比如，如果是通过鼠标悬停触发的样式修改，那么就直接通过这种行为来触发。唯一的问题是：应该如何保持这种样式，不在鼠标离开的时候被重制（否则就没法在 DevTool 里进行查看了）。</p>\n<p>这种时候，有一个简单的方法可以“暂停”浏览器。在 Console 中输入：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">debugger</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>就会在三秒后触发 <code class=\"language-text\">debugger</code>，从而暂停 JavaScript 的执行。这时候，鼠标离开的事件不会得到响应，也就可以安心在 DevTool 中对样式进行仔细的查看和调整了。</p>\n<p>当然，这里触发 <code class=\"language-text\">debugger</code> 的方式可以根据实际情况来写。只要保证在 DOM 改变后触发 <code class=\"language-text\">debugger</code> 就可以了。</p>","frontmatter":{"date":"2019-08-20","title":"Inspect Element after MouseEnter","category":"Chrome"}}},{"node":{"id":"08ab2fbd-f230-5efa-885a-ae25171659e9","html":"<p>在 Chrome 调试的构成中，单步执行代码是常有的操作。然而，一般来说，出问题的很可能是业务代码，具体依赖的库（如 React 或者 Mobx 等）相对则是更加稳定的。如果单步调试的过程中，会频繁进出库相关的代码，显然会对调试造成很多的干扰，不利于问题的排查。</p>\n<p>为此，Chrome 提供了 Blackbox 的功能，可以帮助将部分指定的文件从调试中剔除。一旦使用 Blackbox 剔除了某些代码文件，那么：</p>\n<ul>\n<li>从这些文件中造成的报错不会暂停代码（除非开启了 Pause on exception）</li>\n<li>Step in/out/over 不会执行到这部分的代码</li>\n<li>这些文件中的事件监听断点不会触发</li>\n<li>文件中设置的断点也不会被触发（代码不会暂停）</li>\n</ul>\n<p>有几个方法可以添加 Blackbox：</p>\n<ol>\n<li>打开 DevTools 后按 F1 打开 Settings 界面，然后选择 Blackboxing 并填写</li>\n</ol>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cfc690ef64b8fa20f3d7653491ae0c05/b2a12/2019-08-12-blackbox-rule-screenshot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 40.476190476190474%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKUlEQVQoz41SXY+DIBD0//+7ez7bplV7/UABAUHUzu3Q9OGSXlKScRYWxtmFKoQJg9aIMWLbNoyjg/cezjkYYwsTn4zH44FKa4P9/gClFJZlRdO0aLsO558LmrYr8fF0QpgmzPOMlJJgLgZiTGVOzjk/BUMI6Pu+JLigJFaqRz9oiQcMwpOI0TmdPtkX99aOcKUajyjnOardbl8EmORgTFHO2QpjrThfsK6CP7xKi9bijKbI3FcZY8TFUMQyS27PxZ22TsqcBVlcxPcIMy7XG+q6hhYdVlLxw/7FOGFZN3w3FodO46osBpvk0P8YfRIzBvf7XVoxPgVplw5ft/x18KjPsjYm3HQsP+JL4OZ34Dn2nzG5Yu2vG5KLh3EZXZ9hfZb5Bi4z9yl+Afj4aleYhfmFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"DevTools 设置 Blackbox 匹配规则\"\n        title=\"\"\n        src=\"/static/cfc690ef64b8fa20f3d7653491ae0c05/b9e4f/2019-08-12-blackbox-rule-screenshot.png\"\n        srcset=\"/static/cfc690ef64b8fa20f3d7653491ae0c05/cf440/2019-08-12-blackbox-rule-screenshot.png 148w,\n/static/cfc690ef64b8fa20f3d7653491ae0c05/d2d38/2019-08-12-blackbox-rule-screenshot.png 295w,\n/static/cfc690ef64b8fa20f3d7653491ae0c05/b9e4f/2019-08-12-blackbox-rule-screenshot.png 590w,\n/static/cfc690ef64b8fa20f3d7653491ae0c05/b2a12/2019-08-12-blackbox-rule-screenshot.png 630w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>如果网站的标准库是通过 CDN 文件直接引入的，可以把文件名直接写在这里，如 <code class=\"language-text\">react.min.js</code> 或是 <code class=\"language-text\">jquery.min.js</code> 等；类似的，如果页面是通过 Webpack 进行打包的，那么 vendor 的部分很可能也会打包到一个独立的文件中，比如就叫 <code class=\"language-text\">vendor.xxx.js</code>，那么也可以把相应的匹配写在这里。</p>\n<ol start=\"2\">\n<li>打开 DevTools 后在 Sources 标签下找到需要屏蔽的文件，在文件内容处右键，并选择 Blackbox</li>\n</ol>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/301011fa6736a78f21b3cd10071e7032/34e8a/2019-08-12-blackbox-file-screenshot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 75.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAADXklEQVQ4y22UaU8bVxSG/Y+rSpWaECirsWPAJsZmTwihCRE7iVpFaqUqn5CifmlTiPG+jtdZPB7PeOXpmYHkQ9UZvZp7Z3nuec+cc30tVeM2maFYqqBpGrlcllarhaq2KBQKlEpF7747d5/puk61WiWVSlEu33+TzeZQlKr3na9aF0ihQjZfIZ0tCjxNKp2lUCyTyeb5+/M11zcJT/lCiVqtLnAVTdQ2NMy2jmnoNOpVWaCMz+4Y3BQtrm6apDN5EqkSyUyZVLbC9W2OL6kCLcOmpdu0rQH9/oDxaITTH1FRh9T04f1V66HpBr5Ox6RpOFRbHbGXkyhyYjVHLp/xxuVSXqJSUMVOvVaVcc2TLhGWlYaoTrGsU67odHUNX7vdZjjo4TgWxWaJdDVFopL4prSS5rZ8i6IqdO0uw+FQ3h9yJ1GOR0PGD/OBaDQY3AMdp4fV7WLabQzbQLd1fv/4G29PDrn85YKjsyPO3p1y8f6ct0eH7B+85OrTFc7IwepZfD1GsogH7AmwK0Dd0ml2mmhdjZ29bVYiS2xurxN+tsLWzgar0TCPJn/k+x++4+BwH6NneO/2hz36o77k1XkA9nrYti25bJKtZkgpKV7s77AcDrGxHScSXSG+sUY0tkpsPUpoKcj+mz3qao2sIrmuF0iWkqi6KkBTLNsOmpSA0qhIYjvoUltvXr8isOT3QC5wfStGfHONYGiRyZ8mODs7pafZdJumlE4XtWHgGF18pml6ds22SbVd5y/lmkQzzfOfn7MQmCMcXebpSoDlSIgl0Zx/honJRxxLXv97DN0cukDXrmEYNBrSFWJBqyTZfblBUECxzSirsQjP4qtE1sLMLc4yMfWY88szDzIej7m7u/PGg69/2QXqUu1G9h/sP//A+fCaw70t/MuLrMYjhCJPPaA/5GdmYZrHArx4d/H/QNeuK6tjUe+qfG4kuW3lxPIuoXDQizC4HGDGP82sRLcQnOeJ5PD4/NiD3D2cnuWhAN3GtizLa/KW1qDTNmibOjsvNgkE5omuRZhfmOXJ1IT8jEmmpiclhxOcnJ7cRzgYC8ktQrnI2Hd980WaXWCymzRkx2iUa9JKec5/PWX31TYHR/ts7W0Q24kS34190+WHSxKFhGwsGSqFIsVCnqK05L9QZQ5M8/57MAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"DevTools 设置单个文件 Blackbox\"\n        title=\"\"\n        src=\"/static/301011fa6736a78f21b3cd10071e7032/b9e4f/2019-08-12-blackbox-file-screenshot.png\"\n        srcset=\"/static/301011fa6736a78f21b3cd10071e7032/cf440/2019-08-12-blackbox-file-screenshot.png 148w,\n/static/301011fa6736a78f21b3cd10071e7032/d2d38/2019-08-12-blackbox-file-screenshot.png 295w,\n/static/301011fa6736a78f21b3cd10071e7032/b9e4f/2019-08-12-blackbox-file-screenshot.png 590w,\n/static/301011fa6736a78f21b3cd10071e7032/34e8a/2019-08-12-blackbox-file-screenshot.png 600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p><a href=\"https://developer.chrome.com/devtools/docs/blackboxing\">参考文档</a></p>","frontmatter":{"date":"2019-08-12","title":"Chrome DevTools Blackbox","category":"Chrome"}}},{"node":{"id":"616cd585-975b-5a22-a2d0-446930ea3200","html":"<p>在 Chrome 中，如果当前的光标在地址栏上，可以通过快捷键 <code class=\"language-text\">Cmd + Enter</code> 来打开一个和当前页面一样的新标签页（焦点依然在当前标签页上）。如果光标不在地址栏上，可以先使用 <code class=\"language-text\">Cmd + L</code> 来将光标移动到地址栏，然后再 <code class=\"language-text\">Cmd + Enter</code>。</p>\n<p>如果改用 <code class=\"language-text\">Option + Enter</code>，则可以新创建同一个 URL 地址的标签页，并将焦点定位到新打开的标签页上。</p>\n<p>如果改用 <code class=\"language-text\">Shift + Enter</code>，则可以在一个新窗口打开当前的 URL 地址。</p>","frontmatter":{"date":"2019-07-15","title":"Clone Current Tab in Chrome","category":"Chrome"}}},{"node":{"id":"348b50d4-59d3-552c-82ad-d5bfae743d07","html":"<p>在 Chrome 浏览器中，有专门用于页面截屏的扩展应用。其实 Chrome 自身也提供了截屏的工具。</p>\n<p>要使用 Chrome 自带的页面截屏方案，首先需要打开 Chrome DevTools。接下来，按 Cmd + Shift + P 打开指令搜索框。在搜索框中，搜索 <code class=\"language-text\">screenshots</code> 就可以找到和截屏相关的各个命令：</p>\n<ul>\n<li>Capture area screenshot - 可以截取<strong>页面</strong>某一个区域的图像（用鼠标选择）</li>\n<li>Capture full size screenshot - 可以截取整个页面的图像</li>\n<li>Capture node screenshot - 可以截取当前 DevTool 中选中的元素的图像</li>\n<li>Capture screenshot - 可以截取当前可视区域的图像</li>\n</ul>\n<p>其中，<code class=\"language-text\">Capture node screenshot</code> 是一个比较有意思的功能。在 DevTool 中选定了某一个元素（Element）之后，执行这个命令，就会将这个元素自身的区域截图。当然，元素所在区域内，由于排版的缘故，还存在父元素，子元素或是其他什么元素的内容。在执行截图命令的时候，这些内容也会被包含进去。</p>","frontmatter":{"date":"2019-06-25","title":"Screenshot in Chrome","category":"Chrome"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"Chrome"}}}