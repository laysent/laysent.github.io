{"componentChunkName":"component---src-templates-til-category-js","path":"/til/category/build","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"c366bb01-a2f9-54c4-ac76-8013cd32b800","html":"<p>在使用了 <a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin\">mini-css-extract-plugin</a> 的项目中，有时会遇到如下的 Warning 输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in chunk styles [mini-css-extract-plugin]\nConflicting order between:\n* css xxx/css-loader/dist/cjs.js!./e1.css\n* css xxx/css-loader/dist/cjs.js!./e2.css\n* css xxx/css-loader/dist/cjs.js!./e3.css</code></pre></div>\n<section><h2>tl;dr</h2><p>上面这段 Warning 的实际含义是：</p><blockquote>\n<p>由于没法找到最合适的解，plugin 被迫使用了相对最优的解，将 <code class=\"language-text\">e1.css</code> 放到了编译产物中。在某些 chunk group 中，<code class=\"language-text\">e2.css</code> 或 <code class=\"language-text\">e3.css</code> 这两个文件引用位置在 <code class=\"language-text\">e1.css</code> 之前；而在 plugin 将 <code class=\"language-text\">e1.css</code> 加入编译产物的时候，<code class=\"language-text\">e2.css</code> 和 <code class=\"language-text\">e3.css</code> 还没有被添加。</p>\n</blockquote><p>换句话说，如果 <code class=\"language-text\">e1.css</code> 本来的用途是覆盖 <code class=\"language-text\">e2.css</code> 的内容，且覆盖依靠的是同优先级下 CSS 定义出现的先后顺序，那么在 plugin 编译完成之后，这个覆盖就会失效。</p></section>\n<section><h2>造成 Warning 的例子</h2><p>以下通过一个直观的例子来说明 plugin 在何时可能会输出上述 Warning：</p><p>假设有两个文件 <code class=\"language-text\">entry1.js</code>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token string\">'./e1.css'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'./e2.css'</span><span class=\"token punctuation\">;</span></code></pre></div><p><code class=\"language-text\">entry2.js</code>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token string\">'./e2.css'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'./e1.css'</span><span class=\"token punctuation\">;</span></code></pre></div><p>且 Webpack 配置了需要将 <code class=\"language-text\">e1.css</code> 和 <code class=\"language-text\">e2.css</code> 打包到同一个文件中。如果 plugin 选择将 <code class=\"language-text\">e1.css</code> 放在 <code class=\"language-text\">e2.css</code> 的前面，那么就不满足 <code class=\"language-text\">entry2.js</code> 的使用顺序；反之则不满足 <code class=\"language-text\">entry1.js</code> 的。正是在这样的“矛盾”情况下，plugin 输出了一个 Warning，并选择了一个相对最优的解。</p></section>\n<section><h2>更好的 Warning</h2><p>上面提到的 mini-css-extract-plugin Warning 并不是非常直观，也很难知道具体是哪一个 chunk group 出现了问题。新提交的 PR <a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/pull/465\">#465</a> 以及 <a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/pull/468\">#468</a> 对此做了优化。优化后的输出类似：</p><div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in chunk styles [mini-css-extract-plugin]\nConflicting order. Following module has been added:\n * css xxx!./e1.css\ndespite it was not able to fulfill desired ordering with these modules:\n * css xxx!./e2.css\n   - couldn&#39;t fulfill desired order of chunk group(s) entry2\n   - while fulfilling desired order of chunk group(s) entry1</code></pre></div><p>根据 Warning 的提示，只需要观察 entry2 中对应的代码，就可以找到不满足的引入顺序了。</p></section>\n<section><h2>是否需要关心</h2><p>这个 Warning 是否需要关注，取决于 CSS 在项目中是如何被使用的：只要在项目的使用过程中，没有 CSS 是通过加载的顺序进行优先级覆盖的，那么就可以忽略 plugin 给出的 Warning；反之，如果有这样的情况，则一定需要根据 Warning 修正输出，防止编译导致的意外。</p><p>当然，最保险的做法是启用 CSS Module，从源头上保证各个模块间的 CSS 是不会相互覆盖的。</p></section>\n<section><h2>代码分析</h2><p>以下从这个 Warning 入手，分析 plugin 是如何从 modules 生成最终的打包产物的。</p><p>观察 mini-css-extract-plugin 的源代码，不难找到这个 Warning 的具体输出<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L494\">代码</a>。接下来，将针对这段代码所在的 <code class=\"language-text\">renderContentAsset</code> 进行分析，了解 plugin 生成打包产物的算法。</p><p>首先观察 <code class=\"language-text\">renderContentAsset</code> 函数最开始的<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L416\">比较语句</a>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> chunkGroup<span class=\"token punctuation\">.</span>getModuleIndex2 <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>这里，<code class=\"language-text\">chunkGroup.getModuleIndex2</code> 是 Webpack 4 中的 API，在之前的版本中不存在（Webpack 3 及之前使用的是 <a href=\"https://github.com/webpack-contrib/extract-text-webpack-plugin\">extract-text-webpack-plugin</a>）。接下来，重点关心 Webpack 4 对应的代码段。</p><p>首先看 <code class=\"language-text\">moduleDependencies</code> 变量的初始化（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L418\">源码</a>）：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> moduleDependencies <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span>modules<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p><code class=\"language-text\">moduleDependencies</code> 为每一个 module 都定义了一个对应的空 Set（具体 Set 内的值会在后续填充）。</p><p>接下来看 <code class=\"language-text\">modulesByChunkGroup</code> 变量的定义（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L423\">源码</a>）：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> modulesByChunkGroup <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>chunk<span class=\"token punctuation\">.</span>groupsIterable<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">cg</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">return</span> sortedModules<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>可以看到，<code class=\"language-text\">modulesByChunkGroup</code> 本质上，是将所有的 chunk group（<code class=\"language-text\">chunk.groupsIterable</code>）转化成了对应的 <code class=\"language-text\">sortedModules</code>。这里 <code class=\"language-text\">sortedModules</code> 变量的定义为（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L424-L434\">源码</a>）：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> sortedModules <span class=\"token operator\">=</span> modules\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      module<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">,</span>\n      index<span class=\"token punctuation\">:</span> cg<span class=\"token punctuation\">.</span><span class=\"token function\">getModuleIndex2</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// eslint-disable-next-line no-undefined</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>index <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> b<span class=\"token punctuation\">.</span>index <span class=\"token operator\">-</span> a<span class=\"token punctuation\">.</span>index<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div><p>简单来说，做了几件事情：</p><ol>\n<li>将 <code class=\"language-text\">modules</code> 中不属于当前 chunk group（<code class=\"language-text\">cg</code>）的部分剔除，对应的是 <code class=\"language-text\">.filter((item) =&gt; item.index !== undefined)</code>；</li>\n<li>根据 module 在 chunk group 中实际出现的位置，按从后往前进行排序，对应的是 <code class=\"language-text\">.sort((a, b) =&gt; b.index - a.index)</code></li>\n</ol><p>这里，越是先出现的 module 在最终的 <code class=\"language-text\">sortedModules</code> 数组中排的越靠后。换句话说，出现在数组最后的一个 module，没有任何前置的依赖（在该 chunk group 中，这个 module 是第一个被引入的）；而理论上来说，数组的第一个 module 依赖了数组后面的所有 modules（从 CSS 的角度来说，这个模块出现在最后。在所有选择器优先级一样的前提下，这个 module 理论上可以对之前所有的 module 进行覆盖）。这里采用倒叙的方式组织数组，是为了后续可以方便的使用 <code class=\"language-text\">Array.prototype.pop</code> 函数去获取当前没有依赖的 module。</p><p>接下来，<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L436-L442\">代码</a>对 <code class=\"language-text\">sortedModules</code> 变量值进行了填充：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> sortedModules<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> moduleDependencies<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>sortedModules<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> sortedModules<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>sortedModules<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>如上所述，<code class=\"language-text\">sortedModules</code> 中后出现的 module 是先出现 module 的依赖。这里的 <code class=\"language-text\">moduleDependencies</code> 变量记录了各个 module 的所有依赖（不仅仅是当前 chunk group 的依赖，所有 chunk group 的依赖最终都会被写入到这个 Set 中），其中 key 是各个 module，而对应的 value 则是一个 Set，Set 中的每个元素都是当前这个 module 的依赖。</p><p>之后定义了 <code class=\"language-text\">usedModules</code> 和 <code class=\"language-text\">unusedModulesFilter</code> 函数（<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L448-L450\">源码</a>），目的是为了判断某一个 module 是否已经被当前的 plugin 使用了。</p><p>接下来的<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L452-L455\">代码</a>需要确保所有的 modules 都会根据某个具体的算法在最终的编译产物中被使用到。这里判断的方法就是 <code class=\"language-text\">usedModules</code> 是否包含了 <code class=\"language-text\">modules</code> 中所有的内容。</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>usedModules<span class=\"token punctuation\">.</span>size <span class=\"token operator\">&lt;</span> modules<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> success <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> bestMatch<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> bestMatchDeps<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>至此，准备工作都做完了。接下来就是核心的部分：如何在各个 chunk group 中选取合适的 module，依次放到最终生成的 CSS 文件中。<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L458-L484\">代码</a>如下：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> list <span class=\"token keyword\">of</span> modulesByChunkGroup<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// skip and remove already added modules</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> usedModules<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">[</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    list<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// skip empty lists</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> module <span class=\"token operator\">=</span> list<span class=\"token punctuation\">[</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> deps <span class=\"token operator\">=</span> moduleDependencies<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// determine dependencies that are not yet included</span>\n    <span class=\"token keyword\">const</span> failedDeps <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>unusedModulesFilter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// store best match for fallback behavior</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>bestMatchDeps <span class=\"token operator\">||</span> bestMatchDeps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> failedDeps<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      bestMatch <span class=\"token operator\">=</span> list<span class=\"token punctuation\">;</span>\n      bestMatchDeps <span class=\"token operator\">=</span> failedDeps<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>failedDeps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// use this module and remove it from list</span>\n      usedModules<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      success <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>理想情况下，两个 CSS module 在最终编译产物中的先后顺序，应该和这两个 CSS module 在某一个 chunk group 中的先后顺序是一致的。如果顺序上无法保证一致，那么应该尽可能将不一致的情况降到最低。mini-css-extract-plugin 就是遵循这一个原则来对 module 进行排序的。在每一次的选取步骤中，算法都会依次遍历每一个 chunk group，做下面几个事情：</p><ol>\n<li>拿到当前该 chunk group 中没有依赖的那个 CSS module（<code class=\"language-text\">const module = list[list.length - 1];</code>）；</li>\n<li>判断这个拿到的 CSS module 是否有前置的依赖还没有被放到最终产物中去（<code class=\"language-text\">const failedDeps = Array.from(deps).filter(unusedModulesFilter)</code>）;</li>\n<li>如果没有前置依赖了，那么这个 CSS module 就可以被“安全”的放到当前的编译产物中去（<code class=\"language-text\">if (failedDeps.length === 0) {</code> 对应的部分）；</li>\n<li>如果有不满足的前置依赖，那么就去寻找不满足情况最少的一个（<code class=\"language-text\">bestMatchDeps.length &gt; failedDeps.length</code>），然后记下来（<code class=\"language-text\">bestMatchDeps = failedDeps;</code>）</li>\n</ol><p>如果找到了没有前置依赖的 module，代码就直接 break，跳到下一次 while 循环中去了；如果没有找到完美匹配的情况，就会进入接下来的<a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin/blob/50434b55c9df9cd3c26f2243e23df83e2964c720/src/index.js#L486-L507\">代码</a>：</p><div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// no module found => there is a conflict</span>\n  <span class=\"token comment\">// use list with fewest failed deps</span>\n  <span class=\"token comment\">// and emit a warning</span>\n  <span class=\"token keyword\">const</span> fallbackModule <span class=\"token operator\">=</span> bestMatch<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>ignoreOrder<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    compilation<span class=\"token punctuation\">.</span>warnings<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>\n        <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">chunk </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>chunk<span class=\"token punctuation\">.</span>name <span class=\"token operator\">||</span> chunk<span class=\"token punctuation\">.</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> [</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>pluginName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">]\\n</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token operator\">+</span>\n          <span class=\"token string\">'Conflicting order between:\\n'</span> <span class=\"token operator\">+</span>\n          <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"> * </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>fallbackModule<span class=\"token punctuation\">.</span><span class=\"token function\">readableIdentifier</span><span class=\"token punctuation\">(</span>\n            requestShortener\n          <span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\\n</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token operator\">+</span>\n          <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>bestMatchDeps\n            <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"> * </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">readableIdentifier</span><span class=\"token punctuation\">(</span>requestShortener<span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  usedModules<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>fallbackModule<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>上面代码中的 <code class=\"language-text\">bestMatch</code> 就是对应了最佳情况时候 modules 排序的数组，这里 <code class=\"language-text\">fallbackModule = bestMatch.pop()</code> 就可以拿到当前这个最佳情况的 chunk group 中，没有依赖的那个 CSS module。和之前代码中 <code class=\"language-text\">module = list[list.length - 1]</code> 拿到的数据是一样的。</p><p>同时，<code class=\"language-text\">bestMatchDeps</code> 对应的就是上面代码里的 <code class=\"language-text\">failedDeps</code> 数组，表示的是当前这个 <code class=\"language-text\">fallbackModule</code> 被选中时，有哪些该 module 的前置依赖并没有被事先放到编译产物中去。</p><p>接下来就是向 Webpack 输出 Warning 的代码了。再来看下面这段 Warning：</p><div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">WARNING in chunk styles [mini-css-extract-plugin]\nConflicting order between:\n* css xxx/css-loader/dist/cjs.js!./e1.css\n* css xxx/css-loader/dist/cjs.js!./e2.css\n* css xxx/css-loader/dist/cjs.js!./e3.css</code></pre></div><p>可知道，具体的含义是：由于没法找到最合适的解，plugin 被迫使用了相对最优的解，将 <code class=\"language-text\">e1.css</code> 放到了编译产物中。在某些 chunk group 中，<code class=\"language-text\">e2.css</code> 或 <code class=\"language-text\">e3.css</code> 这两个文件引用位置在 <code class=\"language-text\">e1.css</code> 之前；而在 plugin 将 <code class=\"language-text\">e1.css</code> 加入编译产物的时候，<code class=\"language-text\">e2.css</code> 和 <code class=\"language-text\">e3.css</code> 还没有被添加。</p></section>","frontmatter":{"date":"2019-11-28","title":"Conflicting order in mini-css-extract-plugin","category":"Build"}}},{"node":{"id":"4932e15d-274d-516f-988d-6f70cc3496f0","html":"<p>Chunk Group 是 Webpack 4 中新产生的一个概念。</p>\n<p>在 Webpack 中，一个文件/资源在打包时就是一个 module，一些 module 被打包到一起，生成一个 chunk。在原来的 Webpack 中，chunk 之间的依赖是一种父子关系：如果一个 chunk 有父 chunk，那么就可以认定，在这个 chunk 被加载的时候，至少其一个父 chunk 已经被加载了。在这种假设下，Webpack 可以对 chunk 进行一些优化，比如：如果一个 chunk 中的某个 module 被所有父 chunk 使用了，那么这个 module 就可以从 chunk 中删除（因为在加载 chunk 的时候，至少有一个父 chunk 已经被加载了，故这个 module 肯定已经存在了）。</p>\n<p>然而，这种父子关系的模式，并不利于 chunk 的拆分：在 CommonsChunkPlugin 中，如果一个 chunk 被拆分了出来，那么这个 chunk 会被“当作”是原来 chunk 的父 chunk 进行处理。这种父子关系其实是不正确的，因此也会影响到其他一些优化的进行。</p>\n<p>因此，在 Webpack 4 中，引入了 chunk group 的概念，目的就是修正这一概念。</p>\n<p>一个 chunk group，顾名思义，就是一组 chunk 的集合。一个 Webpack 的加载入口、或是一个异步加载点就是一个 chunk group，这个 group 中所有的 chunk 都是可以被并行加载的。同时，一个 chunk 也可以归属于多个不同的 chunk group。有了 chunk group 的概念，在通过 SplitChunksPlugin 进行拆分的时候，只需要将拆出来的 chunk 划分到对应的各个 chunk group 中去，就可以保证正常的使用了。</p>\n<p>参考文档见<a href=\"https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366\">这里</a>。</p>","frontmatter":{"date":"2019-11-27","title":"Chunk Group","category":"Build"}}},{"node":{"id":"6e82ef91-2e1a-58b0-879c-7e2818cfb8fd","html":"<p>在 Webpack 的配置中，有一个 <code class=\"language-text\">performance</code> 选项。根据 <code class=\"language-text\">performance</code> 中的配置，Webpack 可以针对打包后的结果的实际大小，进行警告或报错。</p>\n<p>具体的配置参数如下：</p>\n<ul>\n<li><code class=\"language-text\">performance.hints</code></li>\n</ul>\n<p>这个参数用于告诉 Webpack 最终产生的报告需要以什么样的方式呈现出来。可能的配置包括 <code class=\"language-text\">false</code>，<code class=\"language-text\">&#39;warning&#39;</code> 和 <code class=\"language-text\">&#39;error&#39;</code>。建议在 CI 中将这部分配置成 <code class=\"language-text\">&#39;error&#39;</code>，保证过大体积的文件无法被发布到线上。</p>\n<p>而具体多大的文件算“过大”，则需要用到下面提到的两个参数：</p>\n<ul>\n<li><code class=\"language-text\">performance.maxEntrypointSize</code></li>\n<li><code class=\"language-text\">performance.maxAssetSize</code></li>\n</ul>\n<p>前者表示入口文件能接受的最大文件尺寸（单位是 byte），后者表示其他生成的文件所能接受的最大尺寸（默认情况下包括了所有的 CSS，非入口 JS 文件，以及字体、图片等文件）。</p>\n<p>比如，入口 JavaScript 文件不能超过 250kb，而其余文件不能超过 100kb：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    maxEntrypointSize<span class=\"token punctuation\">:</span> <span class=\"token number\">250_000</span><span class=\"token punctuation\">,</span>\n    maxAssetSize<span class=\"token punctuation\">:</span> <span class=\"token number\">100_000</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>默认情况下，除了 <code class=\"language-text\">.map</code> 文件外，所有其他产生的文件都会被考虑在内。如果希望改变这个默认的行为，可以使用下面的这个参数：</p>\n<ul>\n<li><code class=\"language-text\">performance.assetFilter</code></li>\n</ul>\n<p>比如，只考虑 JavaScript 文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">assetFilter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">assetFilename</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> assetFilename<span class=\"token punctuation\">.</span><span class=\"token function\">endsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>官方文档在<a href=\"https://webpack.js.org/configuration/performance/\">这里</a>。</p>","frontmatter":{"date":"2019-10-23","title":"Webpack File Limit Error","category":"Build"}}},{"node":{"id":"dd5f1e33-ac72-5dc8-a677-eabec28b82f9","html":"<p>在 JavaScript 中，对模块的引用声明一般写在文件的顶部，而实际引用的 API，可能在运行时的非常晚才会被真正的使用到。看上去，这些 <code class=\"language-text\">import</code> 语句并没有什么问题。但实际上，由于引用模块自身的初始化工作以及可能的副作用，<code class=\"language-text\">import</code> 带来的性能损耗有时候也是不容忽视的。</p>\n<p>首先来看下面这个 JavaScript 文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> defaults <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'lodash'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">defaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// → { 'a': 1, 'b': 2 }</span></code></pre></div>\n<p>看上去是一段非常简单的 JavaScript 代码，只是执行了一个很简单的操作。基本等价于下面这段代码（Lodash 的 API 可以参考<a href=\"https://lodash.com/docs/4.17.15#defaults\">文档</a>）：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>然而两者有一个很重要的区别，就是前者引用了 Lodash 的 API。这个看上去是一个非常简单的操作，但实际上也有不小的消耗。在程序执行 <code class=\"language-text\">import</code> 语句的时候，会加载 Lodash 完整的初始化代码，并给 <code class=\"language-text\">defaults</code> 变量赋值 Lodash 的 defaults API。其中，Lodash 的初始化代码完整执行完成，需要大概 15ms 左右的时间。实际上，如果改成只引用 <code class=\"language-text\">defaults</code> 这一个 API，最终的效果就会好很多：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> defaults <span class=\"token keyword\">from</span> <span class=\"token string\">'lodash/defaults'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">defaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果累计了很多这样小的初始化成本，最终就会导致在应用实际启动的过程中，产生几百毫秒的延迟。这一点在 Web 应用中相对还好，毕竟体积和初始化速度多少存在着一些关系，而 Web 应用对体积非常的敏感；但是同样的问题，到了 Electron 项目中，就有可能变得不容小觑起来。作为 PC 级别的应用，Electron 的打包往往对体积没有那么严苛的要求。很多时候多一个库，少一个库，都没有太大的差别。然而，各个库初始化的速度累计起来，却有可能拖累本就不快的 App 启动速度。</p>\n<p>再举一个小例子。下面的这段代码看上去似乎没有什么问题：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> crypto <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'crypto'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">md5</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> crypto<span class=\"token punctuation\">.</span><span class=\"token function\">createHash</span><span class=\"token punctuation\">(</span><span class=\"token string\">'md5'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">digest</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hex'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>然而，实际加载 crypto 模块可能需要 5ms 的时间。这个时间在初始化的时候就用掉了，但实际用到 crypto 模块的时间却可能还早（或者压根最终没触发）。考虑到 require 本身就有缓存的机制，将这一步骤放到第一次执行的时候再做，就可以省下这 5ms 的加载时间：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">md5</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'crypto'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">createHash</span><span class=\"token punctuation\">(</span><span class=\"token string\">'md5'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">digest</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hex'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当然，上面只是一些例子。真正在实际的项目中需要解决这一问题，第一步，就是知道有哪些代码在初始阶段被加载了，分别花了多长的时间。这看上去是一个挺麻烦的工作，但如果应用是使用 Webpack 进行打包的，那么问题就变得不那么麻烦了。</p>\n<p>Webpack 由于需要支持 HMR 以及 Dynamic Import，在编译的时候需要打包一个运行时进去，用于管理各个 Chunk 之间的引用（正因如此，Webpack 的打包体积往往会大于用 Rollup 打包的体积）。而正因为有了这个统一的运行时，使得模块间引用的耗时变得非常容易统计了。只需要在下面这行代码的前和后，分别用 Performance 进行一次打点计时，就可以很容易的知道每一个模块实际的加载耗时了。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">modules<span class=\"token punctuation\">[</span>moduleId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>\n  module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">,</span>\n  module<span class=\"token punctuation\">,</span>\n  module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">,</span>\n  __webpack_require__\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>修改后的代码大概如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> performance <span class=\"token operator\">!==</span> <span class=\"token string\">\"undefined\"</span><span class=\"token punctuation\">)</span> performance<span class=\"token punctuation\">.</span><span class=\"token function\">mark</span><span class=\"token punctuation\">(</span>moduleId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmodules<span class=\"token punctuation\">[</span>moduleId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>\n  module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">,</span>\n  module<span class=\"token punctuation\">,</span>\n  module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">,</span>\n  __webpack_require__\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> performance <span class=\"token operator\">!==</span> <span class=\"token string\">\"undefined\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">measure</span><span class=\"token punctuation\">(</span>moduleId<span class=\"token punctuation\">,</span> moduleId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">clearMarks</span><span class=\"token punctuation\">(</span>moduleId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  performance<span class=\"token punctuation\">.</span><span class=\"token function\">clearMeasures</span><span class=\"token punctuation\">(</span>moduleId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里需要加上 <code class=\"language-text\">typeof performance !== &#39;undefined&#39;</code> 的主要原因是，一些 loader（如 css-loader）可能会在 Node 环境执行运行时的代码，这种情况下不可以直接调用 Performance 相关的 API，会报错。</p>\n<p>由于 Webpack 基于 Tapable 架构的关系，要编写一个插件来修改 Webpack 原本的运行时代码也非常的容易。观察 Webpack 的<a href=\"https://github.com/webpack/webpack/blob/758269e81456c946a96b521ee936dbec99d07132/lib/MainTemplate.js#L196\">源码</a> 不难发现，只需要针对 <code class=\"language-text\">mainTemplate</code> 的 <code class=\"language-text\">require</code> 进行一些改动就可以了。同时，从 Webpack 的代码历史来看，上面这句代码前后的 Comment 一直都没有变过。于是，只需要找到模块引用前后的注释，用字符串替换的方式，插入这些新的性能打点语句就可以了。</p>\n<p>最终的代码可以参考 NPM 的库 <a href=\"http://npmjs.com/package/webpack-require-performance-plugin\">webpack-require-performance-plugin</a>，源码在<a href=\"https://github.com/laysent/webpack-require-performance-plugin\">这里</a>。</p>","frontmatter":{"date":"2019-10-08","title":"Webpack Require Performance","category":"Build"}}},{"node":{"id":"c2ac584c-7986-51ff-af03-f2ebb8edf03d","html":"<p>在 Webpack 的编译过程中，可以通过 <code class=\"language-text\">devtool</code> 的配置选项选择以什么样的形式输出 SourceMap。Webpack 提供了非常多的选择方案，不同的选项可以达到的效果是不一样的，也会极大的影响最终编译的时间。Webpack 的官方<a href=\"https://webpack.js.org/configuration/devtool/\">文档</a>，从编译时间、重编译时间（针对 Watch 下的修改重编译）以及最终的使用效果三个纬度，给出了各个配置选项的实际效果。（中文版文档在<a href=\"https://webpack.docschina.org/configuration/devtool/\">这里</a>）</p>\n<p>一般情况下：生产环境最终的打包，建议使用 <code class=\"language-text\">source-map</code> 作为配置。这种配置会将 SourceMap 文件打包到另外一个独立的文件中，线上代码不会暴露源文件，同时提供了最精细的代码映射关系，方便线上代码的调试和问题定位。当然，这种配置的缺点也非常明显，就是构建过程比较花费时间，因此一般只建议在最终要上线的版本中使用这种配置。</p>\n<p>对于开发环境 Watch 模式下打包 Hot Reload 的版本，建议使用 <code class=\"language-text\">eval-source-map</code> 或者 <code class=\"language-text\">cheap-module-eval-source-map</code>。这两种模式，都会将代码用 <code class=\"language-text\">eval</code> 函数包裹起来，重编译的速度比较快，区别主要在于 SourceMap 的生成方案。前者会生成高品质的 SourceMap，因而初次构建的速度会比较慢，但是提供了行和列的映射；后者只提供了行层面的代码映射，因此会更加快一些，但是断点的效果会略打折扣（无法提供到列的映射关系）。</p>\n<p>更多的类型以及各种情况的说明，可以参考官方文档（链接在上面给出）。</p>","frontmatter":{"date":"2019-09-27","title":"SourceMap in Webpack","category":"Build"}}},{"node":{"id":"57f77e04-3b60-51bb-8fbf-1b73e3c87fb7","html":"<p>优化的第一步，是知道瓶颈在哪里。</p>\n<p>在针对 Webpack 编译速度优化的过程中，知道哪些 loader / plugin 运行耗费了很多时间就显得非常重要了。</p>\n<p>Speed Measure Plugin 是一款针对 Webpack 的插件，只需要一些非常简单的操作，插件就可以在已有配置的基础上，给 Webpack 的打包过程增加必要的计时功能，同时清晰的列举出各个 loader / plugin 在本次编译中的耗时情况。Plugin 的文档在<a href=\"https://github.com/stephencookdev/speed-measure-webpack-plugin#readme\">这里</a>。</p>\n<p>简单来说，只需要在原有的配置基础上，这么额外包一层 Speed Measure Plugin 就可以了：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> SpeedMeasurePlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"speed-measure-webpack-plugin\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> smp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SpeedMeasurePlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> disable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> smp<span class=\"token punctuation\">.</span><span class=\"token function\">wrap</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里，<code class=\"language-text\">disable: false</code> 表示需要 Speed Measure Plugin 记录时间，这也是默认的值，可以不传。如果赋值是 <code class=\"language-text\">true</code>，那么就会告知 Speed Measure Plugin 不要做任何处理，结果等同于没有使用 Speed Measure Plugin。如果需要经常对 Webpack 的打包进行优化，可以将 Speed Measure Plugin 的代码写入到库中，并通过环境变量等方法在打包的时候开启或关闭这个记录的功能。</p>","frontmatter":{"date":"2019-09-26","title":"Webpack Speed Measure","category":"Build"}}},{"node":{"id":"03867888-4df4-54ab-af0a-3ea92ffb495f","html":"<p>在 React 的开发中，需要在 Component 的 render 函数或是 Functional Component 的函数中，返回一个定义好的 JSX 内容，用于表示具体需要渲染出来的 UI 样式。Babel 或 TypeScript 会在编译时将这个对象转化成一个 JavaScript 可以理解的一般函数调用（具体调用的函数根据库的不同可能存在差异，对于 React 来说就是 <code class=\"language-text\">React.createElement</code> 函数，对于 Preact 来说则是 <code class=\"language-text\">h</code> 函数）。这个函数会在运行时被执行，并返回一个普通的 Object。React 拿到这个 Object 之后，就可以根据其中的内容来渲染出对应的 UI（根据具体执行的环境，这个步骤可能通过 React-DOM 或 React Native 来完成）。</p>\n<p>既然 JSX 的部分会被编译成普通的函数调用，并在运行时被反复执行，这里必然会有一些性能上的损耗。</p>\n<p>而在实际的开发中，存在着很多的组件，实际需要返回的 JSX 是固定不变的。比如说：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在上面这个例子中，实际上条件的第一种结果，返回的 JSX 是一个固定的值。手动的优化可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> loadingComponent <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> loadingComponent<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样，每次当 <code class=\"language-text\">loading = true</code> 的时候，都会直接返回 <code class=\"language-text\">loadingComponent</code>，而不需要反复执行 <code class=\"language-text\">React.createElement(Loading)</code> 这个函数去拿到最终的返回 Object。除了在运行时减少了重复计算，节省了时间和内存开销（这个在 re-render 非常频繁的时候有一定的优势），另一个好处是，React 可以通过比较返回的结果知道 Object 并没有发生变化，从而直接结束渲染的流程，不再进行接下来更深层次的渲染。</p>\n<p>这部分的操作，其实可以交给编译器去完成。Babel 有一个插件 <code class=\"language-text\">@babel/plugin-transform-react-constant-elements</code> 可以拿来做这方面的优化，具体的使用方式以及可能存在的问题可以参考<a href=\"https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements/\">文档</a>。</p>\n<p>当然，上面的优化依然存在小的瑕疵：因为把创建 Object 的操作提到了初始化的时候就直接进行了，如果存在大量类似的优化，会导致 JavaScript 初始运行的速度被减慢。大量的 Object 被事先创建了出来，而实际上这部分内容都远还没有到需要用的时候。一个更极致的优化可以这么写：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> loadingComponent<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LoadableButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>rest <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>loadingComponent<span class=\"token punctuation\">)</span> loadingComponent <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Loading</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> loadingComponent<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">rest</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这部分的操作就不是 Babel 插件原生支持的了。</p>\n<p>从目前的实际情况来看，生成 JSX 对应 Object 拖慢初始化的例子暂时还不存在（毕竟 <code class=\"language-text\">React.createElement</code> 的执行速度并不是非常慢，而且一个项目中的 JSX 数量也不会非常庞大）。如果有必要，可以 <a href=\"https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-react-constant-elements\">GitHub</a> 上提出 PR，按照类似上面提到的方式进行进一步的优化。</p>","frontmatter":{"date":"2019-09-19","title":"Babel JSX Improvement","category":"Build"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"Build"}}}