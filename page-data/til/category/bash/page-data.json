{"componentChunkName":"component---src-templates-til-category-js","path":"/til/category/bash","result":{"data":{"site":{"siteMetadata":{"title":"LaySent's Site"}},"allMarkdownRemark":{"edges":[{"node":{"id":"80ff40b4-417e-59fe-8b49-49f477af38e5","html":"<p><code class=\"language-text\">dd</code> 是一个 Bash 命令，可以用于文件/硬盘的整体拷贝。比如，希望将 Raspberry Pi 的 SD 卡复制一份，就可以使用 <code class=\"language-text\">dd</code> 这个命令来进行。</p>\n<p>但是默认的 <code class=\"language-text\">dd</code> 命令并没有进度提示，在完整执行完之前，默认在 stdout 中不会看到任何输出。</p>\n<p>如果想要获得当前 <code class=\"language-text\">dd</code> 的执行进度，可以尝试如下的一些方法：</p>\n<ol>\n<li>通过 <code class=\"language-text\">Control + T</code> 将 <code class=\"language-text\">SIGINFO</code> 发送给 <code class=\"language-text\">dd</code> 命令，<code class=\"language-text\">dd</code> 收到后会输出当前的进度信息；</li>\n<li>类似的，也可以通过 <code class=\"language-text\">pkill</code> 命令将 <code class=\"language-text\">SIGINFO</code> 发送给 <code class=\"language-text\">dd</code>：<code class=\"language-text\">pkill -INFO -x dd</code>。</li>\n</ol>\n<p>其中，针对第二点的命令，可以写一个简单的脚本来定时输出当前的进度：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> pgrep ^dd<span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span> <span class=\"token function\">pkill</span> -INFO <span class=\"token function\">dd</span><span class=\"token punctuation\">;</span> <span class=\"token function\">sleep</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">done</span></code></pre></div>\n<p><code class=\"language-text\">dd</code> 的输出结果示例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">1000+0 records in\n1000+0 records out\n67108864000 bytes transferred in 3.720346 secs (18038339571 bytes/sec)</code></pre></div>\n<p>更多方法（原理都是发送 <code class=\"language-text\">SIGINFO</code> 给 <code class=\"language-text\">dd</code>），可以参考<a href=\"https://www.commandlinefu.com/commands/view/11666/check-the-status-of-dd-in-progress-os-x\">这里</a>。</p>","frontmatter":{"date":"2019-11-20","title":"Progress of dd","category":"Bash"}}},{"node":{"id":"0442beaa-4143-5c44-ad49-5d031a3c488b","html":"<p>Raspberry Pi 的操作系统写在 SD Card 中。如果想将这个当前的系统做克隆（用于备份或存储迁移），可以通过 <code class=\"language-text\">dd</code> 命令来进行。</p>\n<ol>\n<li>将原始的 SD Card 以及新的 SD Card 插入电脑；</li>\n<li>通过 <code class=\"language-text\">diskutil</code> 命令来查看当前两张 SD Card 在 <code class=\"language-text\">dev</code> 中分别的命名是怎样的：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">diskutil list</code></pre></div>\n<p>运行后的结果大致如：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">/dev/disk2\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n  ...\n\n/dev/disk3\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   ...</code></pre></div>\n<p>其中 <code class=\"language-text\">/dev/disk2</code> 和 <code class=\"language-text\">/dev/disk3</code> 就分别是插入的两个 SD Card（具体在不同的机器上可能有所不同，需要根据 <code class=\"language-text\">diskutil</code> 列出的数据进行区分）。</p>\n<p>接下来，需要将 <code class=\"language-text\">/dev/disk3</code>（也就是新的 SD Card）进行 unmount 操作，因为 SD Card 最终要写成的格式并不是 MacOS “理解”的格式（这里只是进行了 unmount，文件系统已经不可访问了，但是物理的 SD Card 依然是系统可以访问的，因而可以被写成任意的格式）：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">diskutil unmountDisk /dev/disk2</code></pre></div>\n<p>最后，使用 <code class=\"language-text\">dd</code> 命令进行数据的克隆就可以了：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/dev/disk2 <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>/dev/disk3</code></pre></div>\n<p>当然，如果不需要克隆到新的 SD Card，只是做一个简单的备份，也可以将内容保存到本地的文件中：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/dev/disk2 <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>/path/to/file.dmg</code></pre></div>\n<p>还原备份只需要：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/path/to/file.dmg <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>/dev/disk3</code></pre></div>","frontmatter":{"date":"2019-11-19","title":"Clone SD Card","category":"Bash"}}},{"node":{"id":"b5fcadf5-c222-517c-b058-073a0dd96eb8","html":"<p>在 Bash 中，可以通过以下的命令跳转回上一个访问的目录：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> -</code></pre></div>\n<p>换句话说，<code class=\"language-text\">cd -</code> 可以在最后访问的两个目录间来回跳转。</p>","frontmatter":{"date":"2019-10-20","title":"back to previous folder","category":"Bash"}}},{"node":{"id":"d6be7486-bf8a-54af-bcea-03075a7085ee","html":"<p>在大多数时候，Mac 系统和 Linux 系统在终端的使用体验上是比较一致的，但偶尔也有一些命令，会出现两端不一样的情况。比如，当需要通过 <code class=\"language-text\">date</code> 命令获取昨天的日期。</p>\n<p>在 Mac 中，可以通过如下的命令来完成：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">date</span> -v <span class=\"token string\">'-1d'</span> <span class=\"token string\">'+%Y-%m-%d'</span></code></pre></div>\n<p>输出的结果是 <code class=\"language-text\">2019-08-25</code>。（这里，<code class=\"language-text\">&#39;+%Y-%m-%d&#39;</code> 指定 <code class=\"language-text\">date</code> 以“年-月-日”的格式输出日期；另外，如果想要得到明天的日期，可以通过 <code class=\"language-text\">+1 day</code> 或 <code class=\"language-text\">+1d</code> 来得到）</p>\n<p>然而，在 Linux 系统下，同样的命令无法使用。需要修改成：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">date</span> -d <span class=\"token string\">'-1 day'</span> <span class=\"token string\">'+%Y-%m-%d'</span></code></pre></div>\n<p>才可以得到同样的结果。这里需要注意一点，如果 Docker 是基于 Alpine 的，默认 <code class=\"language-text\">date</code> 不支持 <code class=\"language-text\">-d</code> 这个选项，需要额外安装 <code class=\"language-text\">coreutils</code> 之后，才可以使用。即，在 Dockerfile 中增加：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">RUN</span> apk add <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>update coreutils &amp;&amp; rm <span class=\"token punctuation\">-</span>rf /var/cache/apk/*</code></pre></div>\n<p>之后，上面的命令才能正确运行。</p>\n<p>如果希望一个命令可以在两个系统中运行，可以用如下的方法进行整合：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token environment constant\">$OSTYPE</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"darwin\"</span>* <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token function\">date</span> -v <span class=\"token string\">'-1d'</span> <span class=\"token string\">'+%Y-%m-%d'</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token function\">date</span> -d <span class=\"token string\">'-1 day'</span> <span class=\"token string\">'+%Y-%m-%d'</span></code></pre></div>\n<p>注意，这里需要使用 <code class=\"language-text\">[[</code> 进行判断，<code class=\"language-text\">[</code> 的比较是无法使用 <code class=\"language-text\">*</code> 元字符匹配的。当然，这里没有考虑 Windows 的情况，毕竟 Windows 的情况太特殊了，大部分的命令都不兼容。</p>","frontmatter":{"date":"2019-08-26","title":"Get Yesterday Date in Bash","category":"Bash"}}},{"node":{"id":"76114617-a7a9-588d-91b7-5cc2d9a7d4c2","html":"<p>安装 <code class=\"language-text\">etherwake</code> 用于 WOL (wake on LAN) 操作</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> etherwake</code></pre></div>\n<p>接下来，可以通过命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> etherwake -i eth0 AA:BB:CC:DD:EE:FF</code></pre></div>\n<p>来唤醒 AA:BB:CC:DD:EE:FF 这个 MAC 地址的设备。几点注意：</p>\n<ol>\n<li><code class=\"language-text\">etherwake</code> 需要 <code class=\"language-text\">sudo</code> 运行，否则会报错：<code class=\"language-text\">etherwake: This program must be run as root.</code></li>\n<li><code class=\"language-text\">-i eth0</code> 不是必须的。如果同时有有线和无线网卡，<code class=\"language-text\">-i</code> 可以强制要求 <code class=\"language-text\">etherwake</code> 走有线的路径</li>\n</ol>\n<p><a href=\"https://notenoughtech.com/featured/use-raspberry-pi-wol/\">参考文献</a></p>","frontmatter":{"date":"2019-08-06","title":"Raspberry Pi as WOL","category":"Bash"}}},{"node":{"id":"4da4b0bc-07b5-5fd9-a3a0-aa22a748c6c7","html":"<p>相比于 <code class=\"language-text\">scp</code>，<code class=\"language-text\">rsync</code> 命令可以在 SSH 拷贝的时候提供更多的灵活性，比如只拷贝新修改的或未存在的文件。</p>\n<p>一个简单的拷贝命令如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rsync</span> -auv /local/folder host:/remote/folder</code></pre></div>\n<p>这里，<code class=\"language-text\">-a</code> 表示拷贝所有的文件（包括子文件夹中的），<code class=\"language-text\">-u</code> 表示只拷贝修改时间更新的部分，<code class=\"language-text\">-v</code> 则会将结果输出到 stdin 中方便查看。类似的，还可以使用 <code class=\"language-text\">--ignore-existing</code> 来要求 <code class=\"language-text\">rsync</code> 只拷贝新的文件，忽略已经存在的部分。</p>\n<p>然而在实际使用的过程中，<code class=\"language-text\">rsync</code> 有如下报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Permission denied, please try again.\nrsync: connection unexpectedly closed (0 bytes received so far) [sender]\nrsync error: error in rsync protocol data stream (code 12) at io.c(235) [sender=3.1.2]</code></pre></div>\n<p>如果换同样的 SSH 配置，使用 <code class=\"language-text\">scp</code> 就不会有类似的报错，可见本身并不是 SSH 登陆账户权限的问题。这里的 Permission denied 报错非常的具有误导性。实际上，更可能的情况是 <code class=\"language-text\">rsync</code> 无法在远程主机上找到，需要通过 <code class=\"language-text\">--rsync-path</code> 参数手动指定。</p>\n<p>首先，可以先 SSH 到远程主机上，确认 <code class=\"language-text\">rsync</code> 本身是存在的：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rsync</span> --help</code></pre></div>\n<p>接着，可以通过 <code class=\"language-text\">type</code> 命令确认 <code class=\"language-text\">rsync</code> 的实际位置：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">type</span> -a <span class=\"token function\">rsync</span></code></pre></div>\n<p>这里，假设输出的结果是 <code class=\"language-text\">/bin/rsync</code>，那么，可以将原先的 <code class=\"language-text\">rsync</code> 命令改写为：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rsync</span> -auv /local/folder host:/remote/folder --rsync-path<span class=\"token operator\">=</span>/bin/rsync</code></pre></div>\n<p>再次运行就不会报错了。</p>\n<p><a href=\"https://superuser.com/questions/1017697/how-can-rsync-fail-due-to-missing-permissions-if-remote-login-occurs-with-root\">参考文档</a></p>","frontmatter":{"date":"2019-08-05","title":"Permission Denied for Rsync","category":"Bash"}}},{"node":{"id":"8a0f43f3-a20d-55b4-b583-513fd38b8f95","html":"<p>在 C 编程中，经常会用到 <code class=\"language-text\">Makefile</code> 来对源代码进行编译。一个简单的 <code class=\"language-text\">Makefile</code> 如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"makefile\"><pre class=\"language-makefile\"><code class=\"language-makefile\"><span class=\"token symbol\">out</span><span class=\"token punctuation\">:</span> input.c\n  <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> input.c -o out -Wall -Wextra -std<span class=\"token operator\">=</span>c99</code></pre></div>\n<p>这里，第一行的 <code class=\"language-text\">out: input.c</code> 表示 <code class=\"language-text\">make</code> 应该根据输入 <code class=\"language-text\">input.c</code> 来产出 <code class=\"language-text\">out</code> 这个文件。</p>\n<p>第二行的 <code class=\"language-text\">$(CC)</code> 会由 <code class=\"language-text\">make</code> 替换成本机的 cc 程序（即 <strong>c</strong> <strong>c</strong>ompiler）；后面跟着的是 <code class=\"language-text\">cc</code> 编译会用到的参数，包括输入源文件 <code class=\"language-text\">input.c</code>，输出文件 <code class=\"language-text\">out</code>，编译输出所有的 Warning（<code class=\"language-text\">-Wall</code> 即 <strong>W</strong>arning <strong>all</strong>，<code class=\"language-text\">-Wextra</code> 即 <strong>W</strong>arning <strong>extra</strong>），同时指定使用 <a href=\"https://en.wikipedia.org/wiki/C99\">C99</a> 标准来编译 C 代码（和 <a href=\"https://en.wikipedia.org/wiki/ANSI_C\">ANSI C</a> 相比，C99 允许在函数的任意位置定义变量，而不是必须在顶部）。</p>\n<p>运行 <code class=\"language-text\">make</code> 命令，程序会查找当前目录下的 <code class=\"language-text\">Makefile</code> 函数，读取其中的配置，根据输入输出的要求，查找文件，然后再选择编译。</p>\n<p>第一次编译，程序会用 <code class=\"language-text\">input.c</code> 编译出一个 <code class=\"language-text\">out</code> 文件来。</p>\n<p>在 <code class=\"language-text\">input.c</code> 没有修改的情况下，如果再运行一次 <code class=\"language-text\">make</code> 命令，会得到如下的输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">make: `out` is update to date.</code></pre></div>\n<p>这里，<code class=\"language-text\">make</code> 程序并没有通过任何外部文件的方式记录编译的情况。判断是否需要编译完全依赖于系统默认的文件功能，即简单的比较 <code class=\"language-text\">input.c</code> 和 <code class=\"language-text\">out</code> 两个文件的最后修改时间。如果 <code class=\"language-text\">out</code> 的最后修改时间比 <code class=\"language-text\">input.c</code> 要晚，就认为 <code class=\"language-text\">out</code> 是最新的，不再重复编译；如果 <code class=\"language-text\">input.c</code> 的最后修改时间晚于 <code class=\"language-text\">out</code> 的时间，或是 <code class=\"language-text\">out</code> 压根就不存在，那么 <code class=\"language-text\">make</code> 就会执行 <code class=\"language-text\">Makefile</code> 中配置的编译命令。</p>\n<p>可以通过以下方式欺骗 <code class=\"language-text\">Makefile</code> 来检查这一行为：</p>\n<ol>\n<li>修改一下 <code class=\"language-text\">input.c</code> 并保存</li>\n<li>删除 <code class=\"language-text\">out</code> 文件，然后用 <code class=\"language-text\">touch</code> 命令创建一个空的 <code class=\"language-text\">out</code> 文件。因为是先修改，再创建，所以 <code class=\"language-text\">out</code> 的创建时间会晚于 <code class=\"language-text\">input.c</code></li>\n<li>尝试执行 <code class=\"language-text\">make</code> 命令，会发现提示 <code class=\"language-text\">out</code> 已经是最新的，并没有执行真正的编译命令（尽管这里 <code class=\"language-text\">out</code> 并不是通过 <code class=\"language-text\">make</code> 编译出来的）</li>\n</ol>","frontmatter":{"date":"2019-08-04","title":"How Makefile works","category":"Bash"}}},{"node":{"id":"66614a0f-bbf7-571c-9238-585aeb01e816","html":"<p>在命令行中，一个命令会有一个返回数值，<code class=\"language-text\">0</code> 代表正确运行；如果命令返回了非 <code class=\"language-text\">0</code> 数据，则代表命令运行出现了错误。</p>\n<p>比如，如果 <code class=\"language-text\">Jest</code> 命令跑单元测试出现了错误，那么就会返回一个非 <code class=\"language-text\">0</code> 的值。运用 <code class=\"language-text\">set -e</code> 可以让 Bash 在遇到非零返回的命令行之后即停止，不再运行接下去的命令。</p>\n<p>那么，该如何确定之前的命令是否返回了 <code class=\"language-text\">0</code> 呢？</p>\n<p>可以简单的使用如下的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span></code></pre></div>\n<p>这里的 <code class=\"language-text\">$?</code> 就是上一个命令返回的数值。如果上一条命令执行成功，那么这里应该输出 <code class=\"language-text\">0</code>。</p>","frontmatter":{"date":"2019-08-02","title":"Check Exit Code of Command","category":"Bash"}}},{"node":{"id":"ff403c9a-6f68-5b69-8455-4f392804ddfe","html":"<p>在写 CI 脚本的时候，希望可以在脚本执行失败之后终止后续的所有操作。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"start\"</span>\n<span class=\"token function\">yarn</span> <span class=\"token builtin class-name\">test</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>如果 <code class=\"language-text\">yarn test</code> 这个命令失败了，希望不执行 <code class=\"language-text\">echo &quot;end&quot;</code> 语句。然而通过执行上面的代码，会发现默认是执行的。如果希望不执行这个操作，有几种思路：</p>\n<p>第一种，是用 <code class=\"language-text\">&amp;&amp;</code> 将语句串联起来，比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"start\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">yarn</span> <span class=\"token builtin class-name\">test</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>这样的方案，缺点是比较的麻烦。一旦东西比较多，就很难保证代码的可读性了。</p>\n<p>第二种方案，是使用 <code class=\"language-text\">set -e</code>，脚本改为：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">set</span> -e\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"start\"</span>\n<span class=\"token function\">yarn</span> <span class=\"token builtin class-name\">test</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"end\"</span></code></pre></div>\n<p>如此一来，脚本在语句执行失败（Exit Code 不是 0）之后就会退出，不会执行接下去的脚本。</p>\n<p><a href=\"http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#The-Set-Builtin\">参考文档</a></p>","frontmatter":{"date":"2019-08-01","title":"Exit when Command Fail","category":"Bash"}}},{"node":{"id":"2e81b8d0-f3e0-532c-85a0-c825c461e310","html":"<p>在 Docker 中使用 SSH 的功能时，发现 SSH 报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Bad owner or permissions on ~/.ssh/config</code></pre></div>\n<p>通过 <code class=\"language-text\">ls -l</code> 查看 <code class=\"language-text\">~/.ssh/config</code>，得到如下结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-rw------- 1 1000  1000   557 Jul 29 20:32 config</code></pre></div>\n<p>注意到给出的 User 和 Group 的值不是一个名字（如 <code class=\"language-text\">root</code>），而是一个数字。这说明，文件所属的 User / Group 无法找到。</p>\n<p>可以通过如下的命令查看当前 <code class=\"language-text\">root</code> 用户的 ID：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">id</span> -u root <span class=\"token comment\"># output => 0</span></code></pre></div>\n<p>可以看到和 <code class=\"language-text\">ls</code> 列出的 ID 是不匹配的。这说明，导致 SSH 无法正常工作的主要原因，是 <code class=\"language-text\">~/.ssh/config</code> 文件权限的设置有问题。可以通过如下的命令将权限分配给当前的 <code class=\"language-text\">root</code> 用户：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">chown</span> -R root:root /root/.ssh</code></pre></div>\n<p>再次运行 SSH 就可以正常工作了。</p>","frontmatter":{"date":"2019-07-30","title":"Bad owner or permissions","category":"Bash"}}},{"node":{"id":"8312bbc6-8a5d-567c-8c76-3a5c32b849b9","html":"<p>如果手上有多台设备在管理，SSH 的时候需要记住各个设备的 IP 地址、输入，总是很麻烦的。SSH 提供了配置文件的功能，可以为不同的 IP 设置别名，同时配置登陆需要用到的用户名和 RSA 私钥等。</p>\n<section><h2>配置方法</h2><p>修改 <code class=\"language-text\">~/.ssh/config</code> 文件，增加每个设备对应的配置数据。举例如下：</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Host pi\n    Hostname 192.168.xx.xx\n    User pi\n    IdentityFile ~/.ssh/id_pi_rsa</code></pre></div><p>这样就配置好了一个 Raspberry Pi 的别名。接下来，可以直接使用如下的命令来访问设备：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ssh</span> pi</code></pre></div><p>除了 SSH 之外，SCP 也可以使用同样的配置。比如：</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">scp</span> -r /local/path pi:/remote/path</code></pre></div></section>","frontmatter":{"date":"2019-07-28","title":"SSH Host Config","category":"Bash"}}},{"node":{"id":"6e1151e8-c2a8-5c67-a8a1-8447af786883","html":"<p><code class=\"language-text\">tldr</code> 是一个社区维护的命令工具，可以用于输出某一个命令的说明文档。相比于 <code class=\"language-text\">man</code> 详尽的文档，<code class=\"language-text\">tldr</code> 更侧重于例子。通过具体的使用场景，介绍该命令一些常用的方法。</p>\n<p><code class=\"language-text\">tldr</code> 相关的一些链接地址：<a href=\"https://github.com/tldr-pages/tldr\">GitHub</a>，<a href=\"https://tldr.sh/\">官方网站</a>。</p>\n<p>安装 <code class=\"language-text\">tldr</code> 可以使用 <code class=\"language-text\">brew</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> tldr</code></pre></div>\n<p>比如，需要了解 <code class=\"language-text\">tar</code> 的使用方法，可以运行下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">tldr <span class=\"token function\">tar</span></code></pre></div>\n<p>运行的结果如下：</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/afb42628221addee006643b75e3c5988/04a72/2019-07-03-tldr-screenshot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 74.28571428571428%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAABrklEQVQ4y5WTaVLrQAyEc554t2dfnUDgwf3v00+SYyoUAcKPrvEkVe2v1fLBBw/jNKZpwrFp0HXdF7Vte/f3ezo452CMxjiOmOcZfd+jIeOmbcSoub6Enx8xPtRa8f7+hsvlGW//XlFLgTUGgcitNXDW/o2QqVJyyDWinDLyVetzhQ8Oy7L80ZBmF6xCjB55zQjJI+QAR2ZMyIa3sR8yTN4gR4fTZRXKtCY4Z6GVkviKzubG7CfjA7frrN5EpiF7KckTqYsWnu5c2F7KbvadKc2QCB0RUsx6rogc2Vs8vZwxLRNmvTXf9d2m3wjZsBBZYcOnKrFjDZjUhMUsUDRf7Uheix4yTMEikSnPrp6LxGay3VDZ7eT7x0527felRJpZopipJBRqOhJtP/YYpgHjPIokvpo/Ed7OdZeUEqhlnhsTRtpHLoIpPVFvd9rHK6Gi+K44OXWgIrOFCQYmGrmLYTS0h1RMWQtRRlnolKMo0H5qSsCFcDn9QOSkj+dxkHOXfClcykokp8tJvhCOxjOcSMfjURb7Xry7kcdhRN+0GDp+84CB3ix/Npse/eR2/Qc7FNr+H6tgOQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"tldr command result\"\n        title=\"\"\n        src=\"/static/afb42628221addee006643b75e3c5988/b9e4f/2019-07-03-tldr-screenshot.png\"\n        srcset=\"/static/afb42628221addee006643b75e3c5988/cf440/2019-07-03-tldr-screenshot.png 148w,\n/static/afb42628221addee006643b75e3c5988/d2d38/2019-07-03-tldr-screenshot.png 295w,\n/static/afb42628221addee006643b75e3c5988/b9e4f/2019-07-03-tldr-screenshot.png 590w,\n/static/afb42628221addee006643b75e3c5988/04a72/2019-07-03-tldr-screenshot.png 840w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>注：<code class=\"language-text\">tldr</code> 的全称是 Too Long; Don’t Read。可以理解成“摘要”的意思。</p>","frontmatter":{"date":"2019-07-03","title":"Command `tldr`","category":"Bash"}}},{"node":{"id":"0e7dd42e-99b7-5ce6-a6d3-70c99e1958c7","html":"<p><code class=\"language-text\">ssh</code> 自带跳板机功能：<code class=\"language-text\">-J</code>。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ssh</span> -J userA@a.xxx.com userB@b.xxx.com</code></pre></div>\n<p>命令会需要依次输入 a.xxx.com 和 b.xxx.com 两台机器的登陆信息。校验通过之后，就会登陆 b.xxx.com 这台机器，登陆的用户是 userB。并且，登陆是通过 a.xxx.com 这台机器的 userA 完成的。a.xxx.com 在这里就是一个跳板机的功能。</p>\n<p><a href=\"https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/blob/master/docs/ssh_and_cluster/powerful-ssh-options-you-dont-know.md\">参考文档</a></p>","frontmatter":{"date":"2019-06-18","title":"SSH ProxyJump","category":"Bash"}}},{"node":{"id":"3bf8fb2c-bc26-5383-b33e-a3b271ad750e","html":"<p>Glob 类似于 Regular Expression，主要的使用场景是用于批量的文件匹配，在 bash 或是配置文件中常常被使用。下面列举了一些常见的语法规则：</p>\n<ul>\n<li><code class=\"language-text\">*</code> 匹配任意多个字符（包括匹配零个）</li>\n<li><code class=\"language-text\">?</code> 匹配任意一个字符</li>\n<li><code class=\"language-text\">[abc]</code> 匹配方括号中的任意一个字符</li>\n<li><code class=\"language-text\">[!abc]</code> 或 <code class=\"language-text\">[^abc]</code> 匹配除了方括号中定义的三个字符外的任意字符</li>\n<li><code class=\"language-text\">[a-z]</code> 匹配方括号定义范围内的任意一个字符</li>\n<li><code class=\"language-text\">[!a-z]</code> 或 <code class=\"language-text\">[^a-z]</code> 匹配除了方括号定义范围内的任意一个字符</li>\n<li><code class=\"language-text\">{ab,cd,ef}</code> 匹配花括号中定义的三个字符串中的任意一个</li>\n</ul>\n<p>举个例子，如果 Jest 的单元测试文件命名规范的正则表达式是：<code class=\"language-text\">.+\\.(?:test|spec)\\.[tj]sx?$</code>，也就是匹配下面的这些文件：</p>\n<ul>\n<li>a.test.js</li>\n<li>b.test.jsx</li>\n<li>c.test.ts</li>\n<li>d.test.tsx</li>\n<li>e.spec.js</li>\n<li>f.spec.jsx</li>\n<li>g.spec.ts</li>\n<li>h.spec.tsx</li>\n</ul>\n<p>那么，相应的 Glob 可以写：<code class=\"language-text\">*.{test,spec}.{js,jsx,ts,tsx}</code>。</p>\n<p>如果不涉及到 React 的代码（没有 jsx），可以写成：<code class=\"language-text\">*.{test,spec}.[tj]s</code>。</p>\n<p>参考文档：</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Glob_(programming)\">Wikipedia</a></li>\n<li><a href=\"http://www.jedit.org/users-guide/globs.html\">Glob Patterns</a></li>\n<li><a href=\"http://www.globtester.com/\">globtester</a></li>\n</ul>","frontmatter":{"date":"2019-06-02","title":"glob","category":"Bash"}}},{"node":{"id":"fd9d83bc-327b-51d5-8fc6-bde114eda7c6","html":"<p><code class=\"language-text\">npm</code> 和 <code class=\"language-text\">yarn</code> 都提供升级依赖的命令。</p>\n<p>针对 <code class=\"language-text\">npm</code>，可以使用 <code class=\"language-text\">npm update</code> 来执行，命令格式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm update [-g] [&lt;pkg&gt;...]</code></pre></div>\n<p>更新的时候，默认会更新 <code class=\"language-text\">package.json</code> 文件，可以通过增加 <code class=\"language-text\">--no-save</code> 标记来禁用这一改动。</p>\n<p><code class=\"language-text\">npm</code> 的文档可以看<a href=\"https://docs.npmjs.com/cli/update\">这里</a>。</p>\n<p><code class=\"language-text\">yarn</code> 的命令会更加丰富一些，命令格式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">yarn upgrade [package | package@tag | package@version | @scope/]... [--pattern]</code></pre></div>\n<p>其中，<code class=\"language-text\">--pattern</code> 后面可以跟 grep 的 pattern，只有匹配到的依赖会被升级。</p>\n<p>默认情况下，升级会参考 <code class=\"language-text\">package.json</code> 里定义的依赖允许的升级范围来选择可行的最高版本进行升级。如果希望直接升级到最新版本（往往意味着会有 breaking change），那么可以加上 <code class=\"language-text\">--latest</code> 标志。</p>\n<p><code class=\"language-text\">yarn</code> 的文档可以看<a href=\"https://yarnpkg.com/lang/en/docs/cli/upgrade/\">这里</a>。</p>","frontmatter":{"date":"2019-05-28","title":"Upgrade Npm Dependencies","category":"Bash"}}},{"node":{"id":"3f47cf73-7254-5344-925b-f5936feefdee","html":"<p>以下 Bash 代码可以递归删除指定的 <code class=\"language-text\">.map</code> 文件。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> -type f -name <span class=\"token string\">'*.map'</span> -delete</code></pre></div>\n<p>如果同时希望删除 <code class=\"language-text\">.map</code> 和 <code class=\"language-text\">.xxx</code> 文件，可以加上 <code class=\"language-text\">-o</code> flag</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> -type f -name <span class=\"token string\">'*.map'</span> -o -name <span class=\"token string\">'.*'</span> -delete</code></pre></div>\n<p>一些参数说明：</p>\n<ul>\n<li><code class=\"language-text\">-type f</code> 表示需要查找的是文件</li>\n<li><code class=\"language-text\">-name &#39;xxx&#39;</code> 定义需要匹配的文件名</li>\n<li><code class=\"language-text\">-o</code> 表示 or，后面可以跟新的匹配规则</li>\n<li><code class=\"language-text\">-delete</code> 表示匹配到的文件需要被删除</li>\n</ul>","frontmatter":{"date":"2019-05-27","title":"Recursively delete files by type","category":"Bash"}}},{"node":{"id":"8651fdc2-3dea-54f2-b8c4-334f2d3fe462","html":"<p>如果需要对目录下文件的占用空间做排序，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">du</span> -d <span class=\"token number\">3</span> -k <span class=\"token operator\">|</span> <span class=\"token function\">sort</span> -h</code></pre></div>\n<p>其中，<code class=\"language-text\">du -d 3</code> 表示，最多显示三层子目录，<code class=\"language-text\">-k</code> 会让输出以 <code class=\"language-text\">KB</code> 作为单位。<code class=\"language-text\">sort -h</code> 会对结果进行排序，排序的依据是文件夹的大小。这里，排序需要带上 <code class=\"language-text\">-h</code> 的标识位，不然以字符串进行排序的话，输出没有意义（比如，100 会排在 9 的前面）。</p>","frontmatter":{"date":"2019-05-22","title":"Disk Usage of Folder","category":"Bash"}}},{"node":{"id":"f93b4a7b-b93f-56a2-90df-49f2d5b3b93e","html":"<p>在 Mac 系统里面，<code class=\"language-text\">.app</code> 程序本质上就是一个目录，里面包含了很多文件。如果直接在 Terminal 输入 <code class=\"language-text\">.app</code> 的地址，会进入这个目录，而不是运行这个 App。如果需要运行，可以使用下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">open</span> /Application/Example.app</code></pre></div>\n<p>如果需要指定 <code class=\"language-text\">NODE_ENV</code> 等信息，就可以一起配合使用</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">NODE_ENV</span><span class=\"token operator\">=</span>development <span class=\"token function\">open</span> /Application/Example.app</code></pre></div>","frontmatter":{"date":"2019-05-14","title":"Open Application in Terminal","category":"Bash"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"Bash"}}}